import {
  concat,
  fromString,
  import_pino,
  k,
  toString
} from "./chunk-P3YGFEMI.js";
import {
  HashMD
} from "./chunk-PM35BVFT.js";
import {
  LruMap,
  checksumAddress,
  defineFormatter,
  hexToBigInt,
  hexToNumber,
  isHex,
  keccak256,
  keccak_256,
  numberToHex,
  toHex
} from "./chunk-4W52P3LT.js";
import {
  rotl,
  wrapConstructor
} from "./chunk-FUPOJN5U.js";
import {
  C,
  IEvents,
  Po,
  Qe,
  Qo,
  destr,
  detect,
  esm_default,
  esm_exports,
  f,
  f2,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  getBigIntRpcId,
  i,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  o,
  payloadId,
  r,
  require_cjs,
  require_cjs2,
  require_cjs3,
  sn
} from "./chunk-GPXFYCIE.js";
import {
  require_quick_format_unescaped,
  safeJsonParse,
  safeJsonStringify
} from "./chunk-MCSEDICF.js";
import {
  clear,
  createStore,
  del,
  get,
  keys,
  set
} from "./chunk-ANJCMEYS.js";
import {
  require_events
} from "./chunk-NPY75PGV.js";
import {
  __commonJS,
  __toESM
} from "./chunk-ONY6HBPH.js";

// node_modules/@walletconnect/core/node_modules/pino/browser.js
var require_browser = __commonJS({
  "node_modules/@walletconnect/core/node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k9) {
          return k9 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write) opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false) opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log) logger.log = noop;
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger.levels = pino.levels;
      logger.level = level;
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = child;
      if (transmit2) logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger, "error", "log");
        set2(setOpts, logger, "fatal", "error");
        set2(setOpts, logger, "warn", "error");
        set2(setOpts, logger, "info", "log");
        set2(setOpts, logger, "debug", "log");
        set2(setOpts, logger, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts, logger, level, fallback2) {
      const proto = Object.getPrototypeOf(logger);
      logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback2] || noop;
      wrap(opts, logger, level);
    }
    function wrap(opts, logger, level) {
      if (!opts.transmit && logger[level] === noop) return;
      logger[level] = /* @__PURE__ */ function(write) {
        return function LOG() {
          const ts3 = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i5 = 0; i5 < args.length; i5++) args[i5] = arguments[i5];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject) write.call(proto, asObject(this, level, args, ts3));
          else write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue) return;
            transmit(this, {
              ts: ts3,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger.level],
              send: opts.transmit.send,
              val: logger.levelVal
            }, args);
          }
        };
      }(logger[level]);
    }
    function asObject(logger, level, args, ts3) {
      if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o2 = {};
      if (ts3) {
        o2.time = ts3;
      }
      o2.level = pino.levels.values[level];
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1) lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o2, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0) o2.msg = msg;
      return o2;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i5 in args) {
        if (stdErrSerialize && args[i5] instanceof Error) {
          args[i5] = pino.stdSerializers.err(args[i5]);
        } else if (typeof args[i5] === "object" && !Array.isArray(args[i5])) {
          for (const k9 in args[i5]) {
            if (serialize && serialize.indexOf(k9) > -1 && k9 in serializers) {
              args[i5][k9] = serializers[k9](args[i5][k9]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i5 = 1; i5 < args.length; i5++) {
          args[i5] = arguments[i5 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger, opts, args) {
      const send = opts.send;
      const ts3 = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      applySerializers(
        args,
        logger._serialize || Object.keys(logger.serializers),
        logger.serializers,
        logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
      );
      logger._logEvent.ts = ts3;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a2) {
      return a2;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o2) {
        return typeof o2 !== "undefined" && o2;
      }
      try {
        if (typeof globalThis !== "undefined") return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@walletconnect/sign-client/node_modules/pino/browser.js
var require_browser2 = __commonJS({
  "node_modules/@walletconnect/sign-client/node_modules/pino/browser.js"(exports, module) {
    "use strict";
    var format = require_quick_format_unescaped();
    module.exports = pino;
    var _console = pfGlobalThisOrFallback().console || {};
    var stdSerializers = {
      mapHttpRequest: mock,
      mapHttpResponse: mock,
      wrapRequestSerializer: passthrough,
      wrapResponseSerializer: passthrough,
      wrapErrorSerializer: passthrough,
      req: mock,
      res: mock,
      err: asErrValue
    };
    function shouldSerialize(serialize, serializers) {
      if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k9) {
          return k9 !== "!stdSerializers.err";
        });
        return hasToFilter;
      } else if (serialize === true) {
        return Object.keys(serializers);
      }
      return false;
    }
    function pino(opts) {
      opts = opts || {};
      opts.browser = opts.browser || {};
      const transmit2 = opts.browser.transmit;
      if (transmit2 && typeof transmit2.send !== "function") {
        throw Error("pino: transmit option must have a send function");
      }
      const proto = opts.browser.write || _console;
      if (opts.browser.write) opts.browser.asObject = true;
      const serializers = opts.serializers || {};
      const serialize = shouldSerialize(opts.browser.serialize, serializers);
      let stdErrSerialize = opts.browser.serialize;
      if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1) stdErrSerialize = false;
      const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
      if (typeof proto === "function") {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
      }
      if (opts.enabled === false) opts.level = "silent";
      const level = opts.level || "info";
      const logger = Object.create(proto);
      if (!logger.log) logger.log = noop;
      Object.defineProperty(logger, "levelVal", {
        get: getLevelVal
      });
      Object.defineProperty(logger, "level", {
        get: getLevel,
        set: setLevel
      });
      const setOpts = {
        transmit: transmit2,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
      };
      logger.levels = pino.levels;
      logger.level = level;
      logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
      logger.serializers = serializers;
      logger._serialize = serialize;
      logger._stdErrSerialize = stdErrSerialize;
      logger.child = child;
      if (transmit2) logger._logEvent = createLogEventShape();
      function getLevelVal() {
        return this.level === "silent" ? Infinity : this.levels.values[this.level];
      }
      function getLevel() {
        return this._level;
      }
      function setLevel(level2) {
        if (level2 !== "silent" && !this.levels.values[level2]) {
          throw Error("unknown level " + level2);
        }
        this._level = level2;
        set2(setOpts, logger, "error", "log");
        set2(setOpts, logger, "fatal", "error");
        set2(setOpts, logger, "warn", "error");
        set2(setOpts, logger, "info", "log");
        set2(setOpts, logger, "debug", "log");
        set2(setOpts, logger, "trace", "log");
      }
      function child(bindings, childOptions) {
        if (!bindings) {
          throw new Error("missing bindings for child Pino");
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
          childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
          var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
          var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
          delete bindings.serializers;
          applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
          this._childLevel = (parent._childLevel | 0) + 1;
          this.error = bind(parent, bindings, "error");
          this.fatal = bind(parent, bindings, "fatal");
          this.warn = bind(parent, bindings, "warn");
          this.info = bind(parent, bindings, "info");
          this.debug = bind(parent, bindings, "debug");
          this.trace = bind(parent, bindings, "trace");
          if (childSerializers) {
            this.serializers = childSerializers;
            this._serialize = childSerialize;
          }
          if (transmit2) {
            this._logEvent = createLogEventShape(
              [].concat(parent._logEvent.bindings, bindings)
            );
          }
        }
        Child.prototype = this;
        return new Child(this);
      }
      return logger;
    }
    pino.levels = {
      values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
      },
      labels: {
        10: "trace",
        20: "debug",
        30: "info",
        40: "warn",
        50: "error",
        60: "fatal"
      }
    };
    pino.stdSerializers = stdSerializers;
    pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
    function set2(opts, logger, level, fallback2) {
      const proto = Object.getPrototypeOf(logger);
      logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback2] || noop;
      wrap(opts, logger, level);
    }
    function wrap(opts, logger, level) {
      if (!opts.transmit && logger[level] === noop) return;
      logger[level] = /* @__PURE__ */ function(write) {
        return function LOG() {
          const ts3 = opts.timestamp();
          const args = new Array(arguments.length);
          const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
          for (var i5 = 0; i5 < args.length; i5++) args[i5] = arguments[i5];
          if (opts.serialize && !opts.asObject) {
            applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          }
          if (opts.asObject) write.call(proto, asObject(this, level, args, ts3));
          else write.apply(proto, args);
          if (opts.transmit) {
            const transmitLevel = opts.transmit.level || logger.level;
            const transmitValue = pino.levels.values[transmitLevel];
            const methodValue = pino.levels.values[level];
            if (methodValue < transmitValue) return;
            transmit(this, {
              ts: ts3,
              methodLevel: level,
              methodValue,
              transmitLevel,
              transmitValue: pino.levels.values[opts.transmit.level || logger.level],
              send: opts.transmit.send,
              val: logger.levelVal
            }, args);
          }
        };
      }(logger[level]);
    }
    function asObject(logger, level, args, ts3) {
      if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
      const argsCloned = args.slice();
      let msg = argsCloned[0];
      const o2 = {};
      if (ts3) {
        o2.time = ts3;
      }
      o2.level = pino.levels.values[level];
      let lvl = (logger._childLevel | 0) + 1;
      if (lvl < 1) lvl = 1;
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(o2, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : void 0;
      } else if (typeof msg === "string") msg = format(argsCloned.shift(), argsCloned);
      if (msg !== void 0) o2.msg = msg;
      return o2;
    }
    function applySerializers(args, serialize, serializers, stdErrSerialize) {
      for (const i5 in args) {
        if (stdErrSerialize && args[i5] instanceof Error) {
          args[i5] = pino.stdSerializers.err(args[i5]);
        } else if (typeof args[i5] === "object" && !Array.isArray(args[i5])) {
          for (const k9 in args[i5]) {
            if (serialize && serialize.indexOf(k9) > -1 && k9 in serializers) {
              args[i5][k9] = serializers[k9](args[i5][k9]);
            }
          }
        }
      }
    }
    function bind(parent, bindings, level) {
      return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for (var i5 = 1; i5 < args.length; i5++) {
          args[i5] = arguments[i5 - 1];
        }
        return parent[level].apply(this, args);
      };
    }
    function transmit(logger, opts, args) {
      const send = opts.send;
      const ts3 = opts.ts;
      const methodLevel = opts.methodLevel;
      const methodValue = opts.methodValue;
      const val = opts.val;
      const bindings = logger._logEvent.bindings;
      applySerializers(
        args,
        logger._serialize || Object.keys(logger.serializers),
        logger.serializers,
        logger._stdErrSerialize === void 0 ? true : logger._stdErrSerialize
      );
      logger._logEvent.ts = ts3;
      logger._logEvent.messages = args.filter(function(arg) {
        return bindings.indexOf(arg) === -1;
      });
      logger._logEvent.level.label = methodLevel;
      logger._logEvent.level.value = methodValue;
      send(methodLevel, logger._logEvent, val);
      logger._logEvent = createLogEventShape(bindings);
    }
    function createLogEventShape(bindings) {
      return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: { label: "", value: 0 }
      };
    }
    function asErrValue(err) {
      const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
      };
      for (const key in err) {
        if (obj[key] === void 0) {
          obj[key] = err[key];
        }
      }
      return obj;
    }
    function getTimeFunction(opts) {
      if (typeof opts.timestamp === "function") {
        return opts.timestamp;
      }
      if (opts.timestamp === false) {
        return nullTime;
      }
      return epochTime;
    }
    function mock() {
      return {};
    }
    function passthrough(a2) {
      return a2;
    }
    function noop() {
    }
    function nullTime() {
      return false;
    }
    function epochTime() {
      return Date.now();
    }
    function unixTime() {
      return Math.round(Date.now() / 1e3);
    }
    function isoTime() {
      return new Date(Date.now()).toISOString();
    }
    function pfGlobalThisOrFallback() {
      function defd(o2) {
        return typeof o2 !== "undefined" && o2;
      }
      try {
        if (typeof globalThis !== "undefined") return globalThis;
        Object.defineProperty(Object.prototype, "globalThis", {
          get: function() {
            delete Object.prototype.globalThis;
            return this.globalThis = this;
          },
          configurable: true
        });
        return globalThis;
      } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
      }
    }
  }
});

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var import_events6 = __toESM(require_events());

// node_modules/@walletconnect/utils/dist/index.es.js
var import_time = __toESM(require_cjs());
var import_window_getters = __toESM(require_cjs2());
var import_window_metadata = __toESM(require_cjs3());

// node_modules/@walletconnect/utils/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
async function recoverPublicKey({ hash, signature }) {
  const hashHex = isHex(hash) ? hash : toHex(hash);
  const { secp256k1: secp256k12 } = await import("./secp256k1-VU3M6RGV.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r: r2, s: s3, v: v7, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v7);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r2), hexToBigInt(s3)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex(signature);
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash, signature }));
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transaction.js
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/public/getTransactionCount.js
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber(count);
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@walletconnect/utils/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/promise/withDedupe.js
var promiseCache = new LruMap(8192);

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/rpc/id.js
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@walletconnect/utils/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = new Uint8Array(new Array(16).fill(0).map((_5, i5) => i5));
var Pi = Id.map((i5) => (9 * i5 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i5 = 0; i5 < 4; i5++)
  for (let j4 of [idxL, idxR])
    j4.push(j4[i5].map((k9) => Rho[k9]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i5) => new Uint8Array(i5));
var shiftsL = idxL.map((idx, i5) => idx.map((j4) => shifts[i5][j4]));
var shiftsR = idxR.map((idx, i5) => idx.map((j4) => shifts[i5][j4]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f3(group, x5, y7, z6) {
  if (group === 0)
    return x5 ^ y7 ^ z6;
  else if (group === 1)
    return x5 & y7 | ~x5 & z6;
  else if (group === 2)
    return (x5 | ~y7) ^ z6;
  else if (group === 3)
    return x5 & z6 | y7 & ~z6;
  else
    return x5 ^ (y7 | ~z6);
}
var R_BUF = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset) {
    for (let i5 = 0; i5 < 16; i5++, offset += 4)
      R_BUF[i5] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar3 = al, bl = this.h1 | 0, br3 = bl, cl = this.h2 | 0, cr3 = cl, dl = this.h3 | 0, dr3 = dl, el = this.h4 | 0, er3 = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr3 = idxR[group];
      const sl = shiftsL[group], sr3 = shiftsR[group];
      for (let i5 = 0; i5 < 16; i5++) {
        const tl = rotl(al + f3(group, bl, cl, dl) + R_BUF[rl[i5]] + hbl, sl[i5]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i5 = 0; i5 < 16; i5++) {
        const tr3 = rotl(ar3 + f3(rGroup, br3, cr3, dr3) + R_BUF[rr3[i5]] + hbr, sr3[i5]) + er3 | 0;
        ar3 = er3, er3 = dr3, dr3 = rotl(cr3, 10) | 0, cr3 = br3, br3 = tr3;
      }
    }
    this.set(this.h1 + cl + dr3 | 0, this.h2 + dl + er3 | 0, this.h3 + el + ar3 | 0, this.h4 + al + br3 | 0, this.h0 + bl + cr3 | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/@walletconnect/utils/node_modules/viem/_esm/utils/nonceManager.js
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/version.js
var version = "0.1.1";

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/errors.js
function getVersion() {
  return version;
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Errors.js
var BaseError2 = class _BaseError extends Error {
  constructor(shortMessage, options = {}) {
    const details = (() => {
      var _a;
      if (options.cause instanceof _BaseError) {
        if (options.cause.details)
          return options.cause.details;
        if (options.cause.shortMessage)
          return options.cause.shortMessage;
      }
      if ((_a = options.cause) == null ? void 0 : _a.message)
        return options.cause.message;
      return options.details;
    })();
    const docsPath = (() => {
      if (options.cause instanceof _BaseError)
        return options.cause.docsPath || options.docsPath;
      return options.docsPath;
    })();
    const docsBaseUrl = "https://oxlib.sh";
    const docs = `${docsBaseUrl}${docsPath ?? ""}`;
    const message = [
      shortMessage || "An error occurred.",
      ...options.metaMessages ? ["", ...options.metaMessages] : [],
      ...details || docsPath ? [
        "",
        details ? `Details: ${details}` : void 0,
        docsPath ? `See: ${docs}` : void 0
      ] : []
    ].filter((x5) => typeof x5 === "string").join("\n");
    super(message, options.cause ? { cause: options.cause } : void 0);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docs", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    });
    Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: `ox@${getVersion()}`
    });
    this.cause = options.cause;
    this.details = details;
    this.docs = docs;
    this.docsPath = docsPath;
    this.shortMessage = shortMessage;
  }
  walk(fn3) {
    return walk(this, fn3);
  }
};
function walk(err, fn3) {
  if (fn3 == null ? void 0 : fn3(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause)
    return walk(err.cause, fn3);
  return fn3 ? null : err;
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/bytes.js
function assertSize(bytes, size_) {
  if (size2(bytes) > size_)
    throw new SizeOverflowError({
      givenSize: size2(bytes),
      maxSize: size_
    });
}
var charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function pad2(bytes, options = {}) {
  const { dir, size: size4 = 32 } = options;
  if (size4 === 0)
    return bytes;
  if (bytes.length > size4)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size4,
      type: "Bytes"
    });
  const paddedBytes = new Uint8Array(size4);
  for (let i5 = 0; i5 < size4; i5++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i5 : size4 - i5 - 1] = bytes[padEnd ? i5 : bytes.length - i5 - 1];
  }
  return paddedBytes;
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/hex.js
function assertSize2(hex, size_) {
  if (size3(hex) > size_)
    throw new SizeOverflowError2({
      givenSize: size3(hex),
      maxSize: size_
    });
}
function pad3(hex_, options = {}) {
  const { dir, size: size4 = 32 } = options;
  if (size4 === 0)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size4 * 2)
    throw new SizeExceedsPaddingSizeError2({
      size: Math.ceil(hex.length / 2),
      targetSize: size4,
      type: "Hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size4 * 2, "0")}`;
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Bytes.js
var decoder = new TextDecoder();
var encoder = new TextEncoder();
function from(value) {
  if (value instanceof Uint8Array)
    return value;
  if (typeof value === "string")
    return fromHex2(value);
  return fromArray(value);
}
function fromArray(value) {
  return value instanceof Uint8Array ? value : new Uint8Array(value);
}
function fromHex2(value, options = {}) {
  const { size: size4 } = options;
  let hex = value;
  if (size4) {
    assertSize2(value, size4);
    hex = padRight(value, size4);
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j4 = 0; index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j4++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j4++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError2(`Invalid byte sequence ("${hexString[j4 - 2]}${hexString[j4 - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function fromString2(value, options = {}) {
  const { size: size4 } = options;
  const bytes = encoder.encode(value);
  if (typeof size4 === "number") {
    assertSize(bytes, size4);
    return padRight2(bytes, size4);
  }
  return bytes;
}
function padRight2(value, size4) {
  return pad2(value, { dir: "right", size: size4 });
}
function size2(value) {
  return value.length;
}
var SizeOverflowError = class extends BaseError2 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeOverflowError"
    });
  }
};
var SizeExceedsPaddingSizeError = class extends BaseError2 {
  constructor({ size: size4, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size4}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Bytes.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Hex.js
var encoder2 = new TextEncoder();
var hexes = Array.from({ length: 256 }, (_v, i5) => i5.toString(16).padStart(2, "0"));
function concat3(...values) {
  return `0x${values.reduce((acc, x5) => acc + x5.replace("0x", ""), "")}`;
}
function fromBoolean(value, options = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof options.size === "number") {
    assertSize2(hex, options.size);
    return padLeft(hex, options.size);
  }
  return hex;
}
function fromBytes2(value, options = {}) {
  let string = "";
  for (let i5 = 0; i5 < value.length; i5++)
    string += hexes[value[i5]];
  const hex = `0x${string}`;
  if (typeof options.size === "number") {
    assertSize2(hex, options.size);
    return padRight(hex, options.size);
  }
  return hex;
}
function fromNumber(value, options = {}) {
  const { signed, size: size4 } = options;
  const value_ = BigInt(value);
  let maxValue;
  if (size4) {
    if (signed)
      maxValue = (1n << BigInt(size4) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size4) * 8n) - 1n;
  } else if (typeof value === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value_ > maxValue || value_ < minValue) {
    const suffix = typeof value === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size4,
      value: `${value}${suffix}`
    });
  }
  const stringValue = (signed && value_ < 0 ? (1n << BigInt(size4 * 8)) + BigInt(value_) : value_).toString(16);
  const hex = `0x${stringValue}`;
  if (size4)
    return padLeft(hex, size4);
  return hex;
}
function fromString3(value, options = {}) {
  return fromBytes2(encoder2.encode(value), options);
}
function padLeft(value, size4) {
  return pad3(value, { dir: "left", size: size4 });
}
function padRight(value, size4) {
  return pad3(value, { dir: "right", size: size4 });
}
function size3(value) {
  return Math.ceil((value.length - 2) / 2);
}
var IntegerOutOfRangeError = class extends BaseError2 {
  constructor({ max, min, signed, size: size4, value }) {
    super(`Number \`${value}\` is not in safe${size4 ? ` ${size4 * 8}-bit` : ""}${signed ? " signed" : " unsigned"} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.IntegerOutOfRangeError"
    });
  }
};
var SizeOverflowError2 = class extends BaseError2 {
  constructor({ givenSize, maxSize }) {
    super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeOverflowError"
    });
  }
};
var SizeExceedsPaddingSizeError2 = class extends BaseError2 {
  constructor({ size: size4, targetSize, type }) {
    super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size4}\`) exceeds padding size (\`${targetSize}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Hex.SizeExceedsPaddingSizeError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Hash.js
function keccak2562(value, options = {}) {
  const { as = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const bytes = keccak_256(from(value));
  if (as === "Bytes")
    return bytes;
  return fromBytes2(bytes);
}

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/lru.js
var LruMap2 = class extends Map {
  constructor(size4) {
    super();
    Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.maxSize = size4;
  }
  get(key) {
    const value = super.get(key);
    if (super.has(key) && value !== void 0) {
      this.delete(key);
      super.set(key, value);
    }
    return value;
  }
  set(key, value) {
    super.set(key, value);
    if (this.maxSize && this.size > this.maxSize) {
      const firstKey = this.keys().next().value;
      if (firstKey)
        this.delete(firstKey);
    }
    return this;
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Caches.js
var caches = {
  checksum: new LruMap2(8192)
};
var checksum = caches.checksum;

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Address.js
var addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value, options = {}) {
  const { strict = true } = options;
  if (!addressRegex.test(value))
    throw new InvalidAddressError2({
      address: value,
      cause: new InvalidInputError()
    });
  if (strict) {
    if (value.toLowerCase() === value)
      return;
    if (checksum2(value) !== value)
      throw new InvalidAddressError2({
        address: value,
        cause: new InvalidChecksumError()
      });
  }
}
function checksum2(address) {
  if (checksum.has(address))
    return checksum.get(address);
  assert(address, { strict: false });
  const hexAddress = address.substring(2).toLowerCase();
  const hash = keccak2562(fromString2(hexAddress), { as: "Bytes" });
  const characters = hexAddress.split("");
  for (let i5 = 0; i5 < 40; i5 += 2) {
    if (hash[i5 >> 1] >> 4 >= 8 && characters[i5]) {
      characters[i5] = characters[i5].toUpperCase();
    }
    if ((hash[i5 >> 1] & 15) >= 8 && characters[i5 + 1]) {
      characters[i5 + 1] = characters[i5 + 1].toUpperCase();
    }
  }
  const result = `0x${characters.join("")}`;
  checksum.set(address, result);
  return result;
}
var InvalidAddressError2 = class extends BaseError2 {
  constructor({ address, cause }) {
    super(`Address "${address}" is invalid.`, {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidAddressError"
    });
  }
};
var InvalidInputError = class extends BaseError2 {
  constructor() {
    super("Address is not a 20 byte (40 hexadecimal character) value.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidInputError"
    });
  }
};
var InvalidChecksumError = class extends BaseError2 {
  constructor() {
    super("Address does not match its checksum counterpart.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Address.InvalidChecksumError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/Solidity.js
var arrayRegex2 = /^(.*)\[([0-9]*)\]$/;
var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
var maxInt8 = 2n ** (8n - 1n) - 1n;
var maxInt16 = 2n ** (16n - 1n) - 1n;
var maxInt24 = 2n ** (24n - 1n) - 1n;
var maxInt32 = 2n ** (32n - 1n) - 1n;
var maxInt40 = 2n ** (40n - 1n) - 1n;
var maxInt48 = 2n ** (48n - 1n) - 1n;
var maxInt56 = 2n ** (56n - 1n) - 1n;
var maxInt64 = 2n ** (64n - 1n) - 1n;
var maxInt72 = 2n ** (72n - 1n) - 1n;
var maxInt80 = 2n ** (80n - 1n) - 1n;
var maxInt88 = 2n ** (88n - 1n) - 1n;
var maxInt96 = 2n ** (96n - 1n) - 1n;
var maxInt104 = 2n ** (104n - 1n) - 1n;
var maxInt112 = 2n ** (112n - 1n) - 1n;
var maxInt120 = 2n ** (120n - 1n) - 1n;
var maxInt128 = 2n ** (128n - 1n) - 1n;
var maxInt136 = 2n ** (136n - 1n) - 1n;
var maxInt144 = 2n ** (144n - 1n) - 1n;
var maxInt152 = 2n ** (152n - 1n) - 1n;
var maxInt160 = 2n ** (160n - 1n) - 1n;
var maxInt168 = 2n ** (168n - 1n) - 1n;
var maxInt176 = 2n ** (176n - 1n) - 1n;
var maxInt184 = 2n ** (184n - 1n) - 1n;
var maxInt192 = 2n ** (192n - 1n) - 1n;
var maxInt200 = 2n ** (200n - 1n) - 1n;
var maxInt208 = 2n ** (208n - 1n) - 1n;
var maxInt216 = 2n ** (216n - 1n) - 1n;
var maxInt224 = 2n ** (224n - 1n) - 1n;
var maxInt232 = 2n ** (232n - 1n) - 1n;
var maxInt240 = 2n ** (240n - 1n) - 1n;
var maxInt248 = 2n ** (248n - 1n) - 1n;
var maxInt256 = 2n ** (256n - 1n) - 1n;
var minInt8 = -(2n ** (8n - 1n));
var minInt16 = -(2n ** (16n - 1n));
var minInt24 = -(2n ** (24n - 1n));
var minInt32 = -(2n ** (32n - 1n));
var minInt40 = -(2n ** (40n - 1n));
var minInt48 = -(2n ** (48n - 1n));
var minInt56 = -(2n ** (56n - 1n));
var minInt64 = -(2n ** (64n - 1n));
var minInt72 = -(2n ** (72n - 1n));
var minInt80 = -(2n ** (80n - 1n));
var minInt88 = -(2n ** (88n - 1n));
var minInt96 = -(2n ** (96n - 1n));
var minInt104 = -(2n ** (104n - 1n));
var minInt112 = -(2n ** (112n - 1n));
var minInt120 = -(2n ** (120n - 1n));
var minInt128 = -(2n ** (128n - 1n));
var minInt136 = -(2n ** (136n - 1n));
var minInt144 = -(2n ** (144n - 1n));
var minInt152 = -(2n ** (152n - 1n));
var minInt160 = -(2n ** (160n - 1n));
var minInt168 = -(2n ** (168n - 1n));
var minInt176 = -(2n ** (176n - 1n));
var minInt184 = -(2n ** (184n - 1n));
var minInt192 = -(2n ** (192n - 1n));
var minInt200 = -(2n ** (200n - 1n));
var minInt208 = -(2n ** (208n - 1n));
var minInt216 = -(2n ** (216n - 1n));
var minInt224 = -(2n ** (224n - 1n));
var minInt232 = -(2n ** (232n - 1n));
var minInt240 = -(2n ** (240n - 1n));
var minInt248 = -(2n ** (248n - 1n));
var minInt256 = -(2n ** (256n - 1n));
var maxUint8 = 2n ** 8n - 1n;
var maxUint16 = 2n ** 16n - 1n;
var maxUint24 = 2n ** 24n - 1n;
var maxUint32 = 2n ** 32n - 1n;
var maxUint40 = 2n ** 40n - 1n;
var maxUint48 = 2n ** 48n - 1n;
var maxUint56 = 2n ** 56n - 1n;
var maxUint64 = 2n ** 64n - 1n;
var maxUint72 = 2n ** 72n - 1n;
var maxUint80 = 2n ** 80n - 1n;
var maxUint88 = 2n ** 88n - 1n;
var maxUint96 = 2n ** 96n - 1n;
var maxUint104 = 2n ** 104n - 1n;
var maxUint112 = 2n ** 112n - 1n;
var maxUint120 = 2n ** 120n - 1n;
var maxUint128 = 2n ** 128n - 1n;
var maxUint136 = 2n ** 136n - 1n;
var maxUint144 = 2n ** 144n - 1n;
var maxUint152 = 2n ** 152n - 1n;
var maxUint160 = 2n ** 160n - 1n;
var maxUint168 = 2n ** 168n - 1n;
var maxUint176 = 2n ** 176n - 1n;
var maxUint184 = 2n ** 184n - 1n;
var maxUint192 = 2n ** 192n - 1n;
var maxUint200 = 2n ** 200n - 1n;
var maxUint208 = 2n ** 208n - 1n;
var maxUint216 = 2n ** 216n - 1n;
var maxUint224 = 2n ** 224n - 1n;
var maxUint232 = 2n ** 232n - 1n;
var maxUint240 = 2n ** 240n - 1n;
var maxUint248 = 2n ** 248n - 1n;
var maxUint2562 = 2n ** 256n - 1n;

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/internal/cursor.js
var staticCursor = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new RecursiveReadLimitExceededError({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(position) {
    if (position < 0 || position > this.bytes.length - 1)
      throw new PositionOutOfBoundsError2({
        length: this.bytes.length,
        position
      });
  },
  decrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position - offset;
    this.assertPosition(position);
    this.position = position;
  },
  getReadCount(position) {
    return this.positionReadCount.get(position || this.position) || 0;
  },
  incrementPosition(offset) {
    if (offset < 0)
      throw new NegativeOffsetError({ offset });
    const position = this.position + offset;
    this.assertPosition(position);
    this.position = position;
  },
  inspectByte(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectBytes(length, position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + length - 1);
    return this.bytes.subarray(position, position + length);
  },
  inspectUint8(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position);
    return this.bytes[position];
  },
  inspectUint16(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 1);
    return this.dataView.getUint16(position);
  },
  inspectUint24(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 2);
    return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
  },
  inspectUint32(position_) {
    const position = position_ ?? this.position;
    this.assertPosition(position + 3);
    return this.dataView.getUint32(position);
  },
  pushByte(byte) {
    this.assertPosition(this.position);
    this.bytes[this.position] = byte;
    this.position++;
  },
  pushBytes(bytes) {
    this.assertPosition(this.position + bytes.length - 1);
    this.bytes.set(bytes, this.position);
    this.position += bytes.length;
  },
  pushUint8(value) {
    this.assertPosition(this.position);
    this.bytes[this.position] = value;
    this.position++;
  },
  pushUint16(value) {
    this.assertPosition(this.position + 1);
    this.dataView.setUint16(this.position, value);
    this.position += 2;
  },
  pushUint24(value) {
    this.assertPosition(this.position + 2);
    this.dataView.setUint16(this.position, value >> 8);
    this.dataView.setUint8(this.position + 2, value & ~4294967040);
    this.position += 3;
  },
  pushUint32(value) {
    this.assertPosition(this.position + 3);
    this.dataView.setUint32(this.position, value);
    this.position += 4;
  },
  readByte() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectByte();
    this.position++;
    return value;
  },
  readBytes(length, size4) {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectBytes(length);
    this.position += size4 ?? length;
    return value;
  },
  readUint8() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint8();
    this.position += 1;
    return value;
  },
  readUint16() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint16();
    this.position += 2;
    return value;
  },
  readUint24() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint24();
    this.position += 3;
    return value;
  },
  readUint32() {
    this.assertReadLimit();
    this._touch();
    const value = this.inspectUint32();
    this.position += 4;
    return value;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(position) {
    const oldPosition = this.position;
    this.assertPosition(position);
    this.position = position;
    return () => this.position = oldPosition;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const count = this.getReadCount();
    this.positionReadCount.set(this.position, count + 1);
    if (count > 0)
      this.recursiveReadCount++;
  }
};
var NegativeOffsetError = class extends BaseError2 {
  constructor({ offset }) {
    super(`Offset \`${offset}\` cannot be negative.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.NegativeOffsetError"
    });
  }
};
var PositionOutOfBoundsError2 = class extends BaseError2 {
  constructor({ length, position }) {
    super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.PositionOutOfBoundsError"
    });
  }
};
var RecursiveReadLimitExceededError = class extends BaseError2 {
  constructor({ count, limit }) {
    super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Cursor.RecursiveReadLimitExceededError"
    });
  }
};

// node_modules/@walletconnect/utils/node_modules/ox/_esm/core/AbiParameters.js
function encodePacked2(types, values) {
  if (types.length !== values.length)
    throw new LengthMismatchError({
      expectedLength: types.length,
      givenLength: values.length
    });
  const data = [];
  for (let i5 = 0; i5 < types.length; i5++) {
    const type = types[i5];
    const value = values[i5];
    data.push(encodePacked2.encode(type, value));
  }
  return concat3(...data);
}
(function(encodePacked3) {
  function encode4(type, value, isArray = false) {
    if (type === "address") {
      const address = value;
      assert(address);
      return padLeft(address.toLowerCase(), isArray ? 32 : 0);
    }
    if (type === "string")
      return fromString3(value);
    if (type === "bytes")
      return value;
    if (type === "bool")
      return padLeft(fromBoolean(value), isArray ? 32 : 1);
    const intMatch = type.match(integerRegex2);
    if (intMatch) {
      const [_type, baseType, bits = "256"] = intMatch;
      const size4 = Number.parseInt(bits) / 8;
      return fromNumber(value, {
        size: isArray ? 32 : size4,
        signed: baseType === "int"
      });
    }
    const bytesMatch = type.match(bytesRegex2);
    if (bytesMatch) {
      const [_type, size4] = bytesMatch;
      if (Number.parseInt(size4) !== (value.length - 2) / 2)
        throw new BytesSizeMismatchError2({
          expectedSize: Number.parseInt(size4),
          value
        });
      return padRight(value, isArray ? 32 : 0);
    }
    const arrayMatch = type.match(arrayRegex2);
    if (arrayMatch && Array.isArray(value)) {
      const [_type, childType] = arrayMatch;
      const data = [];
      for (let i5 = 0; i5 < value.length; i5++) {
        data.push(encode4(childType, value[i5], true));
      }
      if (data.length === 0)
        return "0x";
      return concat3(...data);
    }
    throw new InvalidTypeError(type);
  }
  encodePacked3.encode = encode4;
})(encodePacked2 || (encodePacked2 = {}));
var BytesSizeMismatchError2 = class extends BaseError2 {
  constructor({ expectedSize, value }) {
    super(`Size of bytes "${value}" (bytes${size3(value)}) does not match expected size (bytes${expectedSize}).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.BytesSizeMismatchError"
    });
  }
};
var LengthMismatchError = class extends BaseError2 {
  constructor({ expectedLength, givenLength }) {
    super([
      "ABI encoding parameters/values length mismatch.",
      `Expected length (parameters): ${expectedLength}`,
      `Given length (values): ${givenLength}`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.LengthMismatchError"
    });
  }
};
var InvalidTypeError = class extends BaseError2 {
  constructor(type) {
    super(`Type \`${type}\` is not a valid ABI Type.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiParameters.InvalidTypeError"
    });
  }
};

// node_modules/@walletconnect/utils/dist/index.es.js
var ae = ":";
function Ne(t) {
  const [e, n4] = t.split(ae);
  return { namespace: e, reference: n4 };
}
function Ko(t, e = []) {
  const n4 = [];
  return Object.keys(t).forEach((r2) => {
    if (e.length && !e.includes(r2)) return;
    const o2 = t[r2];
    n4.push(...o2.accounts);
  }), n4;
}
function ue(t, e) {
  return t.includes(":") ? [t] : e.chains || [];
}
var Zo = Object.defineProperty;
var Yo = Object.defineProperties;
var Go = Object.getOwnPropertyDescriptors;
var Tn = Object.getOwnPropertySymbols;
var Wo = Object.prototype.hasOwnProperty;
var Xo = Object.prototype.propertyIsEnumerable;
var Rn = (t, e, n4) => e in t ? Zo(t, e, { enumerable: true, configurable: true, writable: true, value: n4 }) : t[e] = n4;
var _n = (t, e) => {
  for (var n4 in e || (e = {})) Wo.call(e, n4) && Rn(t, n4, e[n4]);
  if (Tn) for (var n4 of Tn(e)) Xo.call(e, n4) && Rn(t, n4, e[n4]);
  return t;
};
var Jo = (t, e) => Yo(t, Go(e));
var $n = "ReactNative";
var Y = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
var jn = "js";
function _e() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function pt() {
  return !(0, import_window_getters.getDocument)() && !!(0, import_window_getters.getNavigator)() && navigator.product === $n;
}
function ei() {
  return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "android";
}
function ni() {
  return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u" && (global == null ? void 0 : global.Platform.OS) === "ios";
}
function Tt() {
  return !_e() && !!(0, import_window_getters.getNavigator)() && !!(0, import_window_getters.getDocument)();
}
function xt() {
  return pt() ? Y.reactNative : _e() ? Y.node : Tt() ? Y.browser : Y.unknown;
}
function ri() {
  var t;
  try {
    return pt() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (t = global.Application) == null ? void 0 : t.applicationId : void 0;
  } catch {
    return;
  }
}
function Cn(t, e) {
  const n4 = new URLSearchParams(t);
  for (const r2 of Object.keys(e).sort()) if (e.hasOwnProperty(r2)) {
    const o2 = e[r2];
    o2 !== void 0 && n4.set(r2, o2);
  }
  return n4.toString();
}
function oi(t) {
  var e, n4;
  const r2 = Pn();
  try {
    return t != null && t.url && r2.url && new URL(t.url).host !== new URL(r2.url).host && (console.warn(`The configured WalletConnect 'metadata.url':${t.url} differs from the actual page url:${r2.url}. This is probably unintended and can lead to issues.`), t.url = r2.url), (e = t == null ? void 0 : t.icons) != null && e.length && t.icons.length > 0 && (t.icons = t.icons.filter((o2) => o2 !== "")), Jo(_n(_n({}, r2), t), { url: (t == null ? void 0 : t.url) || r2.url, name: (t == null ? void 0 : t.name) || r2.name, description: (t == null ? void 0 : t.description) || r2.description, icons: (n4 = t == null ? void 0 : t.icons) != null && n4.length && t.icons.length > 0 ? t.icons : r2.icons });
  } catch (o2) {
    return console.warn("Error populating app metadata", o2), t || r2;
  }
}
function Pn() {
  return (0, import_window_metadata.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
}
function kn() {
  if (xt() === Y.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: n4, Version: r2 } = global.Platform;
    return [n4, r2].join("-");
  }
  const t = detect();
  if (t === null) return "unknown";
  const e = t.os ? t.os.replace(" ", "").toLowerCase() : "unknown";
  return t.type === "browser" ? [e, t.name, t.version].join("-") : [e, t.version].join("-");
}
function Vn() {
  var t;
  const e = xt();
  return e === Y.browser ? [e, ((t = (0, import_window_getters.getLocation)()) == null ? void 0 : t.host) || "unknown"].join(":") : e;
}
function Mn(t, e, n4) {
  const r2 = kn(), o2 = Vn();
  return [[t, e].join("-"), [jn, n4].join("-"), r2, o2].join("/");
}
function si({ protocol: t, version: e, relayUrl: n4, sdkVersion: r2, auth: o2, projectId: i5, useOnCloseEvent: s3, bundleId: c6, packageName: a2 }) {
  const u3 = n4.split("?"), l6 = Mn(t, e, r2), f9 = { auth: o2, ua: l6, projectId: i5, useOnCloseEvent: s3 || void 0, packageName: a2 || void 0, bundleId: c6 || void 0 }, h6 = Cn(u3[1] || "", f9);
  return u3[0] + "?" + h6;
}
function gt(t, e) {
  return t.filter((n4) => e.includes(n4)).length === t.length;
}
function fi(t) {
  return Object.fromEntries(t.entries());
}
function li(t) {
  return new Map(Object.entries(t));
}
function gi(t = import_time.FIVE_MINUTES, e) {
  const n4 = (0, import_time.toMiliseconds)(t || import_time.FIVE_MINUTES);
  let r2, o2, i5, s3;
  return { resolve: (c6) => {
    i5 && r2 && (clearTimeout(i5), r2(c6), s3 = Promise.resolve(c6));
  }, reject: (c6) => {
    i5 && o2 && (clearTimeout(i5), o2(c6));
  }, done: () => new Promise((c6, a2) => {
    if (s3) return c6(s3);
    i5 = setTimeout(() => {
      const u3 = new Error(e);
      s3 = Promise.reject(u3), a2(u3);
    }, n4), r2 = c6, o2 = a2;
  }) };
}
function yi(t, e, n4) {
  return new Promise(async (r2, o2) => {
    const i5 = setTimeout(() => o2(new Error(n4)), e);
    try {
      const s3 = await t;
      r2(s3);
    } catch (s3) {
      o2(s3);
    }
    clearTimeout(i5);
  });
}
function $e(t, e) {
  if (typeof e == "string" && e.startsWith(`${t}:`)) return e;
  if (t.toLowerCase() === "topic") {
    if (typeof e != "string") throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${e}`;
  } else if (t.toLowerCase() === "id") {
    if (typeof e != "number") throw new Error('Value must be "number" for expirer target type: id');
    return `id:${e}`;
  }
  throw new Error(`Unknown expirer target type: ${t}`);
}
function mi(t) {
  return $e("topic", t);
}
function wi(t) {
  return $e("id", t);
}
function bi(t) {
  const [e, n4] = t.split(":"), r2 = { id: void 0, topic: void 0 };
  if (e === "topic" && typeof n4 == "string") r2.topic = n4;
  else if (e === "id" && Number.isInteger(Number(n4))) r2.id = Number(n4);
  else throw new Error(`Invalid target, expected id:number or topic:string, got ${e}:${n4}`);
  return r2;
}
function Ei(t, e) {
  return (0, import_time.fromMiliseconds)((e || Date.now()) + (0, import_time.toMiliseconds)(t));
}
function vi(t) {
  return Date.now() >= (0, import_time.toMiliseconds)(t);
}
function xi(t, e) {
  return `${t}${e ? `:${e}` : ""}`;
}
function ot(t = [], e = []) {
  return [.../* @__PURE__ */ new Set([...t, ...e])];
}
async function Si({ id: t, topic: e, wcDeepLink: n4 }) {
  var r2;
  try {
    if (!n4) return;
    const o2 = typeof n4 == "string" ? JSON.parse(n4) : n4, i5 = o2 == null ? void 0 : o2.href;
    if (typeof i5 != "string") return;
    const s3 = Kn(i5, t, e), c6 = xt();
    if (c6 === Y.browser) {
      if (!((r2 = (0, import_window_getters.getDocument)()) != null && r2.hasFocus())) {
        console.warn("Document does not have focus, skipping deeplink.");
        return;
      }
      Fn(s3);
    } else c6 === Y.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s3);
  } catch (o2) {
    console.error(o2);
  }
}
function Kn(t, e, n4) {
  const r2 = `requestId=${e}&sessionTopic=${n4}`;
  t.endsWith("/") && (t = t.slice(0, -1));
  let o2 = `${t}`;
  if (t.startsWith("https://t.me")) {
    const i5 = t.includes("?") ? "&startapp=" : "?startapp=";
    o2 = `${o2}${i5}${Yn(r2, true)}`;
  } else o2 = `${o2}/wc?${r2}`;
  return o2;
}
function Fn(t) {
  let e = "_self";
  Zn() ? e = "_top" : (zn() || t.startsWith("https://") || t.startsWith("http://")) && (e = "_blank"), window.open(t, e, "noreferrer noopener");
}
async function Oi(t, e) {
  let n4 = "";
  try {
    if (Tt() && (n4 = localStorage.getItem(e), n4)) return n4;
    n4 = await t.getItem(e);
  } catch (r2) {
    console.error(r2);
  }
  return n4;
}
function Ai(t, e) {
  if (!t.includes(e)) return null;
  const n4 = t.split(/([&,?,=])/), r2 = n4.indexOf(e);
  return n4[r2 + 2];
}
function Bi() {
  return typeof crypto < "u" && crypto != null && crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/gu, (t) => {
    const e = Math.random() * 16 | 0;
    return (t === "x" ? e : e & 3 | 8).toString(16);
  });
}
function Ii() {
  return typeof process < "u" && process.env.IS_VITEST === "true";
}
function zn() {
  return typeof window < "u" && (!!window.TelegramWebviewProxy || !!window.Telegram || !!window.TelegramWebviewProxyProto);
}
function Zn() {
  try {
    return window.self !== window.top;
  } catch {
    return false;
  }
}
function Yn(t, e = false) {
  const n4 = Buffer.from(t).toString("base64");
  return e ? n4.replace(/[=]/g, "") : n4;
}
function je(t) {
  return Buffer.from(t, "base64").toString("utf-8");
}
function Ni(t) {
  return new Promise((e) => setTimeout(e, t));
}
function Wt(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function Ui(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function Xt(t, ...e) {
  if (!Ui(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Ce(t) {
  if (typeof t != "function" || typeof t.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  Wt(t.outputLen), Wt(t.blockLen);
}
function Rt(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function Gn(t, e) {
  Xt(t);
  const n4 = e.outputLen;
  if (t.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
var le = BigInt(2 ** 32 - 1);
var Wn = BigInt(32);
function Ti(t, e = false) {
  return e ? { h: Number(t & le), l: Number(t >> Wn & le) } : { h: Number(t >> Wn & le) | 0, l: Number(t & le) | 0 };
}
function Ri(t, e = false) {
  let n4 = new Uint32Array(t.length), r2 = new Uint32Array(t.length);
  for (let o2 = 0; o2 < t.length; o2++) {
    const { h: i5, l: s3 } = Ti(t[o2], e);
    [n4[o2], r2[o2]] = [i5, s3];
  }
  return [n4, r2];
}
var _i = (t, e, n4) => t << n4 | e >>> 32 - n4;
var $i = (t, e, n4) => e << n4 | t >>> 32 - n4;
var Li = (t, e, n4) => e << n4 - 32 | t >>> 64 - n4;
var ji = (t, e, n4) => t << n4 - 32 | e >>> 64 - n4;
var _t = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
function Ci(t) {
  return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
}
function Pe(t) {
  return new DataView(t.buffer, t.byteOffset, t.byteLength);
}
function ct(t, e) {
  return t << 32 - e | t >>> e;
}
var Xn = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function Pi2(t) {
  return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
}
function Jn(t) {
  for (let e = 0; e < t.length; e++) t[e] = Pi2(t[e]);
}
function ki(t) {
  if (typeof t != "string") throw new Error("utf8ToBytes expected string, got " + typeof t);
  return new Uint8Array(new TextEncoder().encode(t));
}
function $t(t) {
  return typeof t == "string" && (t = ki(t)), Xt(t), t;
}
function Vi(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o2 = t[r2];
    Xt(o2), e += o2.length;
  }
  const n4 = new Uint8Array(e);
  for (let r2 = 0, o2 = 0; r2 < t.length; r2++) {
    const i5 = t[r2];
    n4.set(i5, o2), o2 += i5.length;
  }
  return n4;
}
var ke = class {
  clone() {
    return this._cloneInto();
  }
};
function Qn(t) {
  const e = (r2) => t().update($t(r2)).digest(), n4 = t();
  return e.outputLen = n4.outputLen, e.blockLen = n4.blockLen, e.create = () => t(), e;
}
function Lt(t = 32) {
  if (_t && typeof _t.getRandomValues == "function") return _t.getRandomValues(new Uint8Array(t));
  if (_t && typeof _t.randomBytes == "function") return _t.randomBytes(t);
  throw new Error("crypto.getRandomValues must be defined");
}
var tr = [];
var er = [];
var nr = [];
var Mi = BigInt(0);
var Jt = BigInt(1);
var Di = BigInt(2);
var Hi = BigInt(7);
var qi = BigInt(256);
var Ki = BigInt(113);
for (let t = 0, e = Jt, n4 = 1, r2 = 0; t < 24; t++) {
  [n4, r2] = [r2, (2 * n4 + 3 * r2) % 5], tr.push(2 * (5 * r2 + n4)), er.push((t + 1) * (t + 2) / 2 % 64);
  let o2 = Mi;
  for (let i5 = 0; i5 < 7; i5++) e = (e << Jt ^ (e >> Hi) * Ki) % qi, e & Di && (o2 ^= Jt << (Jt << BigInt(i5)) - Jt);
  nr.push(o2);
}
var [Fi, zi] = Ri(nr, true);
var rr = (t, e, n4) => n4 > 32 ? Li(t, e, n4) : _i(t, e, n4);
var or = (t, e, n4) => n4 > 32 ? ji(t, e, n4) : $i(t, e, n4);
function Zi(t, e = 24) {
  const n4 = new Uint32Array(10);
  for (let r2 = 24 - e; r2 < 24; r2++) {
    for (let s3 = 0; s3 < 10; s3++) n4[s3] = t[s3] ^ t[s3 + 10] ^ t[s3 + 20] ^ t[s3 + 30] ^ t[s3 + 40];
    for (let s3 = 0; s3 < 10; s3 += 2) {
      const c6 = (s3 + 8) % 10, a2 = (s3 + 2) % 10, u3 = n4[a2], l6 = n4[a2 + 1], f9 = rr(u3, l6, 1) ^ n4[c6], h6 = or(u3, l6, 1) ^ n4[c6 + 1];
      for (let y7 = 0; y7 < 50; y7 += 10) t[s3 + y7] ^= f9, t[s3 + y7 + 1] ^= h6;
    }
    let o2 = t[2], i5 = t[3];
    for (let s3 = 0; s3 < 24; s3++) {
      const c6 = er[s3], a2 = rr(o2, i5, c6), u3 = or(o2, i5, c6), l6 = tr[s3];
      o2 = t[l6], i5 = t[l6 + 1], t[l6] = a2, t[l6 + 1] = u3;
    }
    for (let s3 = 0; s3 < 50; s3 += 10) {
      for (let c6 = 0; c6 < 10; c6++) n4[c6] = t[s3 + c6];
      for (let c6 = 0; c6 < 10; c6++) t[s3 + c6] ^= ~n4[(c6 + 2) % 10] & n4[(c6 + 4) % 10];
    }
    t[0] ^= Fi[r2], t[1] ^= zi[r2];
  }
  n4.fill(0);
}
var En = class _En extends ke {
  constructor(e, n4, r2, o2 = false, i5 = 24) {
    if (super(), this.blockLen = e, this.suffix = n4, this.outputLen = r2, this.enableXOF = o2, this.rounds = i5, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Wt(r2), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Ci(this.state);
  }
  keccak() {
    Xn || Jn(this.state32), Zi(this.state32, this.rounds), Xn || Jn(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(e) {
    Rt(this);
    const { blockLen: n4, state: r2 } = this;
    e = $t(e);
    const o2 = e.length;
    for (let i5 = 0; i5 < o2; ) {
      const s3 = Math.min(n4 - this.pos, o2 - i5);
      for (let c6 = 0; c6 < s3; c6++) r2[this.pos++] ^= e[i5++];
      this.pos === n4 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: e, suffix: n4, pos: r2, blockLen: o2 } = this;
    e[r2] ^= n4, (n4 & 128) !== 0 && r2 === o2 - 1 && this.keccak(), e[o2 - 1] ^= 128, this.keccak();
  }
  writeInto(e) {
    Rt(this, false), Xt(e), this.finish();
    const n4 = this.state, { blockLen: r2 } = this;
    for (let o2 = 0, i5 = e.length; o2 < i5; ) {
      this.posOut >= r2 && this.keccak();
      const s3 = Math.min(r2 - this.posOut, i5 - o2);
      e.set(n4.subarray(this.posOut, this.posOut + s3), o2), this.posOut += s3, o2 += s3;
    }
    return e;
  }
  xofInto(e) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(e);
  }
  xof(e) {
    return Wt(e), this.xofInto(new Uint8Array(e));
  }
  digestInto(e) {
    if (Gn(e, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(e), this.destroy(), e;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(e) {
    const { blockLen: n4, suffix: r2, outputLen: o2, rounds: i5, enableXOF: s3 } = this;
    return e || (e = new _En(n4, r2, o2, s3, i5)), e.state32.set(this.state32), e.pos = this.pos, e.posOut = this.posOut, e.finished = this.finished, e.rounds = i5, e.suffix = r2, e.outputLen = o2, e.enableXOF = s3, e.destroyed = this.destroyed, e;
  }
};
var Yi = (t, e, n4) => Qn(() => new En(e, t, n4));
var Gi = Yi(1, 136, 256 / 8);
var Wi = "https://rpc.walletconnect.org/v1";
function Ve(t) {
  const e = `Ethereum Signed Message:
${t.length}`, n4 = new TextEncoder().encode(e + t);
  return "0x" + Buffer.from(Gi(n4)).toString("hex");
}
async function ir(t, e, n4, r2, o2, i5) {
  switch (n4.t) {
    case "eip191":
      return await sr(t, e, n4.s);
    case "eip1271":
      return await cr(t, e, n4.s, r2, o2, i5);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${n4.t}`);
  }
}
async function sr(t, e, n4) {
  return (await recoverAddress({ hash: Ve(e), signature: n4 })).toLowerCase() === t.toLowerCase();
}
async function cr(t, e, n4, r2, o2, i5) {
  const s3 = Ne(r2);
  if (!s3.namespace || !s3.reference) throw new Error(`isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${r2}`);
  try {
    const c6 = "0x1626ba7e", a2 = "0000000000000000000000000000000000000000000000000000000000000040", u3 = "0000000000000000000000000000000000000000000000000000000000000041", l6 = n4.substring(2), f9 = Ve(e).substring(2), h6 = c6 + f9 + a2 + u3 + l6, y7 = await fetch(`${i5 || Wi}/?chainId=${r2}&projectId=${o2}`, { method: "POST", body: JSON.stringify({ id: Xi(), jsonrpc: "2.0", method: "eth_call", params: [{ to: t, data: h6 }, "latest"] }) }), { result: E8 } = await y7.json();
    return E8 ? E8.slice(0, c6.length).toLowerCase() === c6.toLowerCase() : false;
  } catch (c6) {
    return console.error("isValidEip1271Signature: ", c6), false;
  }
}
function Xi() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function Ji(t) {
  const e = atob(t), n4 = new Uint8Array(e.length);
  for (let s3 = 0; s3 < e.length; s3++) n4[s3] = e.charCodeAt(s3);
  const r2 = n4[0];
  if (r2 === 0) throw new Error("No signatures found");
  const o2 = 1 + r2 * 64;
  if (n4.length < o2) throw new Error("Transaction data too short for claimed signature count");
  if (n4.length < 100) throw new Error("Transaction too short");
  const i5 = Buffer.from(t, "base64").slice(1, 65);
  return esm_default.encode(i5);
}
var Qi = Object.defineProperty;
var ts = Object.defineProperties;
var es = Object.getOwnPropertyDescriptors;
var ar = Object.getOwnPropertySymbols;
var ns = Object.prototype.hasOwnProperty;
var rs = Object.prototype.propertyIsEnumerable;
var ur = (t, e, n4) => e in t ? Qi(t, e, { enumerable: true, configurable: true, writable: true, value: n4 }) : t[e] = n4;
var Me = (t, e) => {
  for (var n4 in e || (e = {})) ns.call(e, n4) && ur(t, n4, e[n4]);
  if (ar) for (var n4 of ar(e)) rs.call(e, n4) && ur(t, n4, e[n4]);
  return t;
};
var fr = (t, e) => ts(t, es(e));
var os = "did:pkh:";
var de = (t) => t == null ? void 0 : t.split(":");
var lr = (t) => {
  const e = t && de(t);
  if (e) return t.includes(os) ? e[3] : e[1];
};
var dr = (t) => {
  const e = t && de(t);
  if (e) return e[2] + ":" + e[3];
};
var De = (t) => {
  const e = t && de(t);
  if (e) return e.pop();
};
async function is(t) {
  const { cacao: e, projectId: n4 } = t, { s: r2, p: o2 } = e, i5 = hr(o2, o2.iss), s3 = De(o2.iss);
  return await ir(s3, i5, r2, dr(o2.iss), n4);
}
var hr = (t, e) => {
  const n4 = `${t.domain} wants you to sign in with your Ethereum account:`, r2 = De(e);
  if (!t.aud && !t.uri) throw new Error("Either `aud` or `uri` is required to construct the message");
  let o2 = t.statement || void 0;
  const i5 = `URI: ${t.aud || t.uri}`, s3 = `Version: ${t.version}`, c6 = `Chain ID: ${lr(e)}`, a2 = `Nonce: ${t.nonce}`, u3 = `Issued At: ${t.iat}`, l6 = t.exp ? `Expiration Time: ${t.exp}` : void 0, f9 = t.nbf ? `Not Before: ${t.nbf}` : void 0, h6 = t.requestId ? `Request ID: ${t.requestId}` : void 0, y7 = t.resources ? `Resources:${t.resources.map((p6) => `
- ${p6}`).join("")}` : void 0, E8 = pe(t.resources);
  if (E8) {
    const p6 = yt(E8);
    o2 = Ke(o2, p6);
  }
  return [n4, r2, "", o2, "", i5, s3, c6, a2, u3, l6, f9, h6, y7].filter((p6) => p6 != null).join(`
`);
};
function mr(t) {
  return Buffer.from(JSON.stringify(t)).toString("base64");
}
function wr(t) {
  return JSON.parse(Buffer.from(t, "base64").toString("utf-8"));
}
function at(t) {
  if (!t) throw new Error("No recap provided, value is undefined");
  if (!t.att) throw new Error("No `att` property found");
  const e = Object.keys(t.att);
  if (!(e != null && e.length)) throw new Error("No resources found in `att` property");
  e.forEach((n4) => {
    const r2 = t.att[n4];
    if (Array.isArray(r2)) throw new Error(`Resource must be an object: ${n4}`);
    if (typeof r2 != "object") throw new Error(`Resource must be an object: ${n4}`);
    if (!Object.keys(r2).length) throw new Error(`Resource object is empty: ${n4}`);
    Object.keys(r2).forEach((o2) => {
      const i5 = r2[o2];
      if (!Array.isArray(i5)) throw new Error(`Ability limits ${o2} must be an array of objects, found: ${i5}`);
      if (!i5.length) throw new Error(`Value of ${o2} is empty array, must be an array with objects`);
      i5.forEach((s3) => {
        if (typeof s3 != "object") throw new Error(`Ability limits (${o2}) must be an array of objects, found: ${s3}`);
      });
    });
  });
}
function br(t, e, n4, r2 = {}) {
  return n4 == null ? void 0 : n4.sort((o2, i5) => o2.localeCompare(i5)), { att: { [t]: He(e, n4, r2) } };
}
function He(t, e, n4 = {}) {
  e = e == null ? void 0 : e.sort((o2, i5) => o2.localeCompare(i5));
  const r2 = e.map((o2) => ({ [`${t}/${o2}`]: [n4] }));
  return Object.assign({}, ...r2);
}
function he(t) {
  return at(t), `urn:recap:${mr(t).replace(/=/g, "")}`;
}
function yt(t) {
  const e = wr(t.replace("urn:recap:", ""));
  return at(e), e;
}
function fs(t, e, n4) {
  const r2 = br(t, e, n4);
  return he(r2);
}
function qe(t) {
  return t && t.includes("urn:recap:");
}
function ls(t, e) {
  const n4 = yt(t), r2 = yt(e), o2 = vr(n4, r2);
  return he(o2);
}
function vr(t, e) {
  at(t), at(e);
  const n4 = Object.keys(t.att).concat(Object.keys(e.att)).sort((o2, i5) => o2.localeCompare(i5)), r2 = { att: {} };
  return n4.forEach((o2) => {
    var i5, s3;
    Object.keys(((i5 = t.att) == null ? void 0 : i5[o2]) || {}).concat(Object.keys(((s3 = e.att) == null ? void 0 : s3[o2]) || {})).sort((c6, a2) => c6.localeCompare(a2)).forEach((c6) => {
      var a2, u3;
      r2.att[o2] = fr(Me({}, r2.att[o2]), { [c6]: ((a2 = t.att[o2]) == null ? void 0 : a2[c6]) || ((u3 = e.att[o2]) == null ? void 0 : u3[c6]) });
    });
  }), r2;
}
function Ke(t = "", e) {
  at(e);
  const n4 = "I further authorize the stated URI to perform the following actions on my behalf: ";
  if (t.includes(n4)) return t;
  const r2 = [];
  let o2 = 0;
  Object.keys(e.att).forEach((c6) => {
    const a2 = Object.keys(e.att[c6]).map((f9) => ({ ability: f9.split("/")[0], action: f9.split("/")[1] }));
    a2.sort((f9, h6) => f9.action.localeCompare(h6.action));
    const u3 = {};
    a2.forEach((f9) => {
      u3[f9.ability] || (u3[f9.ability] = []), u3[f9.ability].push(f9.action);
    });
    const l6 = Object.keys(u3).map((f9) => (o2++, `(${o2}) '${f9}': '${u3[f9].join("', '")}' for '${c6}'.`));
    r2.push(l6.join(", ").replace(".,", "."));
  });
  const i5 = r2.join(" "), s3 = `${n4}${i5}`;
  return `${t ? t + " " : ""}${s3}`;
}
function ds(t) {
  var e;
  const n4 = yt(t);
  at(n4);
  const r2 = (e = n4.att) == null ? void 0 : e.eip155;
  return r2 ? Object.keys(r2).map((o2) => o2.split("/")[1]) : [];
}
function hs(t) {
  const e = yt(t);
  at(e);
  const n4 = [];
  return Object.values(e.att).forEach((r2) => {
    Object.values(r2).forEach((o2) => {
      var i5;
      (i5 = o2 == null ? void 0 : o2[0]) != null && i5.chains && n4.push(o2[0].chains);
    });
  }), [...new Set(n4.flat())];
}
function pe(t) {
  if (!t) return;
  const e = t == null ? void 0 : t[t.length - 1];
  return qe(e) ? e : void 0;
}
function Fe(t) {
  if (!Number.isSafeInteger(t) || t < 0) throw new Error("positive integer expected, got " + t);
}
function Sr(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function tt(t, ...e) {
  if (!Sr(t)) throw new Error("Uint8Array expected");
  if (e.length > 0 && !e.includes(t.length)) throw new Error("Uint8Array expected of length " + e + ", got length=" + t.length);
}
function Or(t, e = true) {
  if (t.destroyed) throw new Error("Hash instance has been destroyed");
  if (e && t.finished) throw new Error("Hash#digest() has already been called");
}
function ps(t, e) {
  tt(t);
  const n4 = e.outputLen;
  if (t.length < n4) throw new Error("digestInto() expects output buffer of length at least " + n4);
}
function Ar(t) {
  if (typeof t != "boolean") throw new Error(`boolean expected, not ${t}`);
}
var mt = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4));
var gs = (t) => new DataView(t.buffer, t.byteOffset, t.byteLength);
var ys = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!ys) throw new Error("Non little-endian hardware is not supported");
function ms(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
function ze(t) {
  if (typeof t == "string") t = ms(t);
  else if (Sr(t)) t = Ze(t);
  else throw new Error("Uint8Array expected, got " + typeof t);
  return t;
}
function ws(t, e) {
  if (e == null || typeof e != "object") throw new Error("options must be defined");
  return Object.assign(t, e);
}
function bs(t, e) {
  if (t.length !== e.length) return false;
  let n4 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n4 |= t[r2] ^ e[r2];
  return n4 === 0;
}
var Es = (t, e) => {
  function n4(r2, ...o2) {
    if (tt(r2), t.nonceLength !== void 0) {
      const l6 = o2[0];
      if (!l6) throw new Error("nonce / iv required");
      t.varSizeNonce ? tt(l6) : tt(l6, t.nonceLength);
    }
    const i5 = t.tagLength;
    i5 && o2[1] !== void 0 && tt(o2[1]);
    const s3 = e(r2, ...o2), c6 = (l6, f9) => {
      if (f9 !== void 0) {
        if (l6 !== 2) throw new Error("cipher output not supported");
        tt(f9);
      }
    };
    let a2 = false;
    return { encrypt(l6, f9) {
      if (a2) throw new Error("cannot encrypt() twice with same key + nonce");
      return a2 = true, tt(l6), c6(s3.encrypt.length, f9), s3.encrypt(l6, f9);
    }, decrypt(l6, f9) {
      if (tt(l6), i5 && l6.length < i5) throw new Error("invalid ciphertext length: smaller than tagLength=" + i5);
      return c6(s3.decrypt.length, f9), s3.decrypt(l6, f9);
    } };
  }
  return Object.assign(n4, t), n4;
};
function Br(t, e, n4 = true) {
  if (e === void 0) return new Uint8Array(t);
  if (e.length !== t) throw new Error("invalid output length, expected " + t + ", got: " + e.length);
  if (n4 && !vs(e)) throw new Error("invalid output, must be aligned");
  return e;
}
function Ir(t, e, n4, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n4, r2);
  const o2 = BigInt(32), i5 = BigInt(4294967295), s3 = Number(n4 >> o2 & i5), c6 = Number(n4 & i5), a2 = r2 ? 4 : 0, u3 = r2 ? 0 : 4;
  t.setUint32(e + a2, s3, r2), t.setUint32(e + u3, c6, r2);
}
function vs(t) {
  return t.byteOffset % 4 === 0;
}
function Ze(t) {
  return Uint8Array.from(t);
}
function jt(...t) {
  for (let e = 0; e < t.length; e++) t[e].fill(0);
}
var Nr = (t) => Uint8Array.from(t.split("").map((e) => e.charCodeAt(0)));
var xs = Nr("expand 16-byte k");
var Ss = Nr("expand 32-byte k");
var Os = mt(xs);
var As = mt(Ss);
function V(t, e) {
  return t << e | t >>> 32 - e;
}
function Ye(t) {
  return t.byteOffset % 4 === 0;
}
var ge = 64;
var Bs = 16;
var Ur = 2 ** 32 - 1;
var Tr = new Uint32Array();
function Is(t, e, n4, r2, o2, i5, s3, c6) {
  const a2 = o2.length, u3 = new Uint8Array(ge), l6 = mt(u3), f9 = Ye(o2) && Ye(i5), h6 = f9 ? mt(o2) : Tr, y7 = f9 ? mt(i5) : Tr;
  for (let E8 = 0; E8 < a2; s3++) {
    if (t(e, n4, r2, l6, s3, c6), s3 >= Ur) throw new Error("arx: counter overflow");
    const p6 = Math.min(ge, a2 - E8);
    if (f9 && p6 === ge) {
      const d4 = E8 / 4;
      if (E8 % 4 !== 0) throw new Error("arx: invalid block position");
      for (let v7 = 0, m3; v7 < Bs; v7++) m3 = d4 + v7, y7[m3] = h6[m3] ^ l6[v7];
      E8 += ge;
      continue;
    }
    for (let d4 = 0, v7; d4 < p6; d4++) v7 = E8 + d4, i5[v7] = o2[v7] ^ u3[d4];
    E8 += p6;
  }
}
function Ns(t, e) {
  const { allowShortKeys: n4, extendNonceFn: r2, counterLength: o2, counterRight: i5, rounds: s3 } = ws({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, e);
  if (typeof t != "function") throw new Error("core must be a function");
  return Fe(o2), Fe(s3), Ar(i5), Ar(n4), (c6, a2, u3, l6, f9 = 0) => {
    tt(c6), tt(a2), tt(u3);
    const h6 = u3.length;
    if (l6 === void 0 && (l6 = new Uint8Array(h6)), tt(l6), Fe(f9), f9 < 0 || f9 >= Ur) throw new Error("arx: counter overflow");
    if (l6.length < h6) throw new Error(`arx: output (${l6.length}) is shorter than data (${h6})`);
    const y7 = [];
    let E8 = c6.length, p6, d4;
    if (E8 === 32) y7.push(p6 = Ze(c6)), d4 = As;
    else if (E8 === 16 && n4) p6 = new Uint8Array(32), p6.set(c6), p6.set(c6, 16), d4 = Os, y7.push(p6);
    else throw new Error(`arx: invalid 32-byte key, got length=${E8}`);
    Ye(a2) || y7.push(a2 = Ze(a2));
    const v7 = mt(p6);
    if (r2) {
      if (a2.length !== 24) throw new Error("arx: extended nonce must be 24 bytes");
      r2(d4, v7, mt(a2.subarray(0, 16)), v7), a2 = a2.subarray(16);
    }
    const m3 = 16 - o2;
    if (m3 !== a2.length) throw new Error(`arx: nonce must be ${m3} or 16 bytes`);
    if (m3 !== 12) {
      const N4 = new Uint8Array(12);
      N4.set(a2, i5 ? 0 : 12 - a2.length), a2 = N4, y7.push(a2);
    }
    const O6 = mt(a2);
    return Is(t, d4, v7, O6, u3, l6, f9, s3), jt(...y7), l6;
  };
}
var F = (t, e) => t[e++] & 255 | (t[e++] & 255) << 8;
var Us = class {
  constructor(e) {
    this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = false, e = ze(e), tt(e, 32);
    const n4 = F(e, 0), r2 = F(e, 2), o2 = F(e, 4), i5 = F(e, 6), s3 = F(e, 8), c6 = F(e, 10), a2 = F(e, 12), u3 = F(e, 14);
    this.r[0] = n4 & 8191, this.r[1] = (n4 >>> 13 | r2 << 3) & 8191, this.r[2] = (r2 >>> 10 | o2 << 6) & 7939, this.r[3] = (o2 >>> 7 | i5 << 9) & 8191, this.r[4] = (i5 >>> 4 | s3 << 12) & 255, this.r[5] = s3 >>> 1 & 8190, this.r[6] = (s3 >>> 14 | c6 << 2) & 8191, this.r[7] = (c6 >>> 11 | a2 << 5) & 8065, this.r[8] = (a2 >>> 8 | u3 << 8) & 8191, this.r[9] = u3 >>> 5 & 127;
    for (let l6 = 0; l6 < 8; l6++) this.pad[l6] = F(e, 16 + 2 * l6);
  }
  process(e, n4, r2 = false) {
    const o2 = r2 ? 0 : 2048, { h: i5, r: s3 } = this, c6 = s3[0], a2 = s3[1], u3 = s3[2], l6 = s3[3], f9 = s3[4], h6 = s3[5], y7 = s3[6], E8 = s3[7], p6 = s3[8], d4 = s3[9], v7 = F(e, n4 + 0), m3 = F(e, n4 + 2), O6 = F(e, n4 + 4), N4 = F(e, n4 + 6), $5 = F(e, n4 + 8), B5 = F(e, n4 + 10), A5 = F(e, n4 + 12), T5 = F(e, n4 + 14);
    let S7 = i5[0] + (v7 & 8191), L5 = i5[1] + ((v7 >>> 13 | m3 << 3) & 8191), U7 = i5[2] + ((m3 >>> 10 | O6 << 6) & 8191), _5 = i5[3] + ((O6 >>> 7 | N4 << 9) & 8191), j4 = i5[4] + ((N4 >>> 4 | $5 << 12) & 8191), g3 = i5[5] + ($5 >>> 1 & 8191), w5 = i5[6] + (($5 >>> 14 | B5 << 2) & 8191), b7 = i5[7] + ((B5 >>> 11 | A5 << 5) & 8191), I5 = i5[8] + ((A5 >>> 8 | T5 << 8) & 8191), R5 = i5[9] + (T5 >>> 5 | o2), x5 = 0, C7 = x5 + S7 * c6 + L5 * (5 * d4) + U7 * (5 * p6) + _5 * (5 * E8) + j4 * (5 * y7);
    x5 = C7 >>> 13, C7 &= 8191, C7 += g3 * (5 * h6) + w5 * (5 * f9) + b7 * (5 * l6) + I5 * (5 * u3) + R5 * (5 * a2), x5 += C7 >>> 13, C7 &= 8191;
    let P4 = x5 + S7 * a2 + L5 * c6 + U7 * (5 * d4) + _5 * (5 * p6) + j4 * (5 * E8);
    x5 = P4 >>> 13, P4 &= 8191, P4 += g3 * (5 * y7) + w5 * (5 * h6) + b7 * (5 * f9) + I5 * (5 * l6) + R5 * (5 * u3), x5 += P4 >>> 13, P4 &= 8191;
    let k9 = x5 + S7 * u3 + L5 * a2 + U7 * c6 + _5 * (5 * d4) + j4 * (5 * p6);
    x5 = k9 >>> 13, k9 &= 8191, k9 += g3 * (5 * E8) + w5 * (5 * y7) + b7 * (5 * h6) + I5 * (5 * f9) + R5 * (5 * l6), x5 += k9 >>> 13, k9 &= 8191;
    let M5 = x5 + S7 * l6 + L5 * u3 + U7 * a2 + _5 * c6 + j4 * (5 * d4);
    x5 = M5 >>> 13, M5 &= 8191, M5 += g3 * (5 * p6) + w5 * (5 * E8) + b7 * (5 * y7) + I5 * (5 * h6) + R5 * (5 * f9), x5 += M5 >>> 13, M5 &= 8191;
    let D4 = x5 + S7 * f9 + L5 * l6 + U7 * u3 + _5 * a2 + j4 * c6;
    x5 = D4 >>> 13, D4 &= 8191, D4 += g3 * (5 * d4) + w5 * (5 * p6) + b7 * (5 * E8) + I5 * (5 * y7) + R5 * (5 * h6), x5 += D4 >>> 13, D4 &= 8191;
    let z6 = x5 + S7 * h6 + L5 * f9 + U7 * l6 + _5 * u3 + j4 * a2;
    x5 = z6 >>> 13, z6 &= 8191, z6 += g3 * c6 + w5 * (5 * d4) + b7 * (5 * p6) + I5 * (5 * E8) + R5 * (5 * y7), x5 += z6 >>> 13, z6 &= 8191;
    let Z3 = x5 + S7 * y7 + L5 * h6 + U7 * f9 + _5 * l6 + j4 * u3;
    x5 = Z3 >>> 13, Z3 &= 8191, Z3 += g3 * a2 + w5 * c6 + b7 * (5 * d4) + I5 * (5 * p6) + R5 * (5 * E8), x5 += Z3 >>> 13, Z3 &= 8191;
    let st3 = x5 + S7 * E8 + L5 * y7 + U7 * h6 + _5 * f9 + j4 * l6;
    x5 = st3 >>> 13, st3 &= 8191, st3 += g3 * u3 + w5 * a2 + b7 * c6 + I5 * (5 * d4) + R5 * (5 * p6), x5 += st3 >>> 13, st3 &= 8191;
    let W4 = x5 + S7 * p6 + L5 * E8 + U7 * y7 + _5 * h6 + j4 * f9;
    x5 = W4 >>> 13, W4 &= 8191, W4 += g3 * l6 + w5 * u3 + b7 * a2 + I5 * c6 + R5 * (5 * d4), x5 += W4 >>> 13, W4 &= 8191;
    let J4 = x5 + S7 * d4 + L5 * p6 + U7 * E8 + _5 * y7 + j4 * h6;
    x5 = J4 >>> 13, J4 &= 8191, J4 += g3 * f9 + w5 * l6 + b7 * u3 + I5 * a2 + R5 * c6, x5 += J4 >>> 13, J4 &= 8191, x5 = (x5 << 2) + x5 | 0, x5 = x5 + C7 | 0, C7 = x5 & 8191, x5 = x5 >>> 13, P4 += x5, i5[0] = C7, i5[1] = P4, i5[2] = k9, i5[3] = M5, i5[4] = D4, i5[5] = z6, i5[6] = Z3, i5[7] = st3, i5[8] = W4, i5[9] = J4;
  }
  finalize() {
    const { h: e, pad: n4 } = this, r2 = new Uint16Array(10);
    let o2 = e[1] >>> 13;
    e[1] &= 8191;
    for (let c6 = 2; c6 < 10; c6++) e[c6] += o2, o2 = e[c6] >>> 13, e[c6] &= 8191;
    e[0] += o2 * 5, o2 = e[0] >>> 13, e[0] &= 8191, e[1] += o2, o2 = e[1] >>> 13, e[1] &= 8191, e[2] += o2, r2[0] = e[0] + 5, o2 = r2[0] >>> 13, r2[0] &= 8191;
    for (let c6 = 1; c6 < 10; c6++) r2[c6] = e[c6] + o2, o2 = r2[c6] >>> 13, r2[c6] &= 8191;
    r2[9] -= 8192;
    let i5 = (o2 ^ 1) - 1;
    for (let c6 = 0; c6 < 10; c6++) r2[c6] &= i5;
    i5 = ~i5;
    for (let c6 = 0; c6 < 10; c6++) e[c6] = e[c6] & i5 | r2[c6];
    e[0] = (e[0] | e[1] << 13) & 65535, e[1] = (e[1] >>> 3 | e[2] << 10) & 65535, e[2] = (e[2] >>> 6 | e[3] << 7) & 65535, e[3] = (e[3] >>> 9 | e[4] << 4) & 65535, e[4] = (e[4] >>> 12 | e[5] << 1 | e[6] << 14) & 65535, e[5] = (e[6] >>> 2 | e[7] << 11) & 65535, e[6] = (e[7] >>> 5 | e[8] << 8) & 65535, e[7] = (e[8] >>> 8 | e[9] << 5) & 65535;
    let s3 = e[0] + n4[0];
    e[0] = s3 & 65535;
    for (let c6 = 1; c6 < 8; c6++) s3 = (e[c6] + n4[c6] | 0) + (s3 >>> 16) | 0, e[c6] = s3 & 65535;
    jt(r2);
  }
  update(e) {
    Or(this);
    const { buffer: n4, blockLen: r2 } = this;
    e = ze(e);
    const o2 = e.length;
    for (let i5 = 0; i5 < o2; ) {
      const s3 = Math.min(r2 - this.pos, o2 - i5);
      if (s3 === r2) {
        for (; r2 <= o2 - i5; i5 += r2) this.process(e, i5);
        continue;
      }
      n4.set(e.subarray(i5, i5 + s3), this.pos), this.pos += s3, i5 += s3, this.pos === r2 && (this.process(n4, 0, false), this.pos = 0);
    }
    return this;
  }
  destroy() {
    jt(this.h, this.r, this.buffer, this.pad);
  }
  digestInto(e) {
    Or(this), ps(e, this), this.finished = true;
    const { buffer: n4, h: r2 } = this;
    let { pos: o2 } = this;
    if (o2) {
      for (n4[o2++] = 1; o2 < 16; o2++) n4[o2] = 0;
      this.process(n4, 0, true);
    }
    this.finalize();
    let i5 = 0;
    for (let s3 = 0; s3 < 8; s3++) e[i5++] = r2[s3] >>> 0, e[i5++] = r2[s3] >>> 8;
    return e;
  }
  digest() {
    const { buffer: e, outputLen: n4 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n4);
    return this.destroy(), r2;
  }
};
function Ts(t) {
  const e = (r2, o2) => t(o2).update(ze(r2)).digest(), n4 = t(new Uint8Array(32));
  return e.outputLen = n4.outputLen, e.blockLen = n4.blockLen, e.create = (r2) => t(r2), e;
}
var Rs = Ts((t) => new Us(t));
function _s(t, e, n4, r2, o2, i5 = 20) {
  let s3 = t[0], c6 = t[1], a2 = t[2], u3 = t[3], l6 = e[0], f9 = e[1], h6 = e[2], y7 = e[3], E8 = e[4], p6 = e[5], d4 = e[6], v7 = e[7], m3 = o2, O6 = n4[0], N4 = n4[1], $5 = n4[2], B5 = s3, A5 = c6, T5 = a2, S7 = u3, L5 = l6, U7 = f9, _5 = h6, j4 = y7, g3 = E8, w5 = p6, b7 = d4, I5 = v7, R5 = m3, x5 = O6, C7 = N4, P4 = $5;
  for (let M5 = 0; M5 < i5; M5 += 2) B5 = B5 + L5 | 0, R5 = V(R5 ^ B5, 16), g3 = g3 + R5 | 0, L5 = V(L5 ^ g3, 12), B5 = B5 + L5 | 0, R5 = V(R5 ^ B5, 8), g3 = g3 + R5 | 0, L5 = V(L5 ^ g3, 7), A5 = A5 + U7 | 0, x5 = V(x5 ^ A5, 16), w5 = w5 + x5 | 0, U7 = V(U7 ^ w5, 12), A5 = A5 + U7 | 0, x5 = V(x5 ^ A5, 8), w5 = w5 + x5 | 0, U7 = V(U7 ^ w5, 7), T5 = T5 + _5 | 0, C7 = V(C7 ^ T5, 16), b7 = b7 + C7 | 0, _5 = V(_5 ^ b7, 12), T5 = T5 + _5 | 0, C7 = V(C7 ^ T5, 8), b7 = b7 + C7 | 0, _5 = V(_5 ^ b7, 7), S7 = S7 + j4 | 0, P4 = V(P4 ^ S7, 16), I5 = I5 + P4 | 0, j4 = V(j4 ^ I5, 12), S7 = S7 + j4 | 0, P4 = V(P4 ^ S7, 8), I5 = I5 + P4 | 0, j4 = V(j4 ^ I5, 7), B5 = B5 + U7 | 0, P4 = V(P4 ^ B5, 16), b7 = b7 + P4 | 0, U7 = V(U7 ^ b7, 12), B5 = B5 + U7 | 0, P4 = V(P4 ^ B5, 8), b7 = b7 + P4 | 0, U7 = V(U7 ^ b7, 7), A5 = A5 + _5 | 0, R5 = V(R5 ^ A5, 16), I5 = I5 + R5 | 0, _5 = V(_5 ^ I5, 12), A5 = A5 + _5 | 0, R5 = V(R5 ^ A5, 8), I5 = I5 + R5 | 0, _5 = V(_5 ^ I5, 7), T5 = T5 + j4 | 0, x5 = V(x5 ^ T5, 16), g3 = g3 + x5 | 0, j4 = V(j4 ^ g3, 12), T5 = T5 + j4 | 0, x5 = V(x5 ^ T5, 8), g3 = g3 + x5 | 0, j4 = V(j4 ^ g3, 7), S7 = S7 + L5 | 0, C7 = V(C7 ^ S7, 16), w5 = w5 + C7 | 0, L5 = V(L5 ^ w5, 12), S7 = S7 + L5 | 0, C7 = V(C7 ^ S7, 8), w5 = w5 + C7 | 0, L5 = V(L5 ^ w5, 7);
  let k9 = 0;
  r2[k9++] = s3 + B5 | 0, r2[k9++] = c6 + A5 | 0, r2[k9++] = a2 + T5 | 0, r2[k9++] = u3 + S7 | 0, r2[k9++] = l6 + L5 | 0, r2[k9++] = f9 + U7 | 0, r2[k9++] = h6 + _5 | 0, r2[k9++] = y7 + j4 | 0, r2[k9++] = E8 + g3 | 0, r2[k9++] = p6 + w5 | 0, r2[k9++] = d4 + b7 | 0, r2[k9++] = v7 + I5 | 0, r2[k9++] = m3 + R5 | 0, r2[k9++] = O6 + x5 | 0, r2[k9++] = N4 + C7 | 0, r2[k9++] = $5 + P4 | 0;
}
var $s = Ns(_s, { counterRight: false, counterLength: 4, allowShortKeys: false });
var Ls = new Uint8Array(16);
var Rr = (t, e) => {
  t.update(e);
  const n4 = e.length % 16;
  n4 && t.update(Ls.subarray(n4));
};
var js = new Uint8Array(32);
function _r(t, e, n4, r2, o2) {
  const i5 = t(e, n4, js), s3 = Rs.create(i5);
  o2 && Rr(s3, o2), Rr(s3, r2);
  const c6 = new Uint8Array(16), a2 = gs(c6);
  Ir(a2, 0, BigInt(o2 ? o2.length : 0), true), Ir(a2, 8, BigInt(r2.length), true), s3.update(c6);
  const u3 = s3.digest();
  return jt(i5, c6), u3;
}
var Cs = (t) => (e, n4, r2) => ({ encrypt(i5, s3) {
  const c6 = i5.length;
  s3 = Br(c6 + 16, s3, false), s3.set(i5);
  const a2 = s3.subarray(0, -16);
  t(e, n4, a2, a2, 1);
  const u3 = _r(t, e, n4, a2, r2);
  return s3.set(u3, c6), jt(u3), s3;
}, decrypt(i5, s3) {
  s3 = Br(i5.length - 16, s3, false);
  const c6 = i5.subarray(0, -16), a2 = i5.subarray(-16), u3 = _r(t, e, n4, c6, r2);
  if (!bs(a2, u3)) throw new Error("invalid tag");
  return s3.set(i5.subarray(0, -16)), t(e, n4, s3, s3, 1), jt(u3), s3;
} });
var $r = Es({ blockSize: 64, nonceLength: 12, tagLength: 16 }, Cs($s));
var Lr = class extends ke {
  constructor(e, n4) {
    super(), this.finished = false, this.destroyed = false, Ce(e);
    const r2 = $t(n4);
    if (this.iHash = e.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const o2 = this.blockLen, i5 = new Uint8Array(o2);
    i5.set(r2.length > o2 ? e.create().update(r2).digest() : r2);
    for (let s3 = 0; s3 < i5.length; s3++) i5[s3] ^= 54;
    this.iHash.update(i5), this.oHash = e.create();
    for (let s3 = 0; s3 < i5.length; s3++) i5[s3] ^= 106;
    this.oHash.update(i5), i5.fill(0);
  }
  update(e) {
    return Rt(this), this.iHash.update(e), this;
  }
  digestInto(e) {
    Rt(this), Xt(e, this.outputLen), this.finished = true, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();
  }
  digest() {
    const e = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(e), e;
  }
  _cloneInto(e) {
    e || (e = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n4, iHash: r2, finished: o2, destroyed: i5, blockLen: s3, outputLen: c6 } = this;
    return e = e, e.finished = o2, e.destroyed = i5, e.blockLen = s3, e.outputLen = c6, e.oHash = n4._cloneInto(e.oHash), e.iHash = r2._cloneInto(e.iHash), e;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var ye = (t, e, n4) => new Lr(t, e).update(n4).digest();
ye.create = (t, e) => new Lr(t, e);
function Ps(t, e, n4) {
  return Ce(t), n4 === void 0 && (n4 = new Uint8Array(t.outputLen)), ye(t, $t(n4), $t(e));
}
var Ge = new Uint8Array([0]);
var jr = new Uint8Array();
function ks(t, e, n4, r2 = 32) {
  if (Ce(t), Wt(r2), r2 > 255 * t.outputLen) throw new Error("Length should be <= 255*HashLen");
  const o2 = Math.ceil(r2 / t.outputLen);
  n4 === void 0 && (n4 = jr);
  const i5 = new Uint8Array(o2 * t.outputLen), s3 = ye.create(t, e), c6 = s3._cloneInto(), a2 = new Uint8Array(s3.outputLen);
  for (let u3 = 0; u3 < o2; u3++) Ge[0] = u3 + 1, c6.update(u3 === 0 ? jr : a2).update(n4).update(Ge).digestInto(a2), i5.set(a2, t.outputLen * u3), s3._cloneInto(c6);
  return s3.destroy(), c6.destroy(), a2.fill(0), Ge.fill(0), i5.slice(0, r2);
}
var Vs = (t, e, n4, r2, o2) => ks(t, Ps(t, e, n4), r2, o2);
function Ms(t, e, n4, r2) {
  if (typeof t.setBigUint64 == "function") return t.setBigUint64(e, n4, r2);
  const o2 = BigInt(32), i5 = BigInt(4294967295), s3 = Number(n4 >> o2 & i5), c6 = Number(n4 & i5), a2 = r2 ? 4 : 0, u3 = r2 ? 0 : 4;
  t.setUint32(e + a2, s3, r2), t.setUint32(e + u3, c6, r2);
}
function Ds(t, e, n4) {
  return t & e ^ ~t & n4;
}
function Hs(t, e, n4) {
  return t & e ^ t & n4 ^ e & n4;
}
var qs = class extends ke {
  constructor(e, n4, r2, o2) {
    super(), this.blockLen = e, this.outputLen = n4, this.padOffset = r2, this.isLE = o2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(e), this.view = Pe(this.buffer);
  }
  update(e) {
    Rt(this);
    const { view: n4, buffer: r2, blockLen: o2 } = this;
    e = $t(e);
    const i5 = e.length;
    for (let s3 = 0; s3 < i5; ) {
      const c6 = Math.min(o2 - this.pos, i5 - s3);
      if (c6 === o2) {
        const a2 = Pe(e);
        for (; o2 <= i5 - s3; s3 += o2) this.process(a2, s3);
        continue;
      }
      r2.set(e.subarray(s3, s3 + c6), this.pos), this.pos += c6, s3 += c6, this.pos === o2 && (this.process(n4, 0), this.pos = 0);
    }
    return this.length += e.length, this.roundClean(), this;
  }
  digestInto(e) {
    Rt(this), Gn(e, this), this.finished = true;
    const { buffer: n4, view: r2, blockLen: o2, isLE: i5 } = this;
    let { pos: s3 } = this;
    n4[s3++] = 128, this.buffer.subarray(s3).fill(0), this.padOffset > o2 - s3 && (this.process(r2, 0), s3 = 0);
    for (let f9 = s3; f9 < o2; f9++) n4[f9] = 0;
    Ms(r2, o2 - 8, BigInt(this.length * 8), i5), this.process(r2, 0);
    const c6 = Pe(e), a2 = this.outputLen;
    if (a2 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u3 = a2 / 4, l6 = this.get();
    if (u3 > l6.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f9 = 0; f9 < u3; f9++) c6.setUint32(4 * f9, l6[f9], i5);
  }
  digest() {
    const { buffer: e, outputLen: n4 } = this;
    this.digestInto(e);
    const r2 = e.slice(0, n4);
    return this.destroy(), r2;
  }
  _cloneInto(e) {
    e || (e = new this.constructor()), e.set(...this.get());
    const { blockLen: n4, buffer: r2, length: o2, finished: i5, destroyed: s3, pos: c6 } = this;
    return e.length = o2, e.pos = c6, e.finished = i5, e.destroyed = s3, o2 % n4 && e.buffer.set(r2), e;
  }
};
var Ks = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var wt = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var bt = new Uint32Array(64);
var Fs = class extends qs {
  constructor() {
    super(64, 32, 8, false), this.A = wt[0] | 0, this.B = wt[1] | 0, this.C = wt[2] | 0, this.D = wt[3] | 0, this.E = wt[4] | 0, this.F = wt[5] | 0, this.G = wt[6] | 0, this.H = wt[7] | 0;
  }
  get() {
    const { A: e, B: n4, C: r2, D: o2, E: i5, F: s3, G: c6, H: a2 } = this;
    return [e, n4, r2, o2, i5, s3, c6, a2];
  }
  set(e, n4, r2, o2, i5, s3, c6, a2) {
    this.A = e | 0, this.B = n4 | 0, this.C = r2 | 0, this.D = o2 | 0, this.E = i5 | 0, this.F = s3 | 0, this.G = c6 | 0, this.H = a2 | 0;
  }
  process(e, n4) {
    for (let f9 = 0; f9 < 16; f9++, n4 += 4) bt[f9] = e.getUint32(n4, false);
    for (let f9 = 16; f9 < 64; f9++) {
      const h6 = bt[f9 - 15], y7 = bt[f9 - 2], E8 = ct(h6, 7) ^ ct(h6, 18) ^ h6 >>> 3, p6 = ct(y7, 17) ^ ct(y7, 19) ^ y7 >>> 10;
      bt[f9] = p6 + bt[f9 - 7] + E8 + bt[f9 - 16] | 0;
    }
    let { A: r2, B: o2, C: i5, D: s3, E: c6, F: a2, G: u3, H: l6 } = this;
    for (let f9 = 0; f9 < 64; f9++) {
      const h6 = ct(c6, 6) ^ ct(c6, 11) ^ ct(c6, 25), y7 = l6 + h6 + Ds(c6, a2, u3) + Ks[f9] + bt[f9] | 0, p6 = (ct(r2, 2) ^ ct(r2, 13) ^ ct(r2, 22)) + Hs(r2, o2, i5) | 0;
      l6 = u3, u3 = a2, a2 = c6, c6 = s3 + y7 | 0, s3 = i5, i5 = o2, o2 = r2, r2 = y7 + p6 | 0;
    }
    r2 = r2 + this.A | 0, o2 = o2 + this.B | 0, i5 = i5 + this.C | 0, s3 = s3 + this.D | 0, c6 = c6 + this.E | 0, a2 = a2 + this.F | 0, u3 = u3 + this.G | 0, l6 = l6 + this.H | 0, this.set(r2, o2, i5, s3, c6, a2, u3, l6);
  }
  roundClean() {
    bt.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var Qt = Qn(() => new Fs());
var me = BigInt(0);
var we = BigInt(1);
var zs = BigInt(2);
function St(t) {
  return t instanceof Uint8Array || ArrayBuffer.isView(t) && t.constructor.name === "Uint8Array";
}
function te(t) {
  if (!St(t)) throw new Error("Uint8Array expected");
}
function Ct(t, e) {
  if (typeof e != "boolean") throw new Error(t + " boolean expected, got " + e);
}
var Zs = Array.from({ length: 256 }, (t, e) => e.toString(16).padStart(2, "0"));
function Pt(t) {
  te(t);
  let e = "";
  for (let n4 = 0; n4 < t.length; n4++) e += Zs[t[n4]];
  return e;
}
function kt(t) {
  const e = t.toString(16);
  return e.length & 1 ? "0" + e : e;
}
function We(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  return t === "" ? me : BigInt("0x" + t);
}
var ut = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function Cr(t) {
  if (t >= ut._0 && t <= ut._9) return t - ut._0;
  if (t >= ut.A && t <= ut.F) return t - (ut.A - 10);
  if (t >= ut.a && t <= ut.f) return t - (ut.a - 10);
}
function Vt(t) {
  if (typeof t != "string") throw new Error("hex string expected, got " + typeof t);
  const e = t.length, n4 = e / 2;
  if (e % 2) throw new Error("hex string expected, got unpadded hex of length " + e);
  const r2 = new Uint8Array(n4);
  for (let o2 = 0, i5 = 0; o2 < n4; o2++, i5 += 2) {
    const s3 = Cr(t.charCodeAt(i5)), c6 = Cr(t.charCodeAt(i5 + 1));
    if (s3 === void 0 || c6 === void 0) {
      const a2 = t[i5] + t[i5 + 1];
      throw new Error('hex string expected, got non-hex character "' + a2 + '" at index ' + i5);
    }
    r2[o2] = s3 * 16 + c6;
  }
  return r2;
}
function Ot(t) {
  return We(Pt(t));
}
function ee(t) {
  return te(t), We(Pt(Uint8Array.from(t).reverse()));
}
function Mt(t, e) {
  return Vt(t.toString(16).padStart(e * 2, "0"));
}
function be(t, e) {
  return Mt(t, e).reverse();
}
function Ys(t) {
  return Vt(kt(t));
}
function et(t, e, n4) {
  let r2;
  if (typeof e == "string") try {
    r2 = Vt(e);
  } catch (i5) {
    throw new Error(t + " must be hex string or Uint8Array, cause: " + i5);
  }
  else if (St(e)) r2 = Uint8Array.from(e);
  else throw new Error(t + " must be hex string or Uint8Array");
  const o2 = r2.length;
  if (typeof n4 == "number" && o2 !== n4) throw new Error(t + " of length " + n4 + " expected, got " + o2);
  return r2;
}
function ne(...t) {
  let e = 0;
  for (let r2 = 0; r2 < t.length; r2++) {
    const o2 = t[r2];
    te(o2), e += o2.length;
  }
  const n4 = new Uint8Array(e);
  for (let r2 = 0, o2 = 0; r2 < t.length; r2++) {
    const i5 = t[r2];
    n4.set(i5, o2), o2 += i5.length;
  }
  return n4;
}
function Gs(t, e) {
  if (t.length !== e.length) return false;
  let n4 = 0;
  for (let r2 = 0; r2 < t.length; r2++) n4 |= t[r2] ^ e[r2];
  return n4 === 0;
}
function Ws(t) {
  if (typeof t != "string") throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(t));
}
var Xe = (t) => typeof t == "bigint" && me <= t;
function Ee(t, e, n4) {
  return Xe(t) && Xe(e) && Xe(n4) && e <= t && t < n4;
}
function ft(t, e, n4, r2) {
  if (!Ee(e, n4, r2)) throw new Error("expected valid " + t + ": " + n4 + " <= n < " + r2 + ", got " + e);
}
function Pr(t) {
  let e;
  for (e = 0; t > me; t >>= we, e += 1) ;
  return e;
}
function Xs(t, e) {
  return t >> BigInt(e) & we;
}
function Js(t, e, n4) {
  return t | (n4 ? we : me) << BigInt(e);
}
var Je = (t) => (zs << BigInt(t - 1)) - we;
var Qe2 = (t) => new Uint8Array(t);
var kr = (t) => Uint8Array.from(t);
function Vr(t, e, n4) {
  if (typeof t != "number" || t < 2) throw new Error("hashLen must be a number");
  if (typeof e != "number" || e < 2) throw new Error("qByteLen must be a number");
  if (typeof n4 != "function") throw new Error("hmacFn must be a function");
  let r2 = Qe2(t), o2 = Qe2(t), i5 = 0;
  const s3 = () => {
    r2.fill(1), o2.fill(0), i5 = 0;
  }, c6 = (...f9) => n4(o2, r2, ...f9), a2 = (f9 = Qe2()) => {
    o2 = c6(kr([0]), f9), r2 = c6(), f9.length !== 0 && (o2 = c6(kr([1]), f9), r2 = c6());
  }, u3 = () => {
    if (i5++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let f9 = 0;
    const h6 = [];
    for (; f9 < e; ) {
      r2 = c6();
      const y7 = r2.slice();
      h6.push(y7), f9 += r2.length;
    }
    return ne(...h6);
  };
  return (f9, h6) => {
    s3(), a2(f9);
    let y7;
    for (; !(y7 = h6(u3())); ) a2();
    return s3(), y7;
  };
}
var Qs = { bigint: (t) => typeof t == "bigint", function: (t) => typeof t == "function", boolean: (t) => typeof t == "boolean", string: (t) => typeof t == "string", stringOrUint8Array: (t) => typeof t == "string" || St(t), isSafeInteger: (t) => Number.isSafeInteger(t), array: (t) => Array.isArray(t), field: (t, e) => e.Fp.isValid(t), hash: (t) => typeof t == "function" && Number.isSafeInteger(t.outputLen) };
function Dt(t, e, n4 = {}) {
  const r2 = (o2, i5, s3) => {
    const c6 = Qs[i5];
    if (typeof c6 != "function") throw new Error("invalid validator function");
    const a2 = t[o2];
    if (!(s3 && a2 === void 0) && !c6(a2, t)) throw new Error("param " + String(o2) + " is invalid. Expected " + i5 + ", got " + a2);
  };
  for (const [o2, i5] of Object.entries(e)) r2(o2, i5, false);
  for (const [o2, i5] of Object.entries(n4)) r2(o2, i5, true);
  return t;
}
var tc = () => {
  throw new Error("not implemented");
};
function tn(t) {
  const e = /* @__PURE__ */ new WeakMap();
  return (n4, ...r2) => {
    const o2 = e.get(n4);
    if (o2 !== void 0) return o2;
    const i5 = t(n4, ...r2);
    return e.set(n4, i5), i5;
  };
}
var ec = Object.freeze({ __proto__: null, isBytes: St, abytes: te, abool: Ct, bytesToHex: Pt, numberToHexUnpadded: kt, hexToNumber: We, hexToBytes: Vt, bytesToNumberBE: Ot, bytesToNumberLE: ee, numberToBytesBE: Mt, numberToBytesLE: be, numberToVarBytesBE: Ys, ensureBytes: et, concatBytes: ne, equalBytes: Gs, utf8ToBytes: Ws, inRange: Ee, aInRange: ft, bitLen: Pr, bitGet: Xs, bitSet: Js, bitMask: Je, createHmacDrbg: Vr, validateObject: Dt, notImplemented: tc, memoized: tn });
var q = BigInt(0);
var H = BigInt(1);
var At = BigInt(2);
var nc = BigInt(3);
var en = BigInt(4);
var Mr = BigInt(5);
var Dr = BigInt(8);
function X(t, e) {
  const n4 = t % e;
  return n4 >= q ? n4 : e + n4;
}
function Hr(t, e, n4) {
  if (e < q) throw new Error("invalid exponent, negatives unsupported");
  if (n4 <= q) throw new Error("invalid modulus");
  if (n4 === H) return q;
  let r2 = H;
  for (; e > q; ) e & H && (r2 = r2 * t % n4), t = t * t % n4, e >>= H;
  return r2;
}
function it(t, e, n4) {
  let r2 = t;
  for (; e-- > q; ) r2 *= r2, r2 %= n4;
  return r2;
}
function nn(t, e) {
  if (t === q) throw new Error("invert: expected non-zero number");
  if (e <= q) throw new Error("invert: expected positive modulus, got " + e);
  let n4 = X(t, e), r2 = e, o2 = q, i5 = H;
  for (; n4 !== q; ) {
    const c6 = r2 / n4, a2 = r2 % n4, u3 = o2 - i5 * c6;
    r2 = n4, n4 = a2, o2 = i5, i5 = u3;
  }
  if (r2 !== H) throw new Error("invert: does not exist");
  return X(o2, e);
}
function rc(t) {
  const e = (t - H) / At;
  let n4, r2, o2;
  for (n4 = t - H, r2 = 0; n4 % At === q; n4 /= At, r2++) ;
  for (o2 = At; o2 < t && Hr(o2, e, t) !== t - H; o2++) if (o2 > 1e3) throw new Error("Cannot find square root: likely non-prime P");
  if (r2 === 1) {
    const s3 = (t + H) / en;
    return function(a2, u3) {
      const l6 = a2.pow(u3, s3);
      if (!a2.eql(a2.sqr(l6), u3)) throw new Error("Cannot find square root");
      return l6;
    };
  }
  const i5 = (n4 + H) / At;
  return function(c6, a2) {
    if (c6.pow(a2, e) === c6.neg(c6.ONE)) throw new Error("Cannot find square root");
    let u3 = r2, l6 = c6.pow(c6.mul(c6.ONE, o2), n4), f9 = c6.pow(a2, i5), h6 = c6.pow(a2, n4);
    for (; !c6.eql(h6, c6.ONE); ) {
      if (c6.eql(h6, c6.ZERO)) return c6.ZERO;
      let y7 = 1;
      for (let p6 = c6.sqr(h6); y7 < u3 && !c6.eql(p6, c6.ONE); y7++) p6 = c6.sqr(p6);
      const E8 = c6.pow(l6, H << BigInt(u3 - y7 - 1));
      l6 = c6.sqr(E8), f9 = c6.mul(f9, E8), h6 = c6.mul(h6, l6), u3 = y7;
    }
    return f9;
  };
}
function oc(t) {
  if (t % en === nc) {
    const e = (t + H) / en;
    return function(r2, o2) {
      const i5 = r2.pow(o2, e);
      if (!r2.eql(r2.sqr(i5), o2)) throw new Error("Cannot find square root");
      return i5;
    };
  }
  if (t % Dr === Mr) {
    const e = (t - Mr) / Dr;
    return function(r2, o2) {
      const i5 = r2.mul(o2, At), s3 = r2.pow(i5, e), c6 = r2.mul(o2, s3), a2 = r2.mul(r2.mul(c6, At), s3), u3 = r2.mul(c6, r2.sub(a2, r2.ONE));
      if (!r2.eql(r2.sqr(u3), o2)) throw new Error("Cannot find square root");
      return u3;
    };
  }
  return rc(t);
}
var ic = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function sc(t) {
  const e = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, n4 = ic.reduce((r2, o2) => (r2[o2] = "function", r2), e);
  return Dt(t, n4);
}
function cc(t, e, n4) {
  if (n4 < q) throw new Error("invalid exponent, negatives unsupported");
  if (n4 === q) return t.ONE;
  if (n4 === H) return e;
  let r2 = t.ONE, o2 = e;
  for (; n4 > q; ) n4 & H && (r2 = t.mul(r2, o2)), o2 = t.sqr(o2), n4 >>= H;
  return r2;
}
function ac(t, e) {
  const n4 = new Array(e.length), r2 = e.reduce((i5, s3, c6) => t.is0(s3) ? i5 : (n4[c6] = i5, t.mul(i5, s3)), t.ONE), o2 = t.inv(r2);
  return e.reduceRight((i5, s3, c6) => t.is0(s3) ? i5 : (n4[c6] = t.mul(i5, n4[c6]), t.mul(i5, s3)), o2), n4;
}
function qr(t, e) {
  const n4 = e !== void 0 ? e : t.toString(2).length, r2 = Math.ceil(n4 / 8);
  return { nBitLength: n4, nByteLength: r2 };
}
function Kr2(t, e, n4 = false, r2 = {}) {
  if (t <= q) throw new Error("invalid field: expected ORDER > 0, got " + t);
  const { nBitLength: o2, nByteLength: i5 } = qr(t, e);
  if (i5 > 2048) throw new Error("invalid field: expected ORDER of <= 2048 bytes");
  let s3;
  const c6 = Object.freeze({ ORDER: t, isLE: n4, BITS: o2, BYTES: i5, MASK: Je(o2), ZERO: q, ONE: H, create: (a2) => X(a2, t), isValid: (a2) => {
    if (typeof a2 != "bigint") throw new Error("invalid field element: expected bigint, got " + typeof a2);
    return q <= a2 && a2 < t;
  }, is0: (a2) => a2 === q, isOdd: (a2) => (a2 & H) === H, neg: (a2) => X(-a2, t), eql: (a2, u3) => a2 === u3, sqr: (a2) => X(a2 * a2, t), add: (a2, u3) => X(a2 + u3, t), sub: (a2, u3) => X(a2 - u3, t), mul: (a2, u3) => X(a2 * u3, t), pow: (a2, u3) => cc(c6, a2, u3), div: (a2, u3) => X(a2 * nn(u3, t), t), sqrN: (a2) => a2 * a2, addN: (a2, u3) => a2 + u3, subN: (a2, u3) => a2 - u3, mulN: (a2, u3) => a2 * u3, inv: (a2) => nn(a2, t), sqrt: r2.sqrt || ((a2) => (s3 || (s3 = oc(t)), s3(c6, a2))), invertBatch: (a2) => ac(c6, a2), cmov: (a2, u3, l6) => l6 ? u3 : a2, toBytes: (a2) => n4 ? be(a2, i5) : Mt(a2, i5), fromBytes: (a2) => {
    if (a2.length !== i5) throw new Error("Field.fromBytes: expected " + i5 + " bytes, got " + a2.length);
    return n4 ? ee(a2) : Ot(a2);
  } });
  return Object.freeze(c6);
}
function Fr(t) {
  if (typeof t != "bigint") throw new Error("field order must be bigint");
  const e = t.toString(2).length;
  return Math.ceil(e / 8);
}
function zr(t) {
  const e = Fr(t);
  return e + Math.ceil(e / 2);
}
function uc(t, e, n4 = false) {
  const r2 = t.length, o2 = Fr(e), i5 = zr(e);
  if (r2 < 16 || r2 < i5 || r2 > 1024) throw new Error("expected " + i5 + "-1024 bytes of input, got " + r2);
  const s3 = n4 ? ee(t) : Ot(t), c6 = X(s3, e - H) + H;
  return n4 ? be(c6, o2) : Mt(c6, o2);
}
var Zr = BigInt(0);
var ve = BigInt(1);
function rn(t, e) {
  const n4 = e.negate();
  return t ? n4 : e;
}
function Yr(t, e) {
  if (!Number.isSafeInteger(t) || t <= 0 || t > e) throw new Error("invalid window size, expected [1.." + e + "], got W=" + t);
}
function on(t, e) {
  Yr(t, e);
  const n4 = Math.ceil(e / t) + 1, r2 = 2 ** (t - 1);
  return { windows: n4, windowSize: r2 };
}
function fc(t, e) {
  if (!Array.isArray(t)) throw new Error("array expected");
  t.forEach((n4, r2) => {
    if (!(n4 instanceof e)) throw new Error("invalid point at index " + r2);
  });
}
function lc(t, e) {
  if (!Array.isArray(t)) throw new Error("array of scalars expected");
  t.forEach((n4, r2) => {
    if (!e.isValid(n4)) throw new Error("invalid scalar at index " + r2);
  });
}
var sn2 = /* @__PURE__ */ new WeakMap();
var Gr = /* @__PURE__ */ new WeakMap();
function cn(t) {
  return Gr.get(t) || 1;
}
function dc(t, e) {
  return { constTimeNegate: rn, hasPrecomputes(n4) {
    return cn(n4) !== 1;
  }, unsafeLadder(n4, r2, o2 = t.ZERO) {
    let i5 = n4;
    for (; r2 > Zr; ) r2 & ve && (o2 = o2.add(i5)), i5 = i5.double(), r2 >>= ve;
    return o2;
  }, precomputeWindow(n4, r2) {
    const { windows: o2, windowSize: i5 } = on(r2, e), s3 = [];
    let c6 = n4, a2 = c6;
    for (let u3 = 0; u3 < o2; u3++) {
      a2 = c6, s3.push(a2);
      for (let l6 = 1; l6 < i5; l6++) a2 = a2.add(c6), s3.push(a2);
      c6 = a2.double();
    }
    return s3;
  }, wNAF(n4, r2, o2) {
    const { windows: i5, windowSize: s3 } = on(n4, e);
    let c6 = t.ZERO, a2 = t.BASE;
    const u3 = BigInt(2 ** n4 - 1), l6 = 2 ** n4, f9 = BigInt(n4);
    for (let h6 = 0; h6 < i5; h6++) {
      const y7 = h6 * s3;
      let E8 = Number(o2 & u3);
      o2 >>= f9, E8 > s3 && (E8 -= l6, o2 += ve);
      const p6 = y7, d4 = y7 + Math.abs(E8) - 1, v7 = h6 % 2 !== 0, m3 = E8 < 0;
      E8 === 0 ? a2 = a2.add(rn(v7, r2[p6])) : c6 = c6.add(rn(m3, r2[d4]));
    }
    return { p: c6, f: a2 };
  }, wNAFUnsafe(n4, r2, o2, i5 = t.ZERO) {
    const { windows: s3, windowSize: c6 } = on(n4, e), a2 = BigInt(2 ** n4 - 1), u3 = 2 ** n4, l6 = BigInt(n4);
    for (let f9 = 0; f9 < s3; f9++) {
      const h6 = f9 * c6;
      if (o2 === Zr) break;
      let y7 = Number(o2 & a2);
      if (o2 >>= l6, y7 > c6 && (y7 -= u3, o2 += ve), y7 === 0) continue;
      let E8 = r2[h6 + Math.abs(y7) - 1];
      y7 < 0 && (E8 = E8.negate()), i5 = i5.add(E8);
    }
    return i5;
  }, getPrecomputes(n4, r2, o2) {
    let i5 = sn2.get(r2);
    return i5 || (i5 = this.precomputeWindow(r2, n4), n4 !== 1 && sn2.set(r2, o2(i5))), i5;
  }, wNAFCached(n4, r2, o2) {
    const i5 = cn(n4);
    return this.wNAF(i5, this.getPrecomputes(i5, n4, o2), r2);
  }, wNAFCachedUnsafe(n4, r2, o2, i5) {
    const s3 = cn(n4);
    return s3 === 1 ? this.unsafeLadder(n4, r2, i5) : this.wNAFUnsafe(s3, this.getPrecomputes(s3, n4, o2), r2, i5);
  }, setWindowSize(n4, r2) {
    Yr(r2, e), Gr.set(n4, r2), sn2.delete(n4);
  } };
}
function hc(t, e, n4, r2) {
  if (fc(n4, t), lc(r2, e), n4.length !== r2.length) throw new Error("arrays of points and scalars must have equal length");
  const o2 = t.ZERO, i5 = Pr(BigInt(n4.length)), s3 = i5 > 12 ? i5 - 3 : i5 > 4 ? i5 - 2 : i5 ? 2 : 1, c6 = (1 << s3) - 1, a2 = new Array(c6 + 1).fill(o2), u3 = Math.floor((e.BITS - 1) / s3) * s3;
  let l6 = o2;
  for (let f9 = u3; f9 >= 0; f9 -= s3) {
    a2.fill(o2);
    for (let y7 = 0; y7 < r2.length; y7++) {
      const E8 = r2[y7], p6 = Number(E8 >> BigInt(f9) & BigInt(c6));
      a2[p6] = a2[p6].add(n4[y7]);
    }
    let h6 = o2;
    for (let y7 = a2.length - 1, E8 = o2; y7 > 0; y7--) E8 = E8.add(a2[y7]), h6 = h6.add(E8);
    if (l6 = l6.add(h6), f9 !== 0) for (let y7 = 0; y7 < s3; y7++) l6 = l6.double();
  }
  return l6;
}
function Wr(t) {
  return sc(t.Fp), Dt(t, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...qr(t.n, t.nBitLength), ...t, p: t.Fp.ORDER });
}
BigInt(0), BigInt(1), BigInt(2), BigInt(8);
var Ht = BigInt(0);
var an = BigInt(1);
function pc(t) {
  return Dt(t, { a: "bigint" }, { montgomeryBits: "isSafeInteger", nByteLength: "isSafeInteger", adjustScalarBytes: "function", domain: "function", powPminus2: "function", Gu: "bigint" }), Object.freeze({ ...t });
}
function gc(t) {
  const e = pc(t), { P: n4 } = e, r2 = (m3) => X(m3, n4), o2 = e.montgomeryBits, i5 = Math.ceil(o2 / 8), s3 = e.nByteLength, c6 = e.adjustScalarBytes || ((m3) => m3), a2 = e.powPminus2 || ((m3) => Hr(m3, n4 - BigInt(2), n4));
  function u3(m3, O6, N4) {
    const $5 = r2(m3 * (O6 - N4));
    return O6 = r2(O6 - $5), N4 = r2(N4 + $5), [O6, N4];
  }
  const l6 = (e.a - BigInt(2)) / BigInt(4);
  function f9(m3, O6) {
    ft("u", m3, Ht, n4), ft("scalar", O6, Ht, n4);
    const N4 = O6, $5 = m3;
    let B5 = an, A5 = Ht, T5 = m3, S7 = an, L5 = Ht, U7;
    for (let j4 = BigInt(o2 - 1); j4 >= Ht; j4--) {
      const g3 = N4 >> j4 & an;
      L5 ^= g3, U7 = u3(L5, B5, T5), B5 = U7[0], T5 = U7[1], U7 = u3(L5, A5, S7), A5 = U7[0], S7 = U7[1], L5 = g3;
      const w5 = B5 + A5, b7 = r2(w5 * w5), I5 = B5 - A5, R5 = r2(I5 * I5), x5 = b7 - R5, C7 = T5 + S7, P4 = T5 - S7, k9 = r2(P4 * w5), M5 = r2(C7 * I5), D4 = k9 + M5, z6 = k9 - M5;
      T5 = r2(D4 * D4), S7 = r2($5 * r2(z6 * z6)), B5 = r2(b7 * R5), A5 = r2(x5 * (b7 + r2(l6 * x5)));
    }
    U7 = u3(L5, B5, T5), B5 = U7[0], T5 = U7[1], U7 = u3(L5, A5, S7), A5 = U7[0], S7 = U7[1];
    const _5 = a2(A5);
    return r2(B5 * _5);
  }
  function h6(m3) {
    return be(r2(m3), i5);
  }
  function y7(m3) {
    const O6 = et("u coordinate", m3, i5);
    return s3 === 32 && (O6[31] &= 127), ee(O6);
  }
  function E8(m3) {
    const O6 = et("scalar", m3), N4 = O6.length;
    if (N4 !== i5 && N4 !== s3) {
      let $5 = "" + i5 + " or " + s3;
      throw new Error("invalid scalar, expected " + $5 + " bytes, got " + N4);
    }
    return ee(c6(O6));
  }
  function p6(m3, O6) {
    const N4 = y7(O6), $5 = E8(m3), B5 = f9(N4, $5);
    if (B5 === Ht) throw new Error("invalid private or public key received");
    return h6(B5);
  }
  const d4 = h6(e.Gu);
  function v7(m3) {
    return p6(m3, d4);
  }
  return { scalarMult: p6, scalarMultBase: v7, getSharedSecret: (m3, O6) => p6(m3, O6), getPublicKey: (m3) => v7(m3), utils: { randomPrivateKey: () => e.randomBytes(e.nByteLength) }, GuBytes: d4 };
}
var un = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
BigInt(0);
var yc = BigInt(1);
var Xr = BigInt(2);
var mc = BigInt(3);
var wc = BigInt(5);
BigInt(8);
function bc(t) {
  const e = BigInt(10), n4 = BigInt(20), r2 = BigInt(40), o2 = BigInt(80), i5 = un, c6 = t * t % i5 * t % i5, a2 = it(c6, Xr, i5) * c6 % i5, u3 = it(a2, yc, i5) * t % i5, l6 = it(u3, wc, i5) * u3 % i5, f9 = it(l6, e, i5) * l6 % i5, h6 = it(f9, n4, i5) * f9 % i5, y7 = it(h6, r2, i5) * h6 % i5, E8 = it(y7, o2, i5) * y7 % i5, p6 = it(E8, o2, i5) * y7 % i5, d4 = it(p6, e, i5) * l6 % i5;
  return { pow_p_5_8: it(d4, Xr, i5) * t % i5, b2: c6 };
}
function Ec(t) {
  return t[0] &= 248, t[31] &= 127, t[31] |= 64, t;
}
var fn = gc({ P: un, a: BigInt(486662), montgomeryBits: 255, nByteLength: 32, Gu: BigInt(9), powPminus2: (t) => {
  const e = un, { pow_p_5_8: n4, b2: r2 } = bc(t);
  return X(it(n4, mc, e) * r2, e);
}, adjustScalarBytes: Ec, randomBytes: Lt });
function Jr(t) {
  t.lowS !== void 0 && Ct("lowS", t.lowS), t.prehash !== void 0 && Ct("prehash", t.prehash);
}
function vc(t) {
  const e = Wr(t);
  Dt(e, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
  const { endo: n4, Fp: r2, a: o2 } = e;
  if (n4) {
    if (!r2.eql(o2, r2.ZERO)) throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
    if (typeof n4 != "object" || typeof n4.beta != "bigint" || typeof n4.splitScalar != "function") throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...e });
}
var { bytesToNumberBE: xc, hexToBytes: Sc } = ec;
var Oc = class extends Error {
  constructor(e = "") {
    super(e);
  }
};
var lt = { Err: Oc, _tlv: { encode: (t, e) => {
  const { Err: n4 } = lt;
  if (t < 0 || t > 256) throw new n4("tlv.encode: wrong tag");
  if (e.length & 1) throw new n4("tlv.encode: unpadded data");
  const r2 = e.length / 2, o2 = kt(r2);
  if (o2.length / 2 & 128) throw new n4("tlv.encode: long form length too big");
  const i5 = r2 > 127 ? kt(o2.length / 2 | 128) : "";
  return kt(t) + i5 + o2 + e;
}, decode(t, e) {
  const { Err: n4 } = lt;
  let r2 = 0;
  if (t < 0 || t > 256) throw new n4("tlv.encode: wrong tag");
  if (e.length < 2 || e[r2++] !== t) throw new n4("tlv.decode: wrong tlv");
  const o2 = e[r2++], i5 = !!(o2 & 128);
  let s3 = 0;
  if (!i5) s3 = o2;
  else {
    const a2 = o2 & 127;
    if (!a2) throw new n4("tlv.decode(long): indefinite length not supported");
    if (a2 > 4) throw new n4("tlv.decode(long): byte length is too big");
    const u3 = e.subarray(r2, r2 + a2);
    if (u3.length !== a2) throw new n4("tlv.decode: length bytes not complete");
    if (u3[0] === 0) throw new n4("tlv.decode(long): zero leftmost byte");
    for (const l6 of u3) s3 = s3 << 8 | l6;
    if (r2 += a2, s3 < 128) throw new n4("tlv.decode(long): not minimal encoding");
  }
  const c6 = e.subarray(r2, r2 + s3);
  if (c6.length !== s3) throw new n4("tlv.decode: wrong value length");
  return { v: c6, l: e.subarray(r2 + s3) };
} }, _int: { encode(t) {
  const { Err: e } = lt;
  if (t < dt) throw new e("integer: negative integers are not allowed");
  let n4 = kt(t);
  if (Number.parseInt(n4[0], 16) & 8 && (n4 = "00" + n4), n4.length & 1) throw new e("unexpected DER parsing assertion: unpadded hex");
  return n4;
}, decode(t) {
  const { Err: e } = lt;
  if (t[0] & 128) throw new e("invalid signature integer: negative");
  if (t[0] === 0 && !(t[1] & 128)) throw new e("invalid signature integer: unnecessary leading zero");
  return xc(t);
} }, toSig(t) {
  const { Err: e, _int: n4, _tlv: r2 } = lt, o2 = typeof t == "string" ? Sc(t) : t;
  te(o2);
  const { v: i5, l: s3 } = r2.decode(48, o2);
  if (s3.length) throw new e("invalid signature: left bytes after parsing");
  const { v: c6, l: a2 } = r2.decode(2, i5), { v: u3, l: l6 } = r2.decode(2, a2);
  if (l6.length) throw new e("invalid signature: left bytes after parsing");
  return { r: n4.decode(c6), s: n4.decode(u3) };
}, hexFromSig(t) {
  const { _tlv: e, _int: n4 } = lt, r2 = e.encode(2, n4.encode(t.r)), o2 = e.encode(2, n4.encode(t.s)), i5 = r2 + o2;
  return e.encode(48, i5);
} };
var dt = BigInt(0);
var K = BigInt(1);
BigInt(2);
var Qr = BigInt(3);
BigInt(4);
function Ac(t) {
  const e = vc(t), { Fp: n4 } = e, r2 = Kr2(e.n, e.nBitLength), o2 = e.toBytes || ((p6, d4, v7) => {
    const m3 = d4.toAffine();
    return ne(Uint8Array.from([4]), n4.toBytes(m3.x), n4.toBytes(m3.y));
  }), i5 = e.fromBytes || ((p6) => {
    const d4 = p6.subarray(1), v7 = n4.fromBytes(d4.subarray(0, n4.BYTES)), m3 = n4.fromBytes(d4.subarray(n4.BYTES, 2 * n4.BYTES));
    return { x: v7, y: m3 };
  });
  function s3(p6) {
    const { a: d4, b: v7 } = e, m3 = n4.sqr(p6), O6 = n4.mul(m3, p6);
    return n4.add(n4.add(O6, n4.mul(p6, d4)), v7);
  }
  if (!n4.eql(n4.sqr(e.Gy), s3(e.Gx))) throw new Error("bad generator point: equation left != right");
  function c6(p6) {
    return Ee(p6, K, e.n);
  }
  function a2(p6) {
    const { allowedPrivateKeyLengths: d4, nByteLength: v7, wrapPrivateKey: m3, n: O6 } = e;
    if (d4 && typeof p6 != "bigint") {
      if (St(p6) && (p6 = Pt(p6)), typeof p6 != "string" || !d4.includes(p6.length)) throw new Error("invalid private key");
      p6 = p6.padStart(v7 * 2, "0");
    }
    let N4;
    try {
      N4 = typeof p6 == "bigint" ? p6 : Ot(et("private key", p6, v7));
    } catch {
      throw new Error("invalid private key, expected hex or " + v7 + " bytes, got " + typeof p6);
    }
    return m3 && (N4 = X(N4, O6)), ft("private key", N4, K, O6), N4;
  }
  function u3(p6) {
    if (!(p6 instanceof h6)) throw new Error("ProjectivePoint expected");
  }
  const l6 = tn((p6, d4) => {
    const { px: v7, py: m3, pz: O6 } = p6;
    if (n4.eql(O6, n4.ONE)) return { x: v7, y: m3 };
    const N4 = p6.is0();
    d4 == null && (d4 = N4 ? n4.ONE : n4.inv(O6));
    const $5 = n4.mul(v7, d4), B5 = n4.mul(m3, d4), A5 = n4.mul(O6, d4);
    if (N4) return { x: n4.ZERO, y: n4.ZERO };
    if (!n4.eql(A5, n4.ONE)) throw new Error("invZ was invalid");
    return { x: $5, y: B5 };
  }), f9 = tn((p6) => {
    if (p6.is0()) {
      if (e.allowInfinityPoint && !n4.is0(p6.py)) return;
      throw new Error("bad point: ZERO");
    }
    const { x: d4, y: v7 } = p6.toAffine();
    if (!n4.isValid(d4) || !n4.isValid(v7)) throw new Error("bad point: x or y not FE");
    const m3 = n4.sqr(v7), O6 = s3(d4);
    if (!n4.eql(m3, O6)) throw new Error("bad point: equation left != right");
    if (!p6.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class h6 {
    constructor(d4, v7, m3) {
      if (this.px = d4, this.py = v7, this.pz = m3, d4 == null || !n4.isValid(d4)) throw new Error("x required");
      if (v7 == null || !n4.isValid(v7)) throw new Error("y required");
      if (m3 == null || !n4.isValid(m3)) throw new Error("z required");
      Object.freeze(this);
    }
    static fromAffine(d4) {
      const { x: v7, y: m3 } = d4 || {};
      if (!d4 || !n4.isValid(v7) || !n4.isValid(m3)) throw new Error("invalid affine point");
      if (d4 instanceof h6) throw new Error("projective point not allowed");
      const O6 = (N4) => n4.eql(N4, n4.ZERO);
      return O6(v7) && O6(m3) ? h6.ZERO : new h6(v7, m3, n4.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(d4) {
      const v7 = n4.invertBatch(d4.map((m3) => m3.pz));
      return d4.map((m3, O6) => m3.toAffine(v7[O6])).map(h6.fromAffine);
    }
    static fromHex(d4) {
      const v7 = h6.fromAffine(i5(et("pointHex", d4)));
      return v7.assertValidity(), v7;
    }
    static fromPrivateKey(d4) {
      return h6.BASE.multiply(a2(d4));
    }
    static msm(d4, v7) {
      return hc(h6, r2, d4, v7);
    }
    _setWindowSize(d4) {
      E8.setWindowSize(this, d4);
    }
    assertValidity() {
      f9(this);
    }
    hasEvenY() {
      const { y: d4 } = this.toAffine();
      if (n4.isOdd) return !n4.isOdd(d4);
      throw new Error("Field doesn't support isOdd");
    }
    equals(d4) {
      u3(d4);
      const { px: v7, py: m3, pz: O6 } = this, { px: N4, py: $5, pz: B5 } = d4, A5 = n4.eql(n4.mul(v7, B5), n4.mul(N4, O6)), T5 = n4.eql(n4.mul(m3, B5), n4.mul($5, O6));
      return A5 && T5;
    }
    negate() {
      return new h6(this.px, n4.neg(this.py), this.pz);
    }
    double() {
      const { a: d4, b: v7 } = e, m3 = n4.mul(v7, Qr), { px: O6, py: N4, pz: $5 } = this;
      let B5 = n4.ZERO, A5 = n4.ZERO, T5 = n4.ZERO, S7 = n4.mul(O6, O6), L5 = n4.mul(N4, N4), U7 = n4.mul($5, $5), _5 = n4.mul(O6, N4);
      return _5 = n4.add(_5, _5), T5 = n4.mul(O6, $5), T5 = n4.add(T5, T5), B5 = n4.mul(d4, T5), A5 = n4.mul(m3, U7), A5 = n4.add(B5, A5), B5 = n4.sub(L5, A5), A5 = n4.add(L5, A5), A5 = n4.mul(B5, A5), B5 = n4.mul(_5, B5), T5 = n4.mul(m3, T5), U7 = n4.mul(d4, U7), _5 = n4.sub(S7, U7), _5 = n4.mul(d4, _5), _5 = n4.add(_5, T5), T5 = n4.add(S7, S7), S7 = n4.add(T5, S7), S7 = n4.add(S7, U7), S7 = n4.mul(S7, _5), A5 = n4.add(A5, S7), U7 = n4.mul(N4, $5), U7 = n4.add(U7, U7), S7 = n4.mul(U7, _5), B5 = n4.sub(B5, S7), T5 = n4.mul(U7, L5), T5 = n4.add(T5, T5), T5 = n4.add(T5, T5), new h6(B5, A5, T5);
    }
    add(d4) {
      u3(d4);
      const { px: v7, py: m3, pz: O6 } = this, { px: N4, py: $5, pz: B5 } = d4;
      let A5 = n4.ZERO, T5 = n4.ZERO, S7 = n4.ZERO;
      const L5 = e.a, U7 = n4.mul(e.b, Qr);
      let _5 = n4.mul(v7, N4), j4 = n4.mul(m3, $5), g3 = n4.mul(O6, B5), w5 = n4.add(v7, m3), b7 = n4.add(N4, $5);
      w5 = n4.mul(w5, b7), b7 = n4.add(_5, j4), w5 = n4.sub(w5, b7), b7 = n4.add(v7, O6);
      let I5 = n4.add(N4, B5);
      return b7 = n4.mul(b7, I5), I5 = n4.add(_5, g3), b7 = n4.sub(b7, I5), I5 = n4.add(m3, O6), A5 = n4.add($5, B5), I5 = n4.mul(I5, A5), A5 = n4.add(j4, g3), I5 = n4.sub(I5, A5), S7 = n4.mul(L5, b7), A5 = n4.mul(U7, g3), S7 = n4.add(A5, S7), A5 = n4.sub(j4, S7), S7 = n4.add(j4, S7), T5 = n4.mul(A5, S7), j4 = n4.add(_5, _5), j4 = n4.add(j4, _5), g3 = n4.mul(L5, g3), b7 = n4.mul(U7, b7), j4 = n4.add(j4, g3), g3 = n4.sub(_5, g3), g3 = n4.mul(L5, g3), b7 = n4.add(b7, g3), _5 = n4.mul(j4, b7), T5 = n4.add(T5, _5), _5 = n4.mul(I5, b7), A5 = n4.mul(w5, A5), A5 = n4.sub(A5, _5), _5 = n4.mul(w5, j4), S7 = n4.mul(I5, S7), S7 = n4.add(S7, _5), new h6(A5, T5, S7);
    }
    subtract(d4) {
      return this.add(d4.negate());
    }
    is0() {
      return this.equals(h6.ZERO);
    }
    wNAF(d4) {
      return E8.wNAFCached(this, d4, h6.normalizeZ);
    }
    multiplyUnsafe(d4) {
      const { endo: v7, n: m3 } = e;
      ft("scalar", d4, dt, m3);
      const O6 = h6.ZERO;
      if (d4 === dt) return O6;
      if (this.is0() || d4 === K) return this;
      if (!v7 || E8.hasPrecomputes(this)) return E8.wNAFCachedUnsafe(this, d4, h6.normalizeZ);
      let { k1neg: N4, k1: $5, k2neg: B5, k2: A5 } = v7.splitScalar(d4), T5 = O6, S7 = O6, L5 = this;
      for (; $5 > dt || A5 > dt; ) $5 & K && (T5 = T5.add(L5)), A5 & K && (S7 = S7.add(L5)), L5 = L5.double(), $5 >>= K, A5 >>= K;
      return N4 && (T5 = T5.negate()), B5 && (S7 = S7.negate()), S7 = new h6(n4.mul(S7.px, v7.beta), S7.py, S7.pz), T5.add(S7);
    }
    multiply(d4) {
      const { endo: v7, n: m3 } = e;
      ft("scalar", d4, K, m3);
      let O6, N4;
      if (v7) {
        const { k1neg: $5, k1: B5, k2neg: A5, k2: T5 } = v7.splitScalar(d4);
        let { p: S7, f: L5 } = this.wNAF(B5), { p: U7, f: _5 } = this.wNAF(T5);
        S7 = E8.constTimeNegate($5, S7), U7 = E8.constTimeNegate(A5, U7), U7 = new h6(n4.mul(U7.px, v7.beta), U7.py, U7.pz), O6 = S7.add(U7), N4 = L5.add(_5);
      } else {
        const { p: $5, f: B5 } = this.wNAF(d4);
        O6 = $5, N4 = B5;
      }
      return h6.normalizeZ([O6, N4])[0];
    }
    multiplyAndAddUnsafe(d4, v7, m3) {
      const O6 = h6.BASE, N4 = (B5, A5) => A5 === dt || A5 === K || !B5.equals(O6) ? B5.multiplyUnsafe(A5) : B5.multiply(A5), $5 = N4(this, v7).add(N4(d4, m3));
      return $5.is0() ? void 0 : $5;
    }
    toAffine(d4) {
      return l6(this, d4);
    }
    isTorsionFree() {
      const { h: d4, isTorsionFree: v7 } = e;
      if (d4 === K) return true;
      if (v7) return v7(h6, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: d4, clearCofactor: v7 } = e;
      return d4 === K ? this : v7 ? v7(h6, this) : this.multiplyUnsafe(e.h);
    }
    toRawBytes(d4 = true) {
      return Ct("isCompressed", d4), this.assertValidity(), o2(h6, this, d4);
    }
    toHex(d4 = true) {
      return Ct("isCompressed", d4), Pt(this.toRawBytes(d4));
    }
  }
  h6.BASE = new h6(e.Gx, e.Gy, n4.ONE), h6.ZERO = new h6(n4.ZERO, n4.ONE, n4.ZERO);
  const y7 = e.nBitLength, E8 = dc(h6, e.endo ? Math.ceil(y7 / 2) : y7);
  return { CURVE: e, ProjectivePoint: h6, normPrivateKeyToScalar: a2, weierstrassEquation: s3, isWithinCurveOrder: c6 };
}
function Bc(t) {
  const e = Wr(t);
  return Dt(e, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...e });
}
function Ic(t) {
  const e = Bc(t), { Fp: n4, n: r2 } = e, o2 = n4.BYTES + 1, i5 = 2 * n4.BYTES + 1;
  function s3(g3) {
    return X(g3, r2);
  }
  function c6(g3) {
    return nn(g3, r2);
  }
  const { ProjectivePoint: a2, normPrivateKeyToScalar: u3, weierstrassEquation: l6, isWithinCurveOrder: f9 } = Ac({ ...e, toBytes(g3, w5, b7) {
    const I5 = w5.toAffine(), R5 = n4.toBytes(I5.x), x5 = ne;
    return Ct("isCompressed", b7), b7 ? x5(Uint8Array.from([w5.hasEvenY() ? 2 : 3]), R5) : x5(Uint8Array.from([4]), R5, n4.toBytes(I5.y));
  }, fromBytes(g3) {
    const w5 = g3.length, b7 = g3[0], I5 = g3.subarray(1);
    if (w5 === o2 && (b7 === 2 || b7 === 3)) {
      const R5 = Ot(I5);
      if (!Ee(R5, K, n4.ORDER)) throw new Error("Point is not on curve");
      const x5 = l6(R5);
      let C7;
      try {
        C7 = n4.sqrt(x5);
      } catch (M5) {
        const D4 = M5 instanceof Error ? ": " + M5.message : "";
        throw new Error("Point is not on curve" + D4);
      }
      const P4 = (C7 & K) === K;
      return (b7 & 1) === 1 !== P4 && (C7 = n4.neg(C7)), { x: R5, y: C7 };
    } else if (w5 === i5 && b7 === 4) {
      const R5 = n4.fromBytes(I5.subarray(0, n4.BYTES)), x5 = n4.fromBytes(I5.subarray(n4.BYTES, 2 * n4.BYTES));
      return { x: R5, y: x5 };
    } else {
      const R5 = o2, x5 = i5;
      throw new Error("invalid Point, expected length of " + R5 + ", or uncompressed " + x5 + ", got " + w5);
    }
  } }), h6 = (g3) => Pt(Mt(g3, e.nByteLength));
  function y7(g3) {
    const w5 = r2 >> K;
    return g3 > w5;
  }
  function E8(g3) {
    return y7(g3) ? s3(-g3) : g3;
  }
  const p6 = (g3, w5, b7) => Ot(g3.slice(w5, b7));
  class d4 {
    constructor(w5, b7, I5) {
      this.r = w5, this.s = b7, this.recovery = I5, this.assertValidity();
    }
    static fromCompact(w5) {
      const b7 = e.nByteLength;
      return w5 = et("compactSignature", w5, b7 * 2), new d4(p6(w5, 0, b7), p6(w5, b7, 2 * b7));
    }
    static fromDER(w5) {
      const { r: b7, s: I5 } = lt.toSig(et("DER", w5));
      return new d4(b7, I5);
    }
    assertValidity() {
      ft("r", this.r, K, r2), ft("s", this.s, K, r2);
    }
    addRecoveryBit(w5) {
      return new d4(this.r, this.s, w5);
    }
    recoverPublicKey(w5) {
      const { r: b7, s: I5, recovery: R5 } = this, x5 = B5(et("msgHash", w5));
      if (R5 == null || ![0, 1, 2, 3].includes(R5)) throw new Error("recovery id invalid");
      const C7 = R5 === 2 || R5 === 3 ? b7 + e.n : b7;
      if (C7 >= n4.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const P4 = (R5 & 1) === 0 ? "02" : "03", k9 = a2.fromHex(P4 + h6(C7)), M5 = c6(C7), D4 = s3(-x5 * M5), z6 = s3(I5 * M5), Z3 = a2.BASE.multiplyAndAddUnsafe(k9, D4, z6);
      if (!Z3) throw new Error("point at infinify");
      return Z3.assertValidity(), Z3;
    }
    hasHighS() {
      return y7(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new d4(this.r, s3(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return Vt(this.toDERHex());
    }
    toDERHex() {
      return lt.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return Vt(this.toCompactHex());
    }
    toCompactHex() {
      return h6(this.r) + h6(this.s);
    }
  }
  const v7 = { isValidPrivateKey(g3) {
    try {
      return u3(g3), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: u3, randomPrivateKey: () => {
    const g3 = zr(e.n);
    return uc(e.randomBytes(g3), e.n);
  }, precompute(g3 = 8, w5 = a2.BASE) {
    return w5._setWindowSize(g3), w5.multiply(BigInt(3)), w5;
  } };
  function m3(g3, w5 = true) {
    return a2.fromPrivateKey(g3).toRawBytes(w5);
  }
  function O6(g3) {
    const w5 = St(g3), b7 = typeof g3 == "string", I5 = (w5 || b7) && g3.length;
    return w5 ? I5 === o2 || I5 === i5 : b7 ? I5 === 2 * o2 || I5 === 2 * i5 : g3 instanceof a2;
  }
  function N4(g3, w5, b7 = true) {
    if (O6(g3)) throw new Error("first arg must be private key");
    if (!O6(w5)) throw new Error("second arg must be public key");
    return a2.fromHex(w5).multiply(u3(g3)).toRawBytes(b7);
  }
  const $5 = e.bits2int || function(g3) {
    if (g3.length > 8192) throw new Error("input is too large");
    const w5 = Ot(g3), b7 = g3.length * 8 - e.nBitLength;
    return b7 > 0 ? w5 >> BigInt(b7) : w5;
  }, B5 = e.bits2int_modN || function(g3) {
    return s3($5(g3));
  }, A5 = Je(e.nBitLength);
  function T5(g3) {
    return ft("num < 2^" + e.nBitLength, g3, dt, A5), Mt(g3, e.nByteLength);
  }
  function S7(g3, w5, b7 = L5) {
    if (["recovered", "canonical"].some((W4) => W4 in b7)) throw new Error("sign() legacy options not supported");
    const { hash: I5, randomBytes: R5 } = e;
    let { lowS: x5, prehash: C7, extraEntropy: P4 } = b7;
    x5 == null && (x5 = true), g3 = et("msgHash", g3), Jr(b7), C7 && (g3 = et("prehashed msgHash", I5(g3)));
    const k9 = B5(g3), M5 = u3(w5), D4 = [T5(M5), T5(k9)];
    if (P4 != null && P4 !== false) {
      const W4 = P4 === true ? R5(n4.BYTES) : P4;
      D4.push(et("extraEntropy", W4));
    }
    const z6 = ne(...D4), Z3 = k9;
    function st3(W4) {
      const J4 = $5(W4);
      if (!f9(J4)) return;
      const Be4 = c6(J4), zt3 = a2.BASE.multiply(J4).toAffine(), vt2 = s3(zt3.x);
      if (vt2 === dt) return;
      const Zt3 = s3(Be4 * s3(Z3 + vt2 * M5));
      if (Zt3 === dt) return;
      let Ut3 = (zt3.x === vt2 ? 0 : 2) | Number(zt3.y & K), vn2 = Zt3;
      return x5 && y7(Zt3) && (vn2 = E8(Zt3), Ut3 ^= 1), new d4(vt2, vn2, Ut3);
    }
    return { seed: z6, k2sig: st3 };
  }
  const L5 = { lowS: e.lowS, prehash: false }, U7 = { lowS: e.lowS, prehash: false };
  function _5(g3, w5, b7 = L5) {
    const { seed: I5, k2sig: R5 } = S7(g3, w5, b7), x5 = e;
    return Vr(x5.hash.outputLen, x5.nByteLength, x5.hmac)(I5, R5);
  }
  a2.BASE._setWindowSize(8);
  function j4(g3, w5, b7, I5 = U7) {
    var _a;
    const R5 = g3;
    w5 = et("msgHash", w5), b7 = et("publicKey", b7);
    const { lowS: x5, prehash: C7, format: P4 } = I5;
    if (Jr(I5), "strict" in I5) throw new Error("options.strict was renamed to lowS");
    if (P4 !== void 0 && P4 !== "compact" && P4 !== "der") throw new Error("format must be compact or der");
    const k9 = typeof R5 == "string" || St(R5), M5 = !k9 && !P4 && typeof R5 == "object" && R5 !== null && typeof R5.r == "bigint" && typeof R5.s == "bigint";
    if (!k9 && !M5) throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
    let D4, z6;
    try {
      if (M5 && (D4 = new d4(R5.r, R5.s)), k9) {
        try {
          P4 !== "compact" && (D4 = d4.fromDER(R5));
        } catch (Ut3) {
          if (!(Ut3 instanceof lt.Err)) throw Ut3;
        }
        !D4 && P4 !== "der" && (D4 = d4.fromCompact(R5));
      }
      z6 = a2.fromHex(b7);
    } catch {
      return false;
    }
    if (!D4 || x5 && D4.hasHighS()) return false;
    C7 && (w5 = e.hash(w5));
    const { r: Z3, s: st3 } = D4, W4 = B5(w5), J4 = c6(st3), Be4 = s3(W4 * J4), zt3 = s3(Z3 * J4), vt2 = (_a = a2.BASE.multiplyAndAddUnsafe(z6, Be4, zt3)) == null ? void 0 : _a.toAffine();
    return vt2 ? s3(vt2.x) === Z3 : false;
  }
  return { CURVE: e, getPublicKey: m3, getSharedSecret: N4, sign: _5, verify: j4, ProjectivePoint: a2, Signature: d4, utils: v7 };
}
function Nc(t) {
  return { hash: t, hmac: (e, ...n4) => ye(t, e, Vi(...n4)), randomBytes: Lt };
}
function Uc(t, e) {
  const n4 = (r2) => Ic({ ...t, ...Nc(r2) });
  return { ...n4(e), create: n4 };
}
var to = Kr2(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var Tc = to.create(BigInt("-3"));
var Rc = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var _c = Uc({ a: Tc, b: Rc, Fp: to, n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"), Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"), Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"), h: BigInt(1), lowS: false }, Qt);
var ln = "base10";
var G = "base16";
var qt = "base64pad";
var xe = "base64url";
var Kt = "utf8";
var dn = 0;
var Ft = 1;
var re = 2;
var $c = 0;
var eo = 1;
var oe = 12;
var hn = 32;
function Lc() {
  const t = fn.utils.randomPrivateKey(), e = fn.getPublicKey(t);
  return { privateKey: toString(t, G), publicKey: toString(e, G) };
}
function jc() {
  const t = Lt(hn);
  return toString(t, G);
}
function Cc(t, e) {
  const n4 = fn.getSharedSecret(fromString(t, G), fromString(e, G)), r2 = Vs(Qt, n4, void 0, void 0, hn);
  return toString(r2, G);
}
function Pc(t) {
  const e = Qt(fromString(t, G));
  return toString(e, G);
}
function kc(t) {
  const e = Qt(fromString(t, Kt));
  return toString(e, G);
}
function pn(t) {
  return fromString(`${t}`, ln);
}
function Bt(t) {
  return Number(toString(t, ln));
}
function no(t) {
  return t.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function ro(t) {
  const e = t.replace(/-/g, "+").replace(/_/g, "/"), n4 = (4 - e.length % 4) % 4;
  return e + "=".repeat(n4);
}
function Vc(t) {
  const e = pn(typeof t.type < "u" ? t.type : dn);
  if (Bt(e) === Ft && typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
  const n4 = typeof t.senderPublicKey < "u" ? fromString(t.senderPublicKey, G) : void 0, r2 = typeof t.iv < "u" ? fromString(t.iv, G) : Lt(oe), o2 = fromString(t.symKey, G), i5 = $r(o2, r2).encrypt(fromString(t.message, Kt)), s3 = gn({ type: e, sealed: i5, iv: r2, senderPublicKey: n4 });
  return t.encoding === xe ? no(s3) : s3;
}
function Mc(t) {
  const e = fromString(t.symKey, G), { sealed: n4, iv: r2 } = Se({ encoded: t.encoded, encoding: t.encoding }), o2 = $r(e, r2).decrypt(n4);
  if (o2 === null) throw new Error("Failed to decrypt");
  return toString(o2, Kt);
}
function Dc(t, e) {
  const n4 = pn(re), r2 = Lt(oe), o2 = fromString(t, Kt), i5 = gn({ type: n4, sealed: o2, iv: r2 });
  return e === xe ? no(i5) : i5;
}
function Hc(t, e) {
  const { sealed: n4 } = Se({ encoded: t, encoding: e });
  return toString(n4, Kt);
}
function gn(t) {
  if (Bt(t.type) === re) return toString(concat([t.type, t.sealed]), qt);
  if (Bt(t.type) === Ft) {
    if (typeof t.senderPublicKey > "u") throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([t.type, t.senderPublicKey, t.iv, t.sealed]), qt);
  }
  return toString(concat([t.type, t.iv, t.sealed]), qt);
}
function Se(t) {
  const e = (t.encoding || qt) === xe ? ro(t.encoded) : t.encoded, n4 = fromString(e, qt), r2 = n4.slice($c, eo), o2 = eo;
  if (Bt(r2) === Ft) {
    const a2 = o2 + hn, u3 = a2 + oe, l6 = n4.slice(o2, a2), f9 = n4.slice(a2, u3), h6 = n4.slice(u3);
    return { type: r2, sealed: h6, iv: f9, senderPublicKey: l6 };
  }
  if (Bt(r2) === re) {
    const a2 = n4.slice(o2), u3 = Lt(oe);
    return { type: r2, sealed: a2, iv: u3 };
  }
  const i5 = o2 + oe, s3 = n4.slice(o2, i5), c6 = n4.slice(i5);
  return { type: r2, sealed: c6, iv: s3 };
}
function qc(t, e) {
  const n4 = Se({ encoded: t, encoding: e == null ? void 0 : e.encoding });
  return oo({ type: Bt(n4.type), senderPublicKey: typeof n4.senderPublicKey < "u" ? toString(n4.senderPublicKey, G) : void 0, receiverPublicKey: e == null ? void 0 : e.receiverPublicKey });
}
function oo(t) {
  const e = (t == null ? void 0 : t.type) || dn;
  if (e === Ft) {
    if (typeof (t == null ? void 0 : t.senderPublicKey) > "u") throw new Error("missing sender public key");
    if (typeof (t == null ? void 0 : t.receiverPublicKey) > "u") throw new Error("missing receiver public key");
  }
  return { type: e, senderPublicKey: t == null ? void 0 : t.senderPublicKey, receiverPublicKey: t == null ? void 0 : t.receiverPublicKey };
}
function Kc(t) {
  return t.type === Ft && typeof t.senderPublicKey == "string" && typeof t.receiverPublicKey == "string";
}
function Fc(t) {
  return t.type === re;
}
function io(t) {
  const e = Buffer.from(t.x, "base64"), n4 = Buffer.from(t.y, "base64");
  return concat([new Uint8Array([4]), e, n4]);
}
function zc(t, e) {
  const [n4, r2, o2] = t.split("."), i5 = Buffer.from(ro(o2), "base64");
  if (i5.length !== 64) throw new Error("Invalid signature length");
  const s3 = i5.slice(0, 32), c6 = i5.slice(32, 64), a2 = `${n4}.${r2}`, u3 = Qt(a2), l6 = io(e);
  if (!_c.verify(concat([s3, c6]), u3, l6)) throw new Error("Invalid signature");
  return sn(t).payload;
}
var so = "irn";
function Zc(t) {
  return (t == null ? void 0 : t.relay) || { protocol: so };
}
function Yc(t) {
  const e = C[t];
  if (typeof e > "u") throw new Error(`Relay Protocol not supported: ${t}`);
  return e;
}
function co(t, e = "-") {
  const n4 = {}, r2 = "relay" + e;
  return Object.keys(t).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const i5 = o2.replace(r2, ""), s3 = t[o2];
      n4[i5] = s3;
    }
  }), n4;
}
function Gc(t) {
  if (!t.includes("wc:")) {
    const u3 = je(t);
    u3 != null && u3.includes("wc:") && (t = u3);
  }
  t = t.includes("wc://") ? t.replace("wc://", "") : t, t = t.includes("wc:") ? t.replace("wc:", "") : t;
  const e = t.indexOf(":"), n4 = t.indexOf("?") !== -1 ? t.indexOf("?") : void 0, r2 = t.substring(0, e), o2 = t.substring(e + 1, n4).split("@"), i5 = typeof n4 < "u" ? t.substring(n4) : "", s3 = new URLSearchParams(i5), c6 = {};
  s3.forEach((u3, l6) => {
    c6[l6] = u3;
  });
  const a2 = typeof c6.methods == "string" ? c6.methods.split(",") : void 0;
  return { protocol: r2, topic: ao(o2[0]), version: parseInt(o2[1], 10), symKey: c6.symKey, relay: co(c6), methods: a2, expiryTimestamp: c6.expiryTimestamp ? parseInt(c6.expiryTimestamp, 10) : void 0 };
}
function ao(t) {
  return t.startsWith("//") ? t.substring(2) : t;
}
function uo(t, e = "-") {
  const n4 = "relay", r2 = {};
  return Object.keys(t).forEach((o2) => {
    const i5 = o2, s3 = n4 + e + i5;
    t[i5] && (r2[s3] = t[i5]);
  }), r2;
}
function Wc(t) {
  const e = new URLSearchParams(), n4 = uo(t.relay);
  Object.keys(n4).sort().forEach((o2) => {
    e.set(o2, n4[o2]);
  }), e.set("symKey", t.symKey), t.expiryTimestamp && e.set("expiryTimestamp", t.expiryTimestamp.toString()), t.methods && e.set("methods", t.methods.join(","));
  const r2 = e.toString();
  return `${t.protocol}:${t.topic}@${t.version}?${r2}`;
}
function Xc(t, e, n4) {
  return `${t}?wc_ev=${n4}&topic=${e}`;
}
var Jc = Object.defineProperty;
var Qc = Object.defineProperties;
var ta = Object.getOwnPropertyDescriptors;
var fo = Object.getOwnPropertySymbols;
var ea = Object.prototype.hasOwnProperty;
var na = Object.prototype.propertyIsEnumerable;
var lo = (t, e, n4) => e in t ? Jc(t, e, { enumerable: true, configurable: true, writable: true, value: n4 }) : t[e] = n4;
var ra = (t, e) => {
  for (var n4 in e || (e = {})) ea.call(e, n4) && lo(t, n4, e[n4]);
  if (fo) for (var n4 of fo(e)) na.call(e, n4) && lo(t, n4, e[n4]);
  return t;
};
var oa = (t, e) => Qc(t, ta(e));
function It(t) {
  const e = [];
  return t.forEach((n4) => {
    const [r2, o2] = n4.split(":");
    e.push(`${r2}:${o2}`);
  }), e;
}
function ho(t) {
  const e = [];
  return Object.values(t).forEach((n4) => {
    e.push(...It(n4.accounts));
  }), e;
}
function po(t, e) {
  const n4 = [];
  return Object.values(t).forEach((r2) => {
    It(r2.accounts).includes(e) && n4.push(...r2.methods);
  }), n4;
}
function go(t, e) {
  const n4 = [];
  return Object.values(t).forEach((r2) => {
    It(r2.accounts).includes(e) && n4.push(...r2.events);
  }), n4;
}
function yn(t) {
  return t.includes(":");
}
function yo(t) {
  return yn(t) ? t.split(":")[0] : t;
}
function ie(t) {
  var e, n4, r2;
  const o2 = {};
  if (!Oe(t)) return o2;
  for (const [i5, s3] of Object.entries(t)) {
    const c6 = yn(i5) ? [i5] : s3.chains, a2 = s3.methods || [], u3 = s3.events || [], l6 = yo(i5);
    o2[l6] = oa(ra({}, o2[l6]), { chains: ot(c6, (e = o2[l6]) == null ? void 0 : e.chains), methods: ot(a2, (n4 = o2[l6]) == null ? void 0 : n4.methods), events: ot(u3, (r2 = o2[l6]) == null ? void 0 : r2.events) });
  }
  return o2;
}
function mo(t) {
  const e = {};
  return t == null ? void 0 : t.forEach((n4) => {
    var r2;
    const [o2, i5] = n4.split(":");
    e[o2] || (e[o2] = { accounts: [], chains: [], events: [], methods: [] }), e[o2].accounts.push(n4), (r2 = e[o2].chains) == null || r2.push(`${o2}:${i5}`);
  }), e;
}
function ca(t, e) {
  e = e.map((r2) => r2.replace("did:pkh:", ""));
  const n4 = mo(e);
  for (const [r2, o2] of Object.entries(n4)) o2.methods ? o2.methods = ot(o2.methods, t) : o2.methods = t, o2.events = ["chainChanged", "accountsChanged"];
  return n4;
}
function aa(t, e) {
  var n4, r2, o2, i5, s3, c6;
  const a2 = ie(t), u3 = ie(e), l6 = {}, f9 = Object.keys(a2).concat(Object.keys(u3));
  for (const h6 of f9) l6[h6] = { chains: ot((n4 = a2[h6]) == null ? void 0 : n4.chains, (r2 = u3[h6]) == null ? void 0 : r2.chains), methods: ot((o2 = a2[h6]) == null ? void 0 : o2.methods, (i5 = u3[h6]) == null ? void 0 : i5.methods), events: ot((s3 = a2[h6]) == null ? void 0 : s3.events, (c6 = u3[h6]) == null ? void 0 : c6.events) };
  return l6;
}
var wo = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
var bo = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function ht(t, e) {
  const { message: n4, code: r2 } = bo[t];
  return { message: e ? `${n4} ${e}` : n4, code: r2 };
}
function Nt(t, e) {
  const { message: n4, code: r2 } = wo[t];
  return { message: e ? `${n4} ${e}` : n4, code: r2 };
}
function se(t, e) {
  return Array.isArray(t) ? typeof e < "u" && t.length ? t.every(e) : true : false;
}
function Oe(t) {
  return Object.getPrototypeOf(t) === Object.prototype && Object.keys(t).length;
}
function Et(t) {
  return typeof t > "u";
}
function nt(t, e) {
  return e && Et(t) ? true : typeof t == "string" && !!t.trim().length;
}
function Ae(t, e) {
  return e && Et(t) ? true : typeof t == "number" && !isNaN(t);
}
function ua(t, e) {
  const { requiredNamespaces: n4 } = e, r2 = Object.keys(t.namespaces), o2 = Object.keys(n4);
  let i5 = true;
  return gt(o2, r2) ? (r2.forEach((s3) => {
    const { accounts: c6, methods: a2, events: u3 } = t.namespaces[s3], l6 = It(c6), f9 = n4[s3];
    (!gt(ue(s3, f9), l6) || !gt(f9.methods, a2) || !gt(f9.events, u3)) && (i5 = false);
  }), i5) : false;
}
function ce(t) {
  return nt(t, false) && t.includes(":") ? t.split(":").length === 2 : false;
}
function Eo(t) {
  if (nt(t, false) && t.includes(":")) {
    const e = t.split(":");
    if (e.length === 3) {
      const n4 = e[0] + ":" + e[1];
      return !!e[2] && ce(n4);
    }
  }
  return false;
}
function fa(t) {
  function e(n4) {
    try {
      return typeof new URL(n4) < "u";
    } catch {
      return false;
    }
  }
  try {
    if (nt(t, false)) {
      if (e(t)) return true;
      const n4 = je(t);
      return e(n4);
    }
  } catch {
  }
  return false;
}
function la(t) {
  var e;
  return (e = t == null ? void 0 : t.proposer) == null ? void 0 : e.publicKey;
}
function da(t) {
  return t == null ? void 0 : t.topic;
}
function ha(t, e) {
  let n4 = null;
  return nt(t == null ? void 0 : t.publicKey, false) || (n4 = ht("MISSING_OR_INVALID", `${e} controller public key should be a string`)), n4;
}
function mn(t) {
  let e = true;
  return se(t) ? t.length && (e = t.every((n4) => nt(n4, false))) : e = false, e;
}
function vo(t, e, n4) {
  let r2 = null;
  return se(e) && e.length ? e.forEach((o2) => {
    r2 || ce(o2) || (r2 = Nt("UNSUPPORTED_CHAINS", `${n4}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : ce(t) || (r2 = Nt("UNSUPPORTED_CHAINS", `${n4}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function xo(t, e, n4) {
  let r2 = null;
  return Object.entries(t).forEach(([o2, i5]) => {
    if (r2) return;
    const s3 = vo(o2, ue(o2, i5), `${e} ${n4}`);
    s3 && (r2 = s3);
  }), r2;
}
function So(t, e) {
  let n4 = null;
  return se(t) ? t.forEach((r2) => {
    n4 || Eo(r2) || (n4 = Nt("UNSUPPORTED_ACCOUNTS", `${e}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : n4 = Nt("UNSUPPORTED_ACCOUNTS", `${e}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), n4;
}
function Oo(t, e) {
  let n4 = null;
  return Object.values(t).forEach((r2) => {
    if (n4) return;
    const o2 = So(r2 == null ? void 0 : r2.accounts, `${e} namespace`);
    o2 && (n4 = o2);
  }), n4;
}
function Ao(t, e) {
  let n4 = null;
  return mn(t == null ? void 0 : t.methods) ? mn(t == null ? void 0 : t.events) || (n4 = Nt("UNSUPPORTED_EVENTS", `${e}, events should be an array of strings or empty array for no events`)) : n4 = Nt("UNSUPPORTED_METHODS", `${e}, methods should be an array of strings or empty array for no methods`), n4;
}
function wn(t, e) {
  let n4 = null;
  return Object.values(t).forEach((r2) => {
    if (n4) return;
    const o2 = Ao(r2, `${e}, namespace`);
    o2 && (n4 = o2);
  }), n4;
}
function pa(t, e, n4) {
  let r2 = null;
  if (t && Oe(t)) {
    const o2 = wn(t, e);
    o2 && (r2 = o2);
    const i5 = xo(t, e, n4);
    i5 && (r2 = i5);
  } else r2 = ht("MISSING_OR_INVALID", `${e}, ${n4} should be an object with data`);
  return r2;
}
function Bo(t, e) {
  let n4 = null;
  if (t && Oe(t)) {
    const r2 = wn(t, e);
    r2 && (n4 = r2);
    const o2 = Oo(t, e);
    o2 && (n4 = o2);
  } else n4 = ht("MISSING_OR_INVALID", `${e}, namespaces should be an object with data`);
  return n4;
}
function Io(t) {
  return nt(t.protocol, true);
}
function ga(t, e) {
  let n4 = false;
  return e && !t ? n4 = true : t && se(t) && t.length && t.forEach((r2) => {
    n4 = Io(r2);
  }), n4;
}
function ya(t) {
  return typeof t == "number";
}
function ma(t) {
  return typeof t < "u" && typeof t !== null;
}
function wa(t) {
  return !(!t || typeof t != "object" || !t.code || !Ae(t.code, false) || !t.message || !nt(t.message, false));
}
function ba(t) {
  return !(Et(t) || !nt(t.method, false));
}
function Ea(t) {
  return !(Et(t) || Et(t.result) && Et(t.error) || !Ae(t.id, false) || !nt(t.jsonrpc, false));
}
function va(t) {
  return !(Et(t) || !nt(t.name, false));
}
function xa(t, e) {
  return !(!ce(e) || !ho(t).includes(e));
}
function Sa(t, e, n4) {
  return nt(n4, false) ? po(t, e).includes(n4) : false;
}
function Oa(t, e, n4) {
  return nt(n4, false) ? go(t, e).includes(n4) : false;
}
function No(t, e, n4) {
  let r2 = null;
  const o2 = Aa(t), i5 = Ba(e), s3 = Object.keys(o2), c6 = Object.keys(i5), a2 = Uo(Object.keys(t)), u3 = Uo(Object.keys(e)), l6 = a2.filter((f9) => !u3.includes(f9));
  return l6.length && (r2 = ht("NON_CONFORMING_NAMESPACES", `${n4} namespaces keys don't satisfy requiredNamespaces.
      Required: ${l6.toString()}
      Received: ${Object.keys(e).toString()}`)), gt(s3, c6) || (r2 = ht("NON_CONFORMING_NAMESPACES", `${n4} namespaces chains don't satisfy required namespaces.
      Required: ${s3.toString()}
      Approved: ${c6.toString()}`)), Object.keys(e).forEach((f9) => {
    if (!f9.includes(":") || r2) return;
    const h6 = It(e[f9].accounts);
    h6.includes(f9) || (r2 = ht("NON_CONFORMING_NAMESPACES", `${n4} namespaces accounts don't satisfy namespace accounts for ${f9}
        Required: ${f9}
        Approved: ${h6.toString()}`));
  }), s3.forEach((f9) => {
    r2 || (gt(o2[f9].methods, i5[f9].methods) ? gt(o2[f9].events, i5[f9].events) || (r2 = ht("NON_CONFORMING_NAMESPACES", `${n4} namespaces events don't satisfy namespace events for ${f9}`)) : r2 = ht("NON_CONFORMING_NAMESPACES", `${n4} namespaces methods don't satisfy namespace methods for ${f9}`));
  }), r2;
}
function Aa(t) {
  const e = {};
  return Object.keys(t).forEach((n4) => {
    var r2;
    n4.includes(":") ? e[n4] = t[n4] : (r2 = t[n4].chains) == null || r2.forEach((o2) => {
      e[o2] = { methods: t[n4].methods, events: t[n4].events };
    });
  }), e;
}
function Uo(t) {
  return [...new Set(t.map((e) => e.includes(":") ? e.split(":")[0] : e))];
}
function Ba(t) {
  const e = {};
  return Object.keys(t).forEach((n4) => {
    if (n4.includes(":")) e[n4] = t[n4];
    else {
      const r2 = It(t[n4].accounts);
      r2 == null ? void 0 : r2.forEach((o2) => {
        e[o2] = { accounts: t[n4].accounts.filter((i5) => i5.includes(`${o2}:`)), methods: t[n4].methods, events: t[n4].events };
      });
    }
  }), e;
}
function Ia(t, e) {
  return Ae(t, false) && t <= e.max && t >= e.min;
}
function Na() {
  const t = xt();
  return new Promise((e) => {
    switch (t) {
      case Y.browser:
        e(To());
        break;
      case Y.reactNative:
        e(Ro());
        break;
      case Y.node:
        e(_o());
        break;
      default:
        e(true);
    }
  });
}
function To() {
  return Tt() && (navigator == null ? void 0 : navigator.onLine);
}
async function Ro() {
  if (pt() && typeof global < "u" && global != null && global.NetInfo) {
    const t = await (global == null ? void 0 : global.NetInfo.fetch());
    return t == null ? void 0 : t.isConnected;
  }
  return true;
}
function _o() {
  return true;
}
function Ua(t) {
  switch (xt()) {
    case Y.browser:
      $o(t);
      break;
    case Y.reactNative:
      Lo(t);
      break;
    case Y.node:
      break;
  }
}
function $o(t) {
  !pt() && Tt() && (window.addEventListener("online", () => t(true)), window.addEventListener("offline", () => t(false)));
}
function Lo(t) {
  pt() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((e) => t(e == null ? void 0 : e.isConnected)));
}
function Ta() {
  var t;
  return Tt() && (0, import_window_getters.getDocument)() ? ((t = (0, import_window_getters.getDocument)()) == null ? void 0 : t.visibilityState) === "visible" : true;
}
var bn = {};
var Ra = class {
  static get(e) {
    return bn[e];
  }
  static set(e, n4) {
    bn[e] = n4;
  }
  static delete(e) {
    delete bn[e];
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_events3 = __toESM(require_events());

// node_modules/@walletconnect/core/node_modules/unstorage/dist/shared/unstorage.zVDD2mZo.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify3(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify3(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input, "base64");
  }
  return Uint8Array.from(
    globalThis.atob(input),
    (c6) => c6.codePointAt(0)
  );
}
function base64Encode(input) {
  if (globalThis.Buffer) {
    return Buffer.from(input).toString("base64");
  }
  return globalThis.btoa(String.fromCodePoint(...input));
}
function normalizeKey(key) {
  var _a;
  if (!key) {
    return "";
  }
  return ((_a = key.split("?")[0]) == null ? void 0 : _a.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "")) || "";
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
  if (depth === void 0) {
    return true;
  }
  let substrCount = 0;
  let index = key.indexOf(":");
  while (index > -1) {
    substrCount++;
    index = key.indexOf(":", index + 1);
  }
  return substrCount <= depth;
}
function filterKeyByBase(key, base) {
  if (base) {
    return key.startsWith(base) && key[key.length - 1] !== "$";
  }
  return key[key.length - 1] !== "$";
}

// node_modules/@walletconnect/core/node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r2) => r2.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions = {}) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r2) => r2.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify3(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify3(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify3(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      var _a;
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      let allMountsSupportMaxDepth = true;
      for (const mount of mounts) {
        if (!((_a = mount.driver.flags) == null ? void 0 : _a.maxDepth)) {
          allMountsSupportMaxDepth = false;
        }
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p6) => fullKey.startsWith(p6))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p6) => !p6.startsWith(mount.mountpoint))
        ];
      }
      const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
      return allKeys.filter(
        (key) => (!shouldFilterByDepth || filterKeyByDepth(key, opts.maxDepth)) && filterKeyByBase(key, base)
      );
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m3) => {
          if (m3.driver.clear) {
            return asyncCall(m3.driver.clear, m3.relativeBase, opts);
          }
          if (m3.driver.removeItem) {
            const keys2 = await m3.driver.getKeys(m3.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m3.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a2, b7) => b7.length - a2.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      var _a, _b;
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        (_b = (_a = context.unwatch)[base]) == null ? void 0 : _b.call(_a);
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m3 = getMount(key);
      return {
        driver: m3.driver,
        base: m3.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m3) => ({
        driver: m3.driver,
        base: m3.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/@walletconnect/core/node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i5 = {}) => {
  const t = i5.base && i5.base.length > 0 ? `${i5.base}:` : "", e = (s3) => t + s3;
  let n4;
  return i5.dbName && i5.storeName && (n4 = createStore(i5.dbName, i5.storeName)), { name: x, options: i5, async hasItem(s3) {
    return !(typeof await get(e(s3), n4) > "u");
  }, async getItem(s3) {
    return await get(e(s3), n4) ?? null;
  }, setItem(s3, a2) {
    return set(e(s3), a2, n4);
  }, removeItem(s3) {
    return del(e(s3), n4);
  }, getKeys() {
    return keys(n4);
  }, clear() {
    return clear(n4);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e = await this.indexedDb.getItem(t);
    if (e !== null) return e;
  }
  async setItem(t, e) {
    await this.indexedDb.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i5;
  function t() {
  }
  i5 = t, i5.prototype.getItem = function(e) {
    return this.hasOwnProperty(e) ? String(this[e]) : null;
  }, i5.prototype.setItem = function(e, n4) {
    this[e] = String(n4);
  }, i5.prototype.removeItem = function(e) {
    delete this[e];
  }, i5.prototype.clear = function() {
    const e = this;
    Object.keys(e).forEach(function(n4) {
      e[n4] = void 0, delete e[n4];
    });
  }, i5.prototype.key = function(e) {
    return e = e || 0, Object.keys(this)[e];
  }, i5.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k2(i5) {
  var t;
  return [i5[0], safeJsonParse((t = i5[1]) != null ? t : "")];
}
var K2 = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t) {
    const e = this.localStorage.getItem(t);
    if (e !== null) return safeJsonParse(e);
  }
  async setItem(t, e) {
    this.localStorage.setItem(t, safeJsonStringify(e));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N = "wc_storage_version";
var y = 1;
var O = async (i5, t, e) => {
  const n4 = N, s3 = await t.getItem(n4);
  if (s3 && s3 >= y) {
    e(t);
    return;
  }
  const a2 = await i5.getKeys();
  if (!a2.length) {
    e(t);
    return;
  }
  const m3 = [];
  for (; a2.length; ) {
    const r2 = a2.shift();
    if (!r2) continue;
    const o2 = r2.toLowerCase();
    if (o2.includes("wc@") || o2.includes("walletconnect") || o2.includes("wc_") || o2.includes("wallet_connect")) {
      const f9 = await i5.getItem(r2);
      await t.setItem(r2, f9), m3.push(r2);
    }
  }
  await t.setItem(n4, y), e(t), j(i5, m3);
};
var j = async (i5, t) => {
  t.length && t.forEach(async (e) => {
    await i5.removeItem(e);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e) => {
      this.storage = e, this.initialized = true;
    };
    const t = new K2();
    this.storage = t;
    try {
      const e = new _();
      O(t, e, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e) {
    return await this.initialize(), this.storage.setItem(t, e);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e = setInterval(() => {
        this.initialized && (clearInterval(e), t());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/core/node_modules/@walletconnect/logger/dist/index.es.js
var import_pino2 = __toESM(require_browser());
var import_pino3 = __toESM(require_browser());
var c2 = { level: "info" };
var n = "custom_context";
var l2 = 1e3 * 1024;
var O2 = class {
  constructor(e) {
    this.nodeValue = e, this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length, this.next = null;
  }
  get value() {
    return this.nodeValue;
  }
  get size() {
    return this.sizeInBytes;
  }
};
var d = class {
  constructor(e) {
    this.head = null, this.tail = null, this.lengthInNodes = 0, this.maxSizeInBytes = e, this.sizeInBytes = 0;
  }
  append(e) {
    const t = new O2(e);
    if (t.size > this.maxSizeInBytes) throw new Error(`[LinkedList] Value too big to insert into list: ${e} with size ${t.size}`);
    for (; this.size + t.size > this.maxSizeInBytes; ) this.shift();
    this.head ? (this.tail && (this.tail.next = t), this.tail = t) : (this.head = t, this.tail = t), this.lengthInNodes++, this.sizeInBytes += t.size;
  }
  shift() {
    if (!this.head) return;
    const e = this.head;
    this.head = this.head.next, this.head || (this.tail = null), this.lengthInNodes--, this.sizeInBytes -= e.size;
  }
  toArray() {
    const e = [];
    let t = this.head;
    for (; t !== null; ) e.push(t.value), t = t.next;
    return e;
  }
  get length() {
    return this.lengthInNodes;
  }
  get size() {
    return this.sizeInBytes;
  }
  toOrderedArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this.head;
    return { next: () => {
      if (!e) return { done: true, value: null };
      const t = e.value;
      return e = e.next, { done: false, value: t };
    } };
  }
};
var L = class {
  constructor(e, t = l2) {
    this.level = e ?? "error", this.levelValue = import_pino2.levels.values[this.level], this.MAX_LOG_SIZE_IN_BYTES = t, this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
  }
  forwardToConsole(e, t) {
    t === import_pino2.levels.values.error ? console.error(e) : t === import_pino2.levels.values.warn ? console.warn(e) : t === import_pino2.levels.values.debug ? console.debug(e) : t === import_pino2.levels.values.trace ? console.trace(e) : console.log(e);
  }
  appendToLogs(e) {
    this.logs.append(safeJsonStringify({ timestamp: (/* @__PURE__ */ new Date()).toISOString(), log: e }));
    const t = typeof e == "string" ? JSON.parse(e).level : e.level;
    t >= this.levelValue && this.forwardToConsole(e, t);
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = new d(this.MAX_LOG_SIZE_IN_BYTES);
  }
  getLogArray() {
    return Array.from(this.logs);
  }
  logsToBlob(e) {
    const t = this.getLogArray();
    return t.push(safeJsonStringify({ extraMetadata: e })), new Blob(t, { type: "application/json" });
  }
};
var m = class {
  constructor(e, t = l2) {
    this.baseChunkLogger = new L(e, t);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
  downloadLogsBlobInBrowser(e) {
    const t = URL.createObjectURL(this.logsToBlob(e)), o2 = document.createElement("a");
    o2.href = t, o2.download = `walletconnect-logs-${(/* @__PURE__ */ new Date()).toISOString()}.txt`, document.body.appendChild(o2), o2.click(), document.body.removeChild(o2), URL.revokeObjectURL(t);
  }
};
var B = class {
  constructor(e, t = l2) {
    this.baseChunkLogger = new L(e, t);
  }
  write(e) {
    this.baseChunkLogger.appendToLogs(e);
  }
  getLogs() {
    return this.baseChunkLogger.getLogs();
  }
  clearLogs() {
    this.baseChunkLogger.clearLogs();
  }
  getLogArray() {
    return this.baseChunkLogger.getLogArray();
  }
  logsToBlob(e) {
    return this.baseChunkLogger.logsToBlob(e);
  }
};
var x2 = Object.defineProperty;
var S = Object.defineProperties;
var _2 = Object.getOwnPropertyDescriptors;
var p = Object.getOwnPropertySymbols;
var T = Object.prototype.hasOwnProperty;
var z2 = Object.prototype.propertyIsEnumerable;
var f4 = (r2, e, t) => e in r2 ? x2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var i2 = (r2, e) => {
  for (var t in e || (e = {})) T.call(e, t) && f4(r2, t, e[t]);
  if (p) for (var t of p(e)) z2.call(e, t) && f4(r2, t, e[t]);
  return r2;
};
var g = (r2, e) => S(r2, _2(e));
function k3(r2) {
  return g(i2({}, r2), { level: (r2 == null ? void 0 : r2.level) || c2.level });
}
function v(r2, e = n) {
  return r2[e] || "";
}
function b(r2, e, t = n) {
  return r2[t] = e, r2;
}
function y2(r2, e = n) {
  let t = "";
  return typeof r2.bindings > "u" ? t = v(r2, e) : t = r2.bindings().context || "", t;
}
function w(r2, e, t = n) {
  const o2 = y2(r2, t);
  return o2.trim() ? `${o2}/${e}` : e;
}
function E2(r2, e, t = n) {
  const o2 = w(r2, e, t), a2 = r2.child({ context: o2 });
  return b(a2, o2, t);
}
function C2(r2) {
  var e, t;
  const o2 = new m((e = r2.opts) == null ? void 0 : e.level, r2.maxSizeInBytes);
  return { logger: (0, import_pino2.default)(g(i2({}, r2.opts), { level: "trace", browser: g(i2({}, (t = r2.opts) == null ? void 0 : t.browser), { write: (a2) => o2.write(a2) }) })), chunkLoggerController: o2 };
}
function I(r2) {
  var e;
  const t = new B((e = r2.opts) == null ? void 0 : e.level, r2.maxSizeInBytes);
  return { logger: (0, import_pino2.default)(g(i2({}, r2.opts), { level: "trace" }), t), chunkLoggerController: t };
}
function A(r2) {
  return typeof r2.loggerOverride < "u" && typeof r2.loggerOverride != "string" ? { logger: r2.loggerOverride, chunkLoggerController: null } : typeof window < "u" ? C2(r2) : I(r2);
}

// node_modules/@walletconnect/types/dist/index.es.js
var import_events2 = __toESM(require_events());
var a = Object.defineProperty;
var u = (e, s3, r2) => s3 in e ? a(e, s3, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s3] = r2;
var c3 = (e, s3, r2) => u(e, typeof s3 != "symbol" ? s3 + "" : s3, r2);
var h3 = class extends IEvents {
  constructor(s3) {
    super(), this.opts = s3, c3(this, "protocol", "wc"), c3(this, "version", 2);
  }
};
var p2 = Object.defineProperty;
var b2 = (e, s3, r2) => s3 in e ? p2(e, s3, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s3] = r2;
var v2 = (e, s3, r2) => b2(e, typeof s3 != "symbol" ? s3 + "" : s3, r2);
var I2 = class extends IEvents {
  constructor(s3, r2) {
    super(), this.core = s3, this.logger = r2, v2(this, "records", /* @__PURE__ */ new Map());
  }
};
var y3 = class {
  constructor(s3, r2) {
    this.logger = s3, this.core = r2;
  }
};
var m2 = class extends IEvents {
  constructor(s3, r2) {
    super(), this.relayer = s3, this.logger = r2;
  }
};
var d2 = class extends IEvents {
  constructor(s3) {
    super();
  }
};
var f5 = class {
  constructor(s3, r2, t, q4) {
    this.core = s3, this.logger = r2, this.name = t;
  }
};
var P = class extends IEvents {
  constructor(s3, r2) {
    super(), this.relayer = s3, this.logger = r2;
  }
};
var S2 = class extends IEvents {
  constructor(s3, r2) {
    super(), this.core = s3, this.logger = r2;
  }
};
var M = class {
  constructor(s3, r2, t) {
    this.core = s3, this.logger = r2, this.store = t;
  }
};
var O3 = class {
  constructor(s3, r2) {
    this.projectId = s3, this.logger = r2;
  }
};
var R = class {
  constructor(s3, r2, t) {
    this.core = s3, this.logger = r2, this.telemetryEnabled = t;
  }
};
var T2 = Object.defineProperty;
var k4 = (e, s3, r2) => s3 in e ? T2(e, s3, { enumerable: true, configurable: true, writable: true, value: r2 }) : e[s3] = r2;
var i3 = (e, s3, r2) => k4(e, typeof s3 != "symbol" ? s3 + "" : s3, r2);
var J = class {
  constructor(s3) {
    this.opts = s3, i3(this, "protocol", "wc"), i3(this, "version", 2);
  }
};
var V2 = class {
  constructor(s3) {
    this.client = s3;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());
var import_window_getters2 = __toESM(require_cjs2());
var ze2 = "wc";
var Le = 2;
var he2 = "core";
var B2 = `${ze2}@2:${he2}:`;
var Et2 = { name: he2, logger: "error" };
var It2 = { database: ":memory:" };
var Tt2 = "crypto";
var ke2 = "client_ed25519_seed";
var Ct2 = import_time2.ONE_DAY;
var Pt2 = "keychain";
var St2 = "0.3";
var Ot2 = "messages";
var Rt2 = "0.3";
var je2 = import_time2.SIX_HOURS;
var At2 = "publisher";
var xt2 = "irn";
var Nt2 = "error";
var Ue = "wss://relay.walletconnect.org";
var $t2 = "relayer";
var C3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var zt = "_subscription";
var L2 = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var Lt2 = 0.1;
var _e2 = "2.21.1";
var Q = { link_mode: "link_mode", relay: "relay" };
var le2 = { inbound: "inbound", outbound: "outbound" };
var kt2 = "0.3";
var jt2 = "WALLETCONNECT_CLIENT_ID";
var Fe2 = "WALLETCONNECT_LINK_MODE_APPS";
var $ = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var Ut = "subscription";
var Ft2 = "0.3";
var Ys2 = import_time2.FIVE_SECONDS * 1e3;
var Mt2 = "pairing";
var Kt2 = "0.3";
var se2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var re2 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var F2 = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var Bt2 = "history";
var Vt2 = "0.3";
var qt2 = "expirer";
var M2 = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var Gt = "0.3";
var Wt2 = "verify-api";
var Zs2 = "https://verify.walletconnect.com";
var Ht2 = "https://verify.walletconnect.org";
var ue2 = Ht2;
var Yt2 = `${ue2}/v3`;
var Jt2 = [Zs2, Ht2];
var Xt2 = "echo";
var Zt = "https://echo.walletconnect.com";
var G2 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var Y2 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var er2 = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var tr2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var ir2 = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var sr2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Qt2 = 0.1;
var ei2 = "event-client";
var ti = 86400;
var ii = "https://pulse.walletconnect.org/batch";
function rr2(r2, e) {
  if (r2.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i5 = 0; i5 < t.length; i5++) t[i5] = 255;
  for (var s3 = 0; s3 < r2.length; s3++) {
    var n4 = r2.charAt(s3), o2 = n4.charCodeAt(0);
    if (t[o2] !== 255) throw new TypeError(n4 + " is ambiguous");
    t[o2] = s3;
  }
  var a2 = r2.length, c6 = r2.charAt(0), h6 = Math.log(a2) / Math.log(256), l6 = Math.log(256) / Math.log(a2);
  function d4(u3) {
    if (u3 instanceof Uint8Array || (ArrayBuffer.isView(u3) ? u3 = new Uint8Array(u3.buffer, u3.byteOffset, u3.byteLength) : Array.isArray(u3) && (u3 = Uint8Array.from(u3))), !(u3 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (u3.length === 0) return "";
    for (var b7 = 0, x5 = 0, I5 = 0, D4 = u3.length; I5 !== D4 && u3[I5] === 0; ) I5++, b7++;
    for (var j4 = (D4 - I5) * l6 + 1 >>> 0, T5 = new Uint8Array(j4); I5 !== D4; ) {
      for (var q4 = u3[I5], J4 = 0, K5 = j4 - 1; (q4 !== 0 || J4 < x5) && K5 !== -1; K5--, J4++) q4 += 256 * T5[K5] >>> 0, T5[K5] = q4 % a2 >>> 0, q4 = q4 / a2 >>> 0;
      if (q4 !== 0) throw new Error("Non-zero carry");
      x5 = J4, I5++;
    }
    for (var H4 = j4 - x5; H4 !== j4 && T5[H4] === 0; ) H4++;
    for (var me4 = c6.repeat(b7); H4 < j4; ++H4) me4 += r2.charAt(T5[H4]);
    return me4;
  }
  function g3(u3) {
    if (typeof u3 != "string") throw new TypeError("Expected String");
    if (u3.length === 0) return new Uint8Array();
    var b7 = 0;
    if (u3[b7] !== " ") {
      for (var x5 = 0, I5 = 0; u3[b7] === c6; ) x5++, b7++;
      for (var D4 = (u3.length - b7) * h6 + 1 >>> 0, j4 = new Uint8Array(D4); u3[b7]; ) {
        var T5 = t[u3.charCodeAt(b7)];
        if (T5 === 255) return;
        for (var q4 = 0, J4 = D4 - 1; (T5 !== 0 || q4 < I5) && J4 !== -1; J4--, q4++) T5 += a2 * j4[J4] >>> 0, j4[J4] = T5 % 256 >>> 0, T5 = T5 / 256 >>> 0;
        if (T5 !== 0) throw new Error("Non-zero carry");
        I5 = q4, b7++;
      }
      if (u3[b7] !== " ") {
        for (var K5 = D4 - I5; K5 !== D4 && j4[K5] === 0; ) K5++;
        for (var H4 = new Uint8Array(x5 + (D4 - K5)), me4 = x5; K5 !== D4; ) H4[me4++] = j4[K5++];
        return H4;
      }
    }
  }
  function _5(u3) {
    var b7 = g3(u3);
    if (b7) return b7;
    throw new Error(`Non-${e} character`);
  }
  return { encode: d4, decodeUnsafe: g3, decode: _5 };
}
var nr2 = rr2;
var or2 = nr2;
var si2 = (r2) => {
  if (r2 instanceof Uint8Array && r2.constructor.name === "Uint8Array") return r2;
  if (r2 instanceof ArrayBuffer) return new Uint8Array(r2);
  if (ArrayBuffer.isView(r2)) return new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ar2 = (r2) => new TextEncoder().encode(r2);
var cr2 = (r2) => new TextDecoder().decode(r2);
var hr2 = class {
  constructor(e, t, i5) {
    this.name = e, this.prefix = t, this.baseEncode = i5;
  }
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var lr2 = class {
  constructor(e, t, i5) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i5;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e) {
    return ri2(this, e);
  }
};
var ur2 = class {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return ri2(this, e);
  }
  decode(e) {
    const t = e[0], i5 = this.decoders[t];
    if (i5) return i5.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ri2 = (r2, e) => new ur2({ ...r2.decoders || { [r2.prefix]: r2 }, ...e.decoders || { [e.prefix]: e } });
var dr2 = class {
  constructor(e, t, i5, s3) {
    this.name = e, this.prefix = t, this.baseEncode = i5, this.baseDecode = s3, this.encoder = new hr2(e, t, i5), this.decoder = new lr2(e, t, s3);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
};
var Ee2 = ({ name: r2, prefix: e, encode: t, decode: i5 }) => new dr2(r2, e, t, i5);
var de2 = ({ prefix: r2, name: e, alphabet: t }) => {
  const { encode: i5, decode: s3 } = or2(t, e);
  return Ee2({ prefix: r2, name: e, encode: i5, decode: (n4) => si2(s3(n4)) });
};
var gr = (r2, e, t, i5) => {
  const s3 = {};
  for (let l6 = 0; l6 < e.length; ++l6) s3[e[l6]] = l6;
  let n4 = r2.length;
  for (; r2[n4 - 1] === "="; ) --n4;
  const o2 = new Uint8Array(n4 * t / 8 | 0);
  let a2 = 0, c6 = 0, h6 = 0;
  for (let l6 = 0; l6 < n4; ++l6) {
    const d4 = s3[r2[l6]];
    if (d4 === void 0) throw new SyntaxError(`Non-${i5} character`);
    c6 = c6 << t | d4, a2 += t, a2 >= 8 && (a2 -= 8, o2[h6++] = 255 & c6 >> a2);
  }
  if (a2 >= t || 255 & c6 << 8 - a2) throw new SyntaxError("Unexpected end of data");
  return o2;
};
var pr = (r2, e, t) => {
  const i5 = e[e.length - 1] === "=", s3 = (1 << t) - 1;
  let n4 = "", o2 = 0, a2 = 0;
  for (let c6 = 0; c6 < r2.length; ++c6) for (a2 = a2 << 8 | r2[c6], o2 += 8; o2 > t; ) o2 -= t, n4 += e[s3 & a2 >> o2];
  if (o2 && (n4 += e[s3 & a2 << t - o2]), i5) for (; n4.length * t & 7; ) n4 += "=";
  return n4;
};
var P2 = ({ name: r2, prefix: e, bitsPerChar: t, alphabet: i5 }) => Ee2({ prefix: e, name: r2, encode(s3) {
  return pr(s3, i5, t);
}, decode(s3) {
  return gr(s3, i5, t, r2);
} });
var yr = Ee2({ prefix: "\0", name: "identity", encode: (r2) => cr2(r2), decode: (r2) => ar2(r2) });
var br2 = Object.freeze({ __proto__: null, identity: yr });
var mr2 = P2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var fr2 = Object.freeze({ __proto__: null, base2: mr2 });
var Dr2 = P2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vr2 = Object.freeze({ __proto__: null, base8: Dr2 });
var wr2 = de2({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _r2 = Object.freeze({ __proto__: null, base10: wr2 });
var Er = P2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Ir2 = P2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Tr2 = Object.freeze({ __proto__: null, base16: Er, base16upper: Ir2 });
var Cr2 = P2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Pr2 = P2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var Sr2 = P2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Or2 = P2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Rr2 = P2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var Ar2 = P2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var xr = P2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nr2 = P2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $r2 = P2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var zr2 = Object.freeze({ __proto__: null, base32: Cr2, base32upper: Pr2, base32pad: Sr2, base32padupper: Or2, base32hex: Rr2, base32hexupper: Ar2, base32hexpad: xr, base32hexpadupper: Nr2, base32z: $r2 });
var Lr2 = de2({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var kr2 = de2({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var jr2 = Object.freeze({ __proto__: null, base36: Lr2, base36upper: kr2 });
var Ur2 = de2({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Fr2 = de2({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Mr2 = Object.freeze({ __proto__: null, base58btc: Ur2, base58flickr: Fr2 });
var Kr3 = P2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Br2 = P2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Vr2 = P2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var qr2 = P2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Gr2 = Object.freeze({ __proto__: null, base64: Kr3, base64pad: Br2, base64url: Vr2, base64urlpad: qr2 });
var ni2 = Array.from("");
var Wr2 = ni2.reduce((r2, e, t) => (r2[t] = e, r2), []);
var Hr2 = ni2.reduce((r2, e, t) => (r2[e.codePointAt(0)] = t, r2), []);
function Yr2(r2) {
  return r2.reduce((e, t) => (e += Wr2[t], e), "");
}
function Jr2(r2) {
  const e = [];
  for (const t of r2) {
    const i5 = Hr2[t.codePointAt(0)];
    if (i5 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i5);
  }
  return new Uint8Array(e);
}
var Xr2 = Ee2({ prefix: "", name: "base256emoji", encode: Yr2, decode: Jr2 });
var Zr2 = Object.freeze({ __proto__: null, base256emoji: Xr2 });
var Qr2 = ai;
var oi2 = 128;
var en2 = 127;
var tn2 = ~en2;
var sn3 = Math.pow(2, 31);
function ai(r2, e, t) {
  e = e || [], t = t || 0;
  for (var i5 = t; r2 >= sn3; ) e[t++] = r2 & 255 | oi2, r2 /= 128;
  for (; r2 & tn2; ) e[t++] = r2 & 255 | oi2, r2 >>>= 7;
  return e[t] = r2 | 0, ai.bytes = t - i5 + 1, e;
}
var rn2 = Me2;
var nn2 = 128;
var ci = 127;
function Me2(r2, i5) {
  var t = 0, i5 = i5 || 0, s3 = 0, n4 = i5, o2, a2 = r2.length;
  do {
    if (n4 >= a2) throw Me2.bytes = 0, new RangeError("Could not decode varint");
    o2 = r2[n4++], t += s3 < 28 ? (o2 & ci) << s3 : (o2 & ci) * Math.pow(2, s3), s3 += 7;
  } while (o2 >= nn2);
  return Me2.bytes = n4 - i5, t;
}
var on2 = Math.pow(2, 7);
var an2 = Math.pow(2, 14);
var cn2 = Math.pow(2, 21);
var hn2 = Math.pow(2, 28);
var ln2 = Math.pow(2, 35);
var un2 = Math.pow(2, 42);
var dn2 = Math.pow(2, 49);
var gn2 = Math.pow(2, 56);
var pn2 = Math.pow(2, 63);
var yn2 = function(r2) {
  return r2 < on2 ? 1 : r2 < an2 ? 2 : r2 < cn2 ? 3 : r2 < hn2 ? 4 : r2 < ln2 ? 5 : r2 < un2 ? 6 : r2 < dn2 ? 7 : r2 < gn2 ? 8 : r2 < pn2 ? 9 : 10;
};
var bn2 = { encode: Qr2, decode: rn2, encodingLength: yn2 };
var hi = bn2;
var li2 = (r2, e, t = 0) => (hi.encode(r2, e, t), e);
var ui = (r2) => hi.encodingLength(r2);
var Ke2 = (r2, e) => {
  const t = e.byteLength, i5 = ui(r2), s3 = i5 + ui(t), n4 = new Uint8Array(s3 + t);
  return li2(r2, n4, 0), li2(t, n4, i5), n4.set(e, s3), new mn2(r2, t, e, n4);
};
var mn2 = class {
  constructor(e, t, i5, s3) {
    this.code = e, this.size = t, this.digest = i5, this.bytes = s3;
  }
};
var di = ({ name: r2, code: e, encode: t }) => new fn2(r2, e, t);
var fn2 = class {
  constructor(e, t, i5) {
    this.name = e, this.code = t, this.encode = i5;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? Ke2(this.code, t) : t.then((i5) => Ke2(this.code, i5));
    } else throw Error("Unknown type, must be binary type");
  }
};
var gi2 = (r2) => async (e) => new Uint8Array(await crypto.subtle.digest(r2, e));
var Dn = di({ name: "sha2-256", code: 18, encode: gi2("SHA-256") });
var vn = di({ name: "sha2-512", code: 19, encode: gi2("SHA-512") });
var wn2 = Object.freeze({ __proto__: null, sha256: Dn, sha512: vn });
var pi = 0;
var _n2 = "identity";
var yi2 = si2;
var En2 = (r2) => Ke2(pi, yi2(r2));
var In = { code: pi, name: _n2, encode: yi2, digest: En2 };
var Tn2 = Object.freeze({ __proto__: null, identity: In });
new TextEncoder(), new TextDecoder();
var bi2 = { ...br2, ...fr2, ...vr2, ..._r2, ...Tr2, ...zr2, ...jr2, ...Mr2, ...Gr2, ...Zr2 };
({ ...wn2, ...Tn2 });
function Cn2(r2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r2) : new Uint8Array(r2);
}
function mi2(r2, e, t, i5) {
  return { name: r2, prefix: e, encoder: { name: r2, prefix: e, encode: t }, decoder: { decode: i5 } };
}
var fi2 = mi2("utf8", "u", (r2) => "u" + new TextDecoder("utf8").decode(r2), (r2) => new TextEncoder().encode(r2.substring(1)));
var Be = mi2("ascii", "a", (r2) => {
  let e = "a";
  for (let t = 0; t < r2.length; t++) e += String.fromCharCode(r2[t]);
  return e;
}, (r2) => {
  r2 = r2.substring(1);
  const e = Cn2(r2.length);
  for (let t = 0; t < r2.length; t++) e[t] = r2.charCodeAt(t);
  return e;
});
var Pn2 = { utf8: fi2, "utf-8": fi2, hex: bi2.base16, latin1: Be, ascii: Be, binary: Be, ...bi2 };
function Sn2(r2, e = "utf8") {
  const t = Pn2[e];
  if (!t) throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r2, "utf8") : t.decoder.decode(`${t.prefix}${r2}`);
}
var On2 = Object.defineProperty;
var Rn2 = (r2, e, t) => e in r2 ? On2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var W = (r2, e, t) => Rn2(r2, typeof e != "symbol" ? e + "" : e, t);
var Di2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, W(this, "keychain", /* @__PURE__ */ new Map()), W(this, "name", Pt2), W(this, "version", St2), W(this, "initialized", false), W(this, "storagePrefix", B2), W(this, "init", async () => {
      if (!this.initialized) {
        const i5 = await this.getKeyChain();
        typeof i5 < "u" && (this.keychain = i5), this.initialized = true;
      }
    }), W(this, "has", (i5) => (this.isInitialized(), this.keychain.has(i5))), W(this, "set", async (i5, s3) => {
      this.isInitialized(), this.keychain.set(i5, s3), await this.persist();
    }), W(this, "get", (i5) => {
      this.isInitialized();
      const s3 = this.keychain.get(i5);
      if (typeof s3 > "u") {
        const { message: n4 } = ht("NO_MATCHING_KEY", `${this.name}: ${i5}`);
        throw new Error(n4);
      }
      return s3;
    }), W(this, "del", async (i5) => {
      this.isInitialized(), this.keychain.delete(i5), await this.persist();
    }), this.core = e, this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e) {
    await this.core.storage.setItem(this.storageKey, fi(e));
  }
  async getKeyChain() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? li(e) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var An = Object.defineProperty;
var xn2 = (r2, e, t) => e in r2 ? An(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var S3 = (r2, e, t) => xn2(r2, typeof e != "symbol" ? e + "" : e, t);
var vi2 = class {
  constructor(e, t, i5) {
    this.core = e, this.logger = t, S3(this, "name", Tt2), S3(this, "keychain"), S3(this, "randomSessionIdentifier", jc()), S3(this, "initialized", false), S3(this, "init", async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }), S3(this, "hasKeys", (s3) => (this.isInitialized(), this.keychain.has(s3))), S3(this, "getClientId", async () => {
      this.isInitialized();
      const s3 = await this.getClientSeed(), n4 = Po(s3);
      return Qe(n4.publicKey);
    }), S3(this, "generateKeyPair", () => {
      this.isInitialized();
      const s3 = Lc();
      return this.setPrivateKey(s3.publicKey, s3.privateKey);
    }), S3(this, "signJWT", async (s3) => {
      this.isInitialized();
      const n4 = await this.getClientSeed(), o2 = Po(n4), a2 = this.randomSessionIdentifier, c6 = Ct2;
      return await Qo(a2, s3, c6, o2);
    }), S3(this, "generateSharedKey", (s3, n4, o2) => {
      this.isInitialized();
      const a2 = this.getPrivateKey(s3), c6 = Cc(a2, n4);
      return this.setSymKey(c6, o2);
    }), S3(this, "setSymKey", async (s3, n4) => {
      this.isInitialized();
      const o2 = n4 || Pc(s3);
      return await this.keychain.set(o2, s3), o2;
    }), S3(this, "deleteKeyPair", async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }), S3(this, "deleteSymKey", async (s3) => {
      this.isInitialized(), await this.keychain.del(s3);
    }), S3(this, "encode", async (s3, n4, o2) => {
      this.isInitialized();
      const a2 = oo(o2), c6 = safeJsonStringify(n4);
      if (Fc(a2)) return Dc(c6, o2 == null ? void 0 : o2.encoding);
      if (Kc(a2)) {
        const g3 = a2.senderPublicKey, _5 = a2.receiverPublicKey;
        s3 = await this.generateSharedKey(g3, _5);
      }
      const h6 = this.getSymKey(s3), { type: l6, senderPublicKey: d4 } = a2;
      return Vc({ type: l6, symKey: h6, message: c6, senderPublicKey: d4, encoding: o2 == null ? void 0 : o2.encoding });
    }), S3(this, "decode", async (s3, n4, o2) => {
      this.isInitialized();
      const a2 = qc(n4, o2);
      if (Fc(a2)) {
        const c6 = Hc(n4, o2 == null ? void 0 : o2.encoding);
        return safeJsonParse(c6);
      }
      if (Kc(a2)) {
        const c6 = a2.receiverPublicKey, h6 = a2.senderPublicKey;
        s3 = await this.generateSharedKey(c6, h6);
      }
      try {
        const c6 = this.getSymKey(s3), h6 = Mc({ symKey: c6, encoded: n4, encoding: o2 == null ? void 0 : o2.encoding });
        return safeJsonParse(h6);
      } catch (c6) {
        this.logger.error(`Failed to decode message from topic: '${s3}', clientId: '${await this.getClientId()}'`), this.logger.error(c6);
      }
    }), S3(this, "getPayloadType", (s3, n4 = qt) => {
      const o2 = Se({ encoded: s3, encoding: n4 });
      return Bt(o2.type);
    }), S3(this, "getPayloadSenderPublicKey", (s3, n4 = qt) => {
      const o2 = Se({ encoded: s3, encoding: n4 });
      return o2.senderPublicKey ? toString(o2.senderPublicKey, G) : void 0;
    }), this.core = e, this.logger = E2(t, this.name), this.keychain = i5 || new Di2(this.core, this.logger);
  }
  get context() {
    return y2(this.logger);
  }
  async setPrivateKey(e, t) {
    return await this.keychain.set(e, t), e;
  }
  getPrivateKey(e) {
    return this.keychain.get(e);
  }
  async getClientSeed() {
    let e = "";
    try {
      e = this.keychain.get(ke2);
    } catch {
      e = jc(), await this.keychain.set(ke2, e);
    }
    return Sn2(e, "base16");
  }
  getSymKey(e) {
    return this.keychain.get(e);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Nn = Object.defineProperty;
var $n2 = Object.defineProperties;
var zn2 = Object.getOwnPropertyDescriptors;
var wi2 = Object.getOwnPropertySymbols;
var Ln = Object.prototype.hasOwnProperty;
var kn2 = Object.prototype.propertyIsEnumerable;
var Ve2 = (r2, e, t) => e in r2 ? Nn(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var jn2 = (r2, e) => {
  for (var t in e || (e = {})) Ln.call(e, t) && Ve2(r2, t, e[t]);
  if (wi2) for (var t of wi2(e)) kn2.call(e, t) && Ve2(r2, t, e[t]);
  return r2;
};
var Un = (r2, e) => $n2(r2, zn2(e));
var k5 = (r2, e, t) => Ve2(r2, typeof e != "symbol" ? e + "" : e, t);
var _i2 = class extends y3 {
  constructor(e, t) {
    super(e, t), this.logger = e, this.core = t, k5(this, "messages", /* @__PURE__ */ new Map()), k5(this, "messagesWithoutClientAck", /* @__PURE__ */ new Map()), k5(this, "name", Ot2), k5(this, "version", Rt2), k5(this, "initialized", false), k5(this, "storagePrefix", B2), k5(this, "init", async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const i5 = await this.getRelayerMessages();
          typeof i5 < "u" && (this.messages = i5);
          const s3 = await this.getRelayerMessagesWithoutClientAck();
          typeof s3 < "u" && (this.messagesWithoutClientAck = s3), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (i5) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i5);
        } finally {
          this.initialized = true;
        }
      }
    }), k5(this, "set", async (i5, s3, n4) => {
      this.isInitialized();
      const o2 = kc(s3);
      let a2 = this.messages.get(i5);
      if (typeof a2 > "u" && (a2 = {}), typeof a2[o2] < "u") return o2;
      if (a2[o2] = s3, this.messages.set(i5, a2), n4 === le2.inbound) {
        const c6 = this.messagesWithoutClientAck.get(i5) || {};
        this.messagesWithoutClientAck.set(i5, Un(jn2({}, c6), { [o2]: s3 }));
      }
      return await this.persist(), o2;
    }), k5(this, "get", (i5) => {
      this.isInitialized();
      let s3 = this.messages.get(i5);
      return typeof s3 > "u" && (s3 = {}), s3;
    }), k5(this, "getWithoutAck", (i5) => {
      this.isInitialized();
      const s3 = {};
      for (const n4 of i5) {
        const o2 = this.messagesWithoutClientAck.get(n4) || {};
        s3[n4] = Object.values(o2);
      }
      return s3;
    }), k5(this, "has", (i5, s3) => {
      this.isInitialized();
      const n4 = this.get(i5), o2 = kc(s3);
      return typeof n4[o2] < "u";
    }), k5(this, "ack", async (i5, s3) => {
      this.isInitialized();
      const n4 = this.messagesWithoutClientAck.get(i5);
      if (typeof n4 > "u") return;
      const o2 = kc(s3);
      delete n4[o2], Object.keys(n4).length === 0 ? this.messagesWithoutClientAck.delete(i5) : this.messagesWithoutClientAck.set(i5, n4), await this.persist();
    }), k5(this, "del", async (i5) => {
      this.isInitialized(), this.messages.delete(i5), this.messagesWithoutClientAck.delete(i5), await this.persist();
    }), this.logger = E2(e, this.name), this.core = t;
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get storageKeyWithoutClientAck() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name + "_withoutClientAck";
  }
  async setRelayerMessages(e) {
    await this.core.storage.setItem(this.storageKey, fi(e));
  }
  async setRelayerMessagesWithoutClientAck(e) {
    await this.core.storage.setItem(this.storageKeyWithoutClientAck, fi(e));
  }
  async getRelayerMessages() {
    const e = await this.core.storage.getItem(this.storageKey);
    return typeof e < "u" ? li(e) : void 0;
  }
  async getRelayerMessagesWithoutClientAck() {
    const e = await this.core.storage.getItem(this.storageKeyWithoutClientAck);
    return typeof e < "u" ? li(e) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages), await this.setRelayerMessagesWithoutClientAck(this.messagesWithoutClientAck);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Fn2 = Object.defineProperty;
var Mn2 = Object.defineProperties;
var Kn2 = Object.getOwnPropertyDescriptors;
var Ei2 = Object.getOwnPropertySymbols;
var Bn = Object.prototype.hasOwnProperty;
var Vn2 = Object.prototype.propertyIsEnumerable;
var qe2 = (r2, e, t) => e in r2 ? Fn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Ie2 = (r2, e) => {
  for (var t in e || (e = {})) Bn.call(e, t) && qe2(r2, t, e[t]);
  if (Ei2) for (var t of Ei2(e)) Vn2.call(e, t) && qe2(r2, t, e[t]);
  return r2;
};
var Ge2 = (r2, e) => Mn2(r2, Kn2(e));
var V3 = (r2, e, t) => qe2(r2, typeof e != "symbol" ? e + "" : e, t);
var qn = class extends m2 {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, V3(this, "events", new import_events3.EventEmitter()), V3(this, "name", At2), V3(this, "queue", /* @__PURE__ */ new Map()), V3(this, "publishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), V3(this, "initialPublishTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), V3(this, "needsTransportRestart", false), V3(this, "publish", async (i5, s3, n4) => {
      var o2;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i5, message: s3, opts: n4 } });
      const a2 = (n4 == null ? void 0 : n4.ttl) || je2, c6 = Zc(n4), h6 = (n4 == null ? void 0 : n4.prompt) || false, l6 = (n4 == null ? void 0 : n4.tag) || 0, d4 = (n4 == null ? void 0 : n4.id) || getBigIntRpcId().toString(), g3 = { topic: i5, message: s3, opts: { ttl: a2, relay: c6, prompt: h6, tag: l6, id: d4, attestation: n4 == null ? void 0 : n4.attestation, tvf: n4 == null ? void 0 : n4.tvf } }, _5 = `Failed to publish payload, please try again. id:${d4} tag:${l6}`;
      try {
        const u3 = new Promise(async (b7) => {
          const x5 = ({ id: D4 }) => {
            g3.opts.id === D4 && (this.removeRequestFromQueue(D4), this.relayer.events.removeListener(C3.publish, x5), b7(g3));
          };
          this.relayer.events.on(C3.publish, x5);
          const I5 = yi(new Promise((D4, j4) => {
            this.rpcPublish({ topic: i5, message: s3, ttl: a2, prompt: h6, tag: l6, id: d4, attestation: n4 == null ? void 0 : n4.attestation, tvf: n4 == null ? void 0 : n4.tvf }).then(D4).catch((T5) => {
              this.logger.warn(T5, T5 == null ? void 0 : T5.message), j4(T5);
            });
          }), this.initialPublishTimeout, `Failed initial publish, retrying.... id:${d4} tag:${l6}`);
          try {
            await I5, this.events.removeListener(C3.publish, x5);
          } catch (D4) {
            this.queue.set(d4, Ge2(Ie2({}, g3), { attempt: 1 })), this.logger.warn(D4, D4 == null ? void 0 : D4.message);
          }
        });
        this.logger.trace({ type: "method", method: "publish", params: { id: d4, topic: i5, message: s3, opts: n4 } }), await yi(u3, this.publishTimeout, _5);
      } catch (u3) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(u3), (o2 = n4 == null ? void 0 : n4.internal) != null && o2.throwOnFailedPublish) throw u3;
      } finally {
        this.queue.delete(d4);
      }
    }), V3(this, "on", (i5, s3) => {
      this.events.on(i5, s3);
    }), V3(this, "once", (i5, s3) => {
      this.events.once(i5, s3);
    }), V3(this, "off", (i5, s3) => {
      this.events.off(i5, s3);
    }), V3(this, "removeListener", (i5, s3) => {
      this.events.removeListener(i5, s3);
    }), this.relayer = e, this.logger = E2(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y2(this.logger);
  }
  async rpcPublish(e) {
    var t, i5, s3, n4;
    const { topic: o2, message: a2, ttl: c6 = je2, prompt: h6, tag: l6, id: d4, attestation: g3, tvf: _5 } = e, u3 = { method: Yc(Zc().protocol).publish, params: Ie2({ topic: o2, message: a2, ttl: c6, prompt: h6, tag: l6, attestation: g3 }, _5), id: d4 };
    Et((t = u3.params) == null ? void 0 : t.prompt) && ((i5 = u3.params) == null || delete i5.prompt), Et((s3 = u3.params) == null ? void 0 : s3.tag) && ((n4 = u3.params) == null || delete n4.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: u3 });
    const b7 = await this.relayer.request(u3);
    return this.relayer.events.emit(C3.publish, e), this.logger.debug("Successfully Published Payload"), b7;
  }
  removeRequestFromQueue(e) {
    this.queue.delete(e);
  }
  checkQueue() {
    this.queue.forEach(async (e, t) => {
      const i5 = e.attempt + 1;
      this.queue.set(t, Ge2(Ie2({}, e), { attempt: i5 }));
      const { topic: s3, message: n4, opts: o2, attestation: a2 } = e;
      this.logger.warn({}, `Publisher: queue->publishing: ${e.opts.id}, tag: ${e.opts.tag}, attempt: ${i5}`), await this.rpcPublish(Ge2(Ie2({}, e), { topic: s3, message: n4, ttl: o2.ttl, prompt: o2.prompt, tag: o2.tag, id: o2.id, attestation: a2, tvf: o2.tvf })), this.logger.warn({}, `Publisher: queue->published: ${e.opts.id}`);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(C3.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(C3.message_ack, (e) => {
      this.removeRequestFromQueue(e.id.toString());
    });
  }
};
var Gn2 = Object.defineProperty;
var Wn2 = (r2, e, t) => e in r2 ? Gn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var ne2 = (r2, e, t) => Wn2(r2, typeof e != "symbol" ? e + "" : e, t);
var Hn = class {
  constructor() {
    ne2(this, "map", /* @__PURE__ */ new Map()), ne2(this, "set", (e, t) => {
      const i5 = this.get(e);
      this.exists(e, t) || this.map.set(e, [...i5, t]);
    }), ne2(this, "get", (e) => this.map.get(e) || []), ne2(this, "exists", (e, t) => this.get(e).includes(t)), ne2(this, "delete", (e, t) => {
      if (typeof t > "u") {
        this.map.delete(e);
        return;
      }
      if (!this.map.has(e)) return;
      const i5 = this.get(e);
      if (!this.exists(e, t)) return;
      const s3 = i5.filter((n4) => n4 !== t);
      if (!s3.length) {
        this.map.delete(e);
        return;
      }
      this.map.set(e, s3);
    }), ne2(this, "clear", () => {
      this.map.clear();
    });
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var Yn2 = Object.defineProperty;
var Jn2 = Object.defineProperties;
var Xn2 = Object.getOwnPropertyDescriptors;
var Ii2 = Object.getOwnPropertySymbols;
var Zn2 = Object.prototype.hasOwnProperty;
var Qn2 = Object.prototype.propertyIsEnumerable;
var We2 = (r2, e, t) => e in r2 ? Yn2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var ge2 = (r2, e) => {
  for (var t in e || (e = {})) Zn2.call(e, t) && We2(r2, t, e[t]);
  if (Ii2) for (var t of Ii2(e)) Qn2.call(e, t) && We2(r2, t, e[t]);
  return r2;
};
var He2 = (r2, e) => Jn2(r2, Xn2(e));
var f6 = (r2, e, t) => We2(r2, typeof e != "symbol" ? e + "" : e, t);
var Ti2 = class extends P {
  constructor(e, t) {
    super(e, t), this.relayer = e, this.logger = t, f6(this, "subscriptions", /* @__PURE__ */ new Map()), f6(this, "topicMap", new Hn()), f6(this, "events", new import_events3.EventEmitter()), f6(this, "name", Ut), f6(this, "version", Ft2), f6(this, "pending", /* @__PURE__ */ new Map()), f6(this, "cached", []), f6(this, "initialized", false), f6(this, "storagePrefix", B2), f6(this, "subscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE)), f6(this, "initialSubscribeTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), f6(this, "clientId"), f6(this, "batchSubscribeTopicsLimit", 500), f6(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), await this.restore()), this.initialized = true;
    }), f6(this, "subscribe", async (i5, s3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i5, opts: s3 } });
      try {
        const n4 = Zc(s3), o2 = { topic: i5, relay: n4, transportType: s3 == null ? void 0 : s3.transportType };
        this.pending.set(i5, o2);
        const a2 = await this.rpcSubscribe(i5, n4, s3);
        return typeof a2 == "string" && (this.onSubscribe(a2, o2), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i5, opts: s3 } })), a2;
      } catch (n4) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n4), n4;
      }
    }), f6(this, "unsubscribe", async (i5, s3) => {
      this.isInitialized(), typeof (s3 == null ? void 0 : s3.id) < "u" ? await this.unsubscribeById(i5, s3.id, s3) : await this.unsubscribeByTopic(i5, s3);
    }), f6(this, "isSubscribed", (i5) => new Promise((s3) => {
      s3(this.topicMap.topics.includes(i5));
    })), f6(this, "isKnownTopic", (i5) => new Promise((s3) => {
      s3(this.topicMap.topics.includes(i5) || this.pending.has(i5) || this.cached.some((n4) => n4.topic === i5));
    })), f6(this, "on", (i5, s3) => {
      this.events.on(i5, s3);
    }), f6(this, "once", (i5, s3) => {
      this.events.once(i5, s3);
    }), f6(this, "off", (i5, s3) => {
      this.events.off(i5, s3);
    }), f6(this, "removeListener", (i5, s3) => {
      this.events.removeListener(i5, s3);
    }), f6(this, "start", async () => {
      await this.onConnect();
    }), f6(this, "stop", async () => {
      await this.onDisconnect();
    }), f6(this, "restart", async () => {
      await this.restore(), await this.onRestart();
    }), f6(this, "checkPending", async () => {
      if (this.pending.size === 0 && (!this.initialized || !this.relayer.connected)) return;
      const i5 = [];
      this.pending.forEach((s3) => {
        i5.push(s3);
      }), await this.batchSubscribe(i5);
    }), f6(this, "registerEventListeners", () => {
      this.relayer.core.heartbeat.on(r.pulse, async () => {
        await this.checkPending();
      }), this.events.on($.created, async (i5) => {
        const s3 = $.created;
        this.logger.info(`Emitting ${s3}`), this.logger.debug({ type: "event", event: s3, data: i5 }), await this.persist();
      }), this.events.on($.deleted, async (i5) => {
        const s3 = $.deleted;
        this.logger.info(`Emitting ${s3}`), this.logger.debug({ type: "event", event: s3, data: i5 }), await this.persist();
      });
    }), this.relayer = e, this.logger = E2(t, this.name), this.clientId = "";
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  get hasAnyTopics() {
    return this.topicMap.topics.length > 0 || this.pending.size > 0 || this.cached.length > 0 || this.subscriptions.size > 0;
  }
  hasSubscription(e, t) {
    let i5 = false;
    try {
      i5 = this.getSubscription(e).topic === t;
    } catch {
    }
    return i5;
  }
  reset() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.values.length > 0 && (this.cached = this.values), this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e, t) {
    const i5 = this.topicMap.get(e);
    await Promise.all(i5.map(async (s3) => await this.unsubscribeById(e, s3, t)));
  }
  async unsubscribeById(e, t, i5) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i5 } });
    try {
      const s3 = Zc(i5);
      await this.restartToComplete({ topic: e, id: t, relay: s3 }), await this.rpcUnsubscribe(e, t, s3);
      const n4 = Nt("USER_DISCONNECTED", `${this.name}, ${e}`);
      await this.onUnsubscribe(e, t, n4), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e, id: t, opts: i5 } });
    } catch (s3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s3), s3;
    }
  }
  async rpcSubscribe(e, t, i5) {
    var s3;
    (!i5 || (i5 == null ? void 0 : i5.transportType) === Q.relay) && await this.restartToComplete({ topic: e, id: e, relay: t });
    const n4 = { method: Yc(t.protocol).subscribe, params: { topic: e } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: n4 });
    const o2 = (s3 = i5 == null ? void 0 : i5.internal) == null ? void 0 : s3.throwOnFailedPublish;
    try {
      const a2 = await this.getSubscriptionId(e);
      if ((i5 == null ? void 0 : i5.transportType) === Q.link_mode) return setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(n4).catch((l6) => this.logger.warn(l6));
      }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), a2;
      const c6 = new Promise(async (l6) => {
        const d4 = (g3) => {
          g3.topic === e && (this.events.removeListener($.created, d4), l6(g3.id));
        };
        this.events.on($.created, d4);
        try {
          const g3 = await yi(new Promise((_5, u3) => {
            this.relayer.request(n4).catch((b7) => {
              this.logger.warn(b7, b7 == null ? void 0 : b7.message), u3(b7);
            }).then(_5);
          }), this.initialSubscribeTimeout, `Subscribing to ${e} failed, please try again`);
          this.events.removeListener($.created, d4), l6(g3);
        } catch {
        }
      }), h6 = await yi(c6, this.subscribeTimeout, `Subscribing to ${e} failed, please try again`);
      if (!h6 && o2) throw new Error(`Subscribing to ${e} failed, please try again`);
      return h6 ? a2 : null;
    } catch (a2) {
      if (this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(C3.connection_stalled), o2) throw a2;
    }
    return null;
  }
  async rpcBatchSubscribe(e) {
    if (!e.length) return;
    const t = e[0].relay, i5 = { method: Yc(t.protocol).batchSubscribe, params: { topics: e.map((s3) => s3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i5 });
    try {
      await await yi(new Promise((s3) => {
        this.relayer.request(i5).catch((n4) => this.logger.warn(n4)).then(s3);
      }), this.subscribeTimeout, "rpcBatchSubscribe failed, please try again");
    } catch {
      this.relayer.events.emit(C3.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e) {
    if (!e.length) return;
    const t = e[0].relay, i5 = { method: Yc(t.protocol).batchFetchMessages, params: { topics: e.map((n4) => n4.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i5 });
    let s3;
    try {
      s3 = await await yi(new Promise((n4, o2) => {
        this.relayer.request(i5).catch((a2) => {
          this.logger.warn(a2), o2(a2);
        }).then(n4);
      }), this.subscribeTimeout, "rpcBatchFetchMessages failed, please try again");
    } catch {
      this.relayer.events.emit(C3.connection_stalled);
    }
    return s3;
  }
  rpcUnsubscribe(e, t, i5) {
    const s3 = { method: Yc(i5.protocol).unsubscribe, params: { topic: e, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s3 }), this.relayer.request(s3);
  }
  onSubscribe(e, t) {
    this.setSubscription(e, He2(ge2({}, t), { id: e })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e) {
    e.length && e.forEach((t) => {
      this.setSubscription(t.id, ge2({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e, t, i5) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e) && this.deleteSubscription(t, i5), await this.relayer.messages.del(e);
  }
  async setRelayerSubscriptions(e) {
    await this.relayer.core.storage.setItem(this.storageKey, e);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e, subscription: t }), this.addSubscription(e, t);
  }
  addSubscription(e, t) {
    this.subscriptions.set(e, ge2({}, t)), this.topicMap.set(t.topic, e), this.events.emit($.created, t);
  }
  getSubscription(e) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e });
    const t = this.subscriptions.get(e);
    if (!t) {
      const { message: i5 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i5);
    }
    return t;
  }
  deleteSubscription(e, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e, reason: t });
    const i5 = this.getSubscription(e);
    this.subscriptions.delete(e), this.topicMap.delete(i5.topic, e), this.events.emit($.deleted, He2(ge2({}, i5), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit($.sync);
  }
  async onRestart() {
    if (this.cached.length) {
      const e = [...this.cached], t = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let i5 = 0; i5 < t; i5++) {
        const s3 = e.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchSubscribe(s3);
      }
    }
    this.events.emit($.resubscribed);
  }
  async restore() {
    try {
      const e = await this.getRelayerSubscriptions();
      if (typeof e > "u" || !e.length) return;
      if (this.subscriptions.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e);
    }
  }
  async batchSubscribe(e) {
    e.length && (await this.rpcBatchSubscribe(e), this.onBatchSubscribe(await Promise.all(e.map(async (t) => He2(ge2({}, t), { id: await this.getSubscriptionId(t.topic) })))));
  }
  async batchFetchMessages(e) {
    if (!e.length) return;
    this.logger.trace(`Fetching batch messages for ${e.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e);
    t && t.messages && (await Ni((0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), await this.relayer.handleBatchMessageEvents(t.messages));
  }
  async onConnect() {
    await this.restart(), this.reset();
  }
  onDisconnect() {
    this.onDisable();
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async restartToComplete(e) {
    !this.relayer.connected && !this.relayer.connecting && (this.cached.push(e), await this.relayer.transportOpen());
  }
  async getClientId() {
    return this.clientId || (this.clientId = await this.relayer.core.crypto.getClientId()), this.clientId;
  }
  async getSubscriptionId(e) {
    return kc(e + await this.getClientId());
  }
};
var eo2 = Object.defineProperty;
var Ci2 = Object.getOwnPropertySymbols;
var to2 = Object.prototype.hasOwnProperty;
var io2 = Object.prototype.propertyIsEnumerable;
var Ye2 = (r2, e, t) => e in r2 ? eo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Pi3 = (r2, e) => {
  for (var t in e || (e = {})) to2.call(e, t) && Ye2(r2, t, e[t]);
  if (Ci2) for (var t of Ci2(e)) io2.call(e, t) && Ye2(r2, t, e[t]);
  return r2;
};
var y4 = (r2, e, t) => Ye2(r2, typeof e != "symbol" ? e + "" : e, t);
var Si2 = class extends d2 {
  constructor(e) {
    super(e), y4(this, "protocol", "wc"), y4(this, "version", 2), y4(this, "core"), y4(this, "logger"), y4(this, "events", new import_events3.EventEmitter()), y4(this, "provider"), y4(this, "messages"), y4(this, "subscriber"), y4(this, "publisher"), y4(this, "name", $t2), y4(this, "transportExplicitlyClosed", false), y4(this, "initialized", false), y4(this, "connectionAttemptInProgress", false), y4(this, "relayUrl"), y4(this, "projectId"), y4(this, "packageName"), y4(this, "bundleId"), y4(this, "hasExperiencedNetworkDisruption", false), y4(this, "pingTimeout"), y4(this, "heartBeatTimeout", (0, import_time2.toMiliseconds)(import_time2.THIRTY_SECONDS + import_time2.FIVE_SECONDS)), y4(this, "reconnectTimeout"), y4(this, "connectPromise"), y4(this, "reconnectInProgress", false), y4(this, "requestsInFlight", []), y4(this, "connectTimeout", (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND * 15)), y4(this, "request", async (t) => {
      var i5, s3;
      this.logger.debug("Publishing Request Payload");
      const n4 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        this.logger.trace({ id: n4, method: t.method, topic: (i5 = t.params) == null ? void 0 : i5.topic }, "relayer.request - publishing...");
        const o2 = `${n4}:${((s3 = t.params) == null ? void 0 : s3.tag) || ""}`;
        this.requestsInFlight.push(o2);
        const a2 = await this.provider.request(t);
        return this.requestsInFlight = this.requestsInFlight.filter((c6) => c6 !== o2), a2;
      } catch (o2) {
        throw this.logger.debug(`Failed to Publish Request: ${n4}`), o2;
      }
    }), y4(this, "resetPingTimeout", () => {
      _e() && (clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
        var t, i5, s3, n4;
        try {
          this.logger.debug({}, "pingTimeout: Connection stalled, terminating..."), (n4 = (s3 = (i5 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : i5.socket) == null ? void 0 : s3.terminate) == null || n4.call(s3);
        } catch (o2) {
          this.logger.warn(o2, o2 == null ? void 0 : o2.message);
        }
      }, this.heartBeatTimeout));
    }), y4(this, "onPayloadHandler", (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }), y4(this, "onConnectHandler", () => {
      this.logger.warn({}, "Relayer connected "), this.startPingTimeout(), this.events.emit(C3.connect);
    }), y4(this, "onDisconnectHandler", () => {
      this.logger.warn({}, "Relayer disconnected "), this.requestsInFlight = [], this.onProviderDisconnect();
    }), y4(this, "onProviderErrorHandler", (t) => {
      this.logger.fatal(`Fatal socket error: ${t.message}`), this.events.emit(C3.error, t), this.logger.fatal("Fatal socket error received, closing transport"), this.transportClose();
    }), y4(this, "registerProviderListeners", () => {
      this.provider.on(L2.payload, this.onPayloadHandler), this.provider.on(L2.connect, this.onConnectHandler), this.provider.on(L2.disconnect, this.onDisconnectHandler), this.provider.on(L2.error, this.onProviderErrorHandler);
    }), this.core = e.core, this.logger = typeof e.logger < "u" && typeof e.logger != "string" ? E2(e.logger, this.name) : (0, import_pino3.default)(k3({ level: e.logger || Nt2 })), this.messages = new _i2(this.logger, e.core), this.subscriber = new Ti2(this, this.logger), this.publisher = new qn(this, this.logger), this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ue, this.projectId = e.projectId, ei() ? this.packageName = ri() : ni() && (this.bundleId = ri()), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.hasAnyTopics) try {
      await this.transportOpen();
    } catch (e) {
      this.logger.warn(e, e == null ? void 0 : e.message);
    }
  }
  get context() {
    return y2(this.logger);
  }
  get connected() {
    var e, t, i5;
    return ((i5 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i5.readyState) === 1 || false;
  }
  get connecting() {
    var e, t, i5;
    return ((i5 = (t = (e = this.provider) == null ? void 0 : e.connection) == null ? void 0 : t.socket) == null ? void 0 : i5.readyState) === 0 || this.connectPromise !== void 0 || false;
  }
  async publish(e, t, i5) {
    this.isInitialized(), await this.publisher.publish(e, t, i5), await this.recordMessageEvent({ topic: e, message: t, publishedAt: Date.now(), transportType: Q.relay }, le2.outbound);
  }
  async subscribe(e, t) {
    var i5, s3, n4;
    this.isInitialized(), (!(t != null && t.transportType) || (t == null ? void 0 : t.transportType) === "relay") && await this.toEstablishConnection();
    const o2 = typeof ((i5 = t == null ? void 0 : t.internal) == null ? void 0 : i5.throwOnFailedPublish) > "u" ? true : (s3 = t == null ? void 0 : t.internal) == null ? void 0 : s3.throwOnFailedPublish;
    let a2 = ((n4 = this.subscriber.topicMap.get(e)) == null ? void 0 : n4[0]) || "", c6;
    const h6 = (l6) => {
      l6.topic === e && (this.subscriber.off($.created, h6), c6());
    };
    return await Promise.all([new Promise((l6) => {
      c6 = l6, this.subscriber.on($.created, h6);
    }), new Promise(async (l6, d4) => {
      a2 = await this.subscriber.subscribe(e, Pi3({ internal: { throwOnFailedPublish: o2 } }, t)).catch((g3) => {
        o2 && d4(g3);
      }) || a2, l6();
    })]), a2;
  }
  async unsubscribe(e, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e, t);
  }
  on(e, t) {
    this.events.on(e, t);
  }
  once(e, t) {
    this.events.once(e, t);
  }
  off(e, t) {
    this.events.off(e, t);
  }
  removeListener(e, t) {
    this.events.removeListener(e, t);
  }
  async transportDisconnect() {
    this.provider.disconnect && (this.hasExperiencedNetworkDisruption || this.connected) ? await yi(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e) {
    if (!this.subscriber.hasAnyTopics) {
      this.logger.warn("Starting WS connection skipped because the client has no topics to work with.");
      return;
    }
    if (this.connectPromise ? (this.logger.debug({}, "Waiting for existing connection attempt to resolve..."), await this.connectPromise, this.logger.debug({}, "Existing connection attempt resolved")) : (this.connectPromise = new Promise(async (t, i5) => {
      await this.connect(e).then(t).catch(i5).finally(() => {
        this.connectPromise = void 0;
      });
    }), await this.connectPromise), !this.connected) throw new Error(`Couldn't establish socket connection to the relay server: ${this.relayUrl}`);
  }
  async restartTransport(e) {
    this.logger.debug({}, "Restarting transport..."), !this.connectionAttemptInProgress && (this.relayUrl = e || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Na()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e) {
    if ((e == null ? void 0 : e.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e.sort((i5, s3) => i5.publishedAt - s3.publishedAt);
    this.logger.debug(`Batch of ${t.length} message events sorted`);
    for (const i5 of t) try {
      await this.onMessageEvent(i5);
    } catch (s3) {
      this.logger.warn(s3, "Error while processing batch message event: " + (s3 == null ? void 0 : s3.message));
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e, t) {
    const { topic: i5 } = e;
    if (!t.sessionExists) {
      const s3 = Ei(import_time2.FIVE_MINUTES), n4 = { topic: i5, expiry: s3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(i5, n4);
    }
    this.events.emit(C3.message, e), await this.recordMessageEvent(e, le2.inbound);
  }
  async connect(e) {
    await this.confirmOnlineStateOrThrow(), e && e !== this.relayUrl && (this.relayUrl = e, await this.transportDisconnect()), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    let t = 1;
    for (; t < 6; ) {
      try {
        if (this.transportExplicitlyClosed) break;
        this.logger.debug({}, `Connecting to ${this.relayUrl}, attempt: ${t}...`), await this.createProvider(), await new Promise(async (i5, s3) => {
          const n4 = () => {
            s3(new Error("Connection interrupted while trying to subscribe"));
          };
          this.provider.once(L2.disconnect, n4), await yi(new Promise((o2, a2) => {
            this.provider.connect().then(o2).catch(a2);
          }), this.connectTimeout, `Socket stalled when trying to connect to ${this.relayUrl}`).catch((o2) => {
            s3(o2);
          }).finally(() => {
            this.provider.off(L2.disconnect, n4), clearTimeout(this.reconnectTimeout);
          }), await new Promise(async (o2, a2) => {
            const c6 = () => {
              a2(new Error("Connection interrupted while trying to subscribe"));
            };
            this.provider.once(L2.disconnect, c6), await this.subscriber.start().then(o2).catch(a2).finally(() => {
              this.provider.off(L2.disconnect, c6);
            });
          }), this.hasExperiencedNetworkDisruption = false, i5();
        });
      } catch (i5) {
        await this.subscriber.stop();
        const s3 = i5;
        this.logger.warn({}, s3.message), this.hasExperiencedNetworkDisruption = true;
      } finally {
        this.connectionAttemptInProgress = false;
      }
      if (this.connected) {
        this.logger.debug({}, `Connected to ${this.relayUrl} successfully on attempt: ${t}`);
        break;
      }
      await new Promise((i5) => setTimeout(i5, (0, import_time2.toMiliseconds)(t * 1))), t++;
    }
  }
  startPingTimeout() {
    var e, t, i5, s3, n4;
    if (_e()) try {
      (t = (e = this.provider) == null ? void 0 : e.connection) != null && t.socket && ((n4 = (s3 = (i5 = this.provider) == null ? void 0 : i5.connection) == null ? void 0 : s3.socket) == null || n4.on("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (o2) {
      this.logger.warn(o2, o2 == null ? void 0 : o2.message);
    }
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o(new f(si({ sdkVersion: _e2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e, useOnCloseEvent: true, bundleId: this.bundleId, packageName: this.packageName }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e, t) {
    const { topic: i5, message: s3 } = e;
    await this.messages.set(i5, s3, t);
  }
  async shouldIgnoreMessageEvent(e) {
    const { topic: t, message: i5 } = e;
    if (!i5 || i5.length === 0) return this.logger.warn(`Ignoring invalid/empty message: ${i5}`), true;
    if (!await this.subscriber.isKnownTopic(t)) return this.logger.warn(`Ignoring message for unknown topic ${t}`), true;
    const s3 = this.messages.has(t, i5);
    return s3 && this.logger.warn(`Ignoring duplicate message: ${i5}`), s3;
  }
  async onProviderPayload(e) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e }), isJsonRpcRequest(e)) {
      if (!e.method.endsWith(zt)) return;
      const t = e.params, { topic: i5, message: s3, publishedAt: n4, attestation: o2 } = t.data, a2 = { topic: i5, message: s3, publishedAt: n4, transportType: Q.relay, attestation: o2 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Pi3({ type: "event", event: t.id }, a2)), this.events.emit(t.id, a2), await this.acknowledgePayload(e), await this.onMessageEvent(a2);
    } else isJsonRpcResponse(e) && this.events.emit(C3.message_ack, e);
  }
  async onMessageEvent(e) {
    await this.shouldIgnoreMessageEvent(e) || (await this.recordMessageEvent(e, le2.inbound), this.events.emit(C3.message, e));
  }
  async acknowledgePayload(e) {
    const t = formatJsonRpcResult(e.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(L2.payload, this.onPayloadHandler), this.provider.off(L2.connect, this.onConnectHandler), this.provider.off(L2.disconnect, this.onDisconnectHandler), this.provider.off(L2.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e = await Na();
    Ua(async (t) => {
      e !== t && (e = t, t ? await this.transportOpen().catch((i5) => this.logger.error(i5, i5 == null ? void 0 : i5.message)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    }), this.core.heartbeat.on(r.pulse, async () => {
      if (!this.transportExplicitlyClosed && !this.connected && Ta()) try {
        await this.confirmOnlineStateOrThrow(), await this.transportOpen();
      } catch (t) {
        this.logger.warn(t, t == null ? void 0 : t.message);
      }
    });
  }
  async onProviderDisconnect() {
    clearTimeout(this.pingTimeout), this.events.emit(C3.disconnect), this.connectionAttemptInProgress = false, !this.reconnectInProgress && (this.reconnectInProgress = true, await this.subscriber.stop(), this.subscriber.hasAnyTopics && (this.transportExplicitlyClosed || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e) => this.logger.error(e, e == null ? void 0 : e.message)), this.reconnectTimeout = void 0, this.reconnectInProgress = false;
    }, (0, import_time2.toMiliseconds)(Lt2)))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  async toEstablishConnection() {
    if (await this.confirmOnlineStateOrThrow(), !this.connected) {
      if (this.connectPromise) {
        await this.connectPromise;
        return;
      }
      await this.connect();
    }
  }
};
function so2() {
}
function Oi2(r2) {
  if (!r2 || typeof r2 != "object") return false;
  const e = Object.getPrototypeOf(r2);
  return e === null || e === Object.prototype || Object.getPrototypeOf(e) === null ? Object.prototype.toString.call(r2) === "[object Object]" : false;
}
function Ri2(r2) {
  return Object.getOwnPropertySymbols(r2).filter((e) => Object.prototype.propertyIsEnumerable.call(r2, e));
}
function Ai2(r2) {
  return r2 == null ? r2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(r2);
}
var ro2 = "[object RegExp]";
var no2 = "[object String]";
var oo2 = "[object Number]";
var ao2 = "[object Boolean]";
var xi2 = "[object Arguments]";
var co2 = "[object Symbol]";
var ho2 = "[object Date]";
var lo2 = "[object Map]";
var uo2 = "[object Set]";
var go2 = "[object Array]";
var po2 = "[object Function]";
var yo2 = "[object ArrayBuffer]";
var Je2 = "[object Object]";
var bo2 = "[object Error]";
var mo2 = "[object DataView]";
var fo2 = "[object Uint8Array]";
var Do = "[object Uint8ClampedArray]";
var vo2 = "[object Uint16Array]";
var wo2 = "[object Uint32Array]";
var _o2 = "[object BigUint64Array]";
var Eo2 = "[object Int8Array]";
var Io2 = "[object Int16Array]";
var To2 = "[object Int32Array]";
var Co2 = "[object BigInt64Array]";
var Po3 = "[object Float32Array]";
var So2 = "[object Float64Array]";
function Oo2(r2, e) {
  return r2 === e || Number.isNaN(r2) && Number.isNaN(e);
}
function Ro2(r2, e, t) {
  return pe2(r2, e, void 0, void 0, void 0, void 0, t);
}
function pe2(r2, e, t, i5, s3, n4, o2) {
  const a2 = o2(r2, e, t, i5, s3, n4);
  if (a2 !== void 0) return a2;
  if (typeof r2 == typeof e) switch (typeof r2) {
    case "bigint":
    case "string":
    case "boolean":
    case "symbol":
    case "undefined":
      return r2 === e;
    case "number":
      return r2 === e || Object.is(r2, e);
    case "function":
      return r2 === e;
    case "object":
      return ye2(r2, e, n4, o2);
  }
  return ye2(r2, e, n4, o2);
}
function ye2(r2, e, t, i5) {
  if (Object.is(r2, e)) return true;
  let s3 = Ai2(r2), n4 = Ai2(e);
  if (s3 === xi2 && (s3 = Je2), n4 === xi2 && (n4 = Je2), s3 !== n4) return false;
  switch (s3) {
    case no2:
      return r2.toString() === e.toString();
    case oo2: {
      const c6 = r2.valueOf(), h6 = e.valueOf();
      return Oo2(c6, h6);
    }
    case ao2:
    case ho2:
    case co2:
      return Object.is(r2.valueOf(), e.valueOf());
    case ro2:
      return r2.source === e.source && r2.flags === e.flags;
    case po2:
      return r2 === e;
  }
  t = t ?? /* @__PURE__ */ new Map();
  const o2 = t.get(r2), a2 = t.get(e);
  if (o2 != null && a2 != null) return o2 === e;
  t.set(r2, e), t.set(e, r2);
  try {
    switch (s3) {
      case lo2: {
        if (r2.size !== e.size) return false;
        for (const [c6, h6] of r2.entries()) if (!e.has(c6) || !pe2(h6, e.get(c6), c6, r2, e, t, i5)) return false;
        return true;
      }
      case uo2: {
        if (r2.size !== e.size) return false;
        const c6 = Array.from(r2.values()), h6 = Array.from(e.values());
        for (let l6 = 0; l6 < c6.length; l6++) {
          const d4 = c6[l6], g3 = h6.findIndex((_5) => pe2(d4, _5, void 0, r2, e, t, i5));
          if (g3 === -1) return false;
          h6.splice(g3, 1);
        }
        return true;
      }
      case go2:
      case fo2:
      case Do:
      case vo2:
      case wo2:
      case _o2:
      case Eo2:
      case Io2:
      case To2:
      case Co2:
      case Po3:
      case So2: {
        if (typeof Buffer < "u" && Buffer.isBuffer(r2) !== Buffer.isBuffer(e) || r2.length !== e.length) return false;
        for (let c6 = 0; c6 < r2.length; c6++) if (!pe2(r2[c6], e[c6], c6, r2, e, t, i5)) return false;
        return true;
      }
      case yo2:
        return r2.byteLength !== e.byteLength ? false : ye2(new Uint8Array(r2), new Uint8Array(e), t, i5);
      case mo2:
        return r2.byteLength !== e.byteLength || r2.byteOffset !== e.byteOffset ? false : ye2(new Uint8Array(r2), new Uint8Array(e), t, i5);
      case bo2:
        return r2.name === e.name && r2.message === e.message;
      case Je2: {
        if (!(ye2(r2.constructor, e.constructor, t, i5) || Oi2(r2) && Oi2(e))) return false;
        const h6 = [...Object.keys(r2), ...Ri2(r2)], l6 = [...Object.keys(e), ...Ri2(e)];
        if (h6.length !== l6.length) return false;
        for (let d4 = 0; d4 < h6.length; d4++) {
          const g3 = h6[d4], _5 = r2[g3];
          if (!Object.hasOwn(e, g3)) return false;
          const u3 = e[g3];
          if (!pe2(_5, u3, g3, r2, e, t, i5)) return false;
        }
        return true;
      }
      default:
        return false;
    }
  } finally {
    t.delete(r2), t.delete(e);
  }
}
function Ao2(r2, e) {
  return Ro2(r2, e, so2);
}
var xo2 = Object.defineProperty;
var Ni2 = Object.getOwnPropertySymbols;
var No2 = Object.prototype.hasOwnProperty;
var $o2 = Object.prototype.propertyIsEnumerable;
var Xe2 = (r2, e, t) => e in r2 ? xo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var $i2 = (r2, e) => {
  for (var t in e || (e = {})) No2.call(e, t) && Xe2(r2, t, e[t]);
  if (Ni2) for (var t of Ni2(e)) $o2.call(e, t) && Xe2(r2, t, e[t]);
  return r2;
};
var z3 = (r2, e, t) => Xe2(r2, typeof e != "symbol" ? e + "" : e, t);
var zi2 = class extends f5 {
  constructor(e, t, i5, s3 = B2, n4 = void 0) {
    super(e, t, i5, s3), this.core = e, this.logger = t, this.name = i5, z3(this, "map", /* @__PURE__ */ new Map()), z3(this, "version", kt2), z3(this, "cached", []), z3(this, "initialized", false), z3(this, "getKey"), z3(this, "storagePrefix", B2), z3(this, "recentlyDeleted", []), z3(this, "recentlyDeletedLimit", 200), z3(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o2) => {
        this.getKey && o2 !== null && !Et(o2) ? this.map.set(this.getKey(o2), o2) : la(o2) ? this.map.set(o2.id, o2) : da(o2) && this.map.set(o2.topic, o2);
      }), this.cached = [], this.initialized = true);
    }), z3(this, "set", async (o2, a2) => {
      this.isInitialized(), this.map.has(o2) ? await this.update(o2, a2) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o2, value: a2 }), this.map.set(o2, a2), await this.persist());
    }), z3(this, "get", (o2) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o2 }), this.getData(o2))), z3(this, "getAll", (o2) => (this.isInitialized(), o2 ? this.values.filter((a2) => Object.keys(o2).every((c6) => Ao2(a2[c6], o2[c6]))) : this.values)), z3(this, "update", async (o2, a2) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o2, update: a2 });
      const c6 = $i2($i2({}, this.getData(o2)), a2);
      this.map.set(o2, c6), await this.persist();
    }), z3(this, "delete", async (o2, a2) => {
      this.isInitialized(), this.map.has(o2) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o2, reason: a2 }), this.map.delete(o2), this.addToRecentlyDeleted(o2), await this.persist());
    }), this.logger = E2(t, this.name), this.storagePrefix = s3, this.getKey = n4;
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e) {
    this.recentlyDeleted.push(e), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e) {
    const t = this.map.get(e);
    if (!t) {
      if (this.recentlyDeleted.includes(e)) {
        const { message: s3 } = ht("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e}`);
        throw this.logger.error(s3), new Error(s3);
      }
      const { message: i5 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.error(i5), new Error(i5);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e = await this.getDataStore();
      if (typeof e > "u" || !e.length) return;
      if (this.map.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var zo = Object.defineProperty;
var Lo2 = (r2, e, t) => e in r2 ? zo(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var p3 = (r2, e, t) => Lo2(r2, typeof e != "symbol" ? e + "" : e, t);
var Li2 = class {
  constructor(e, t) {
    this.core = e, this.logger = t, p3(this, "name", Mt2), p3(this, "version", Kt2), p3(this, "events", new import_events3.default()), p3(this, "pairings"), p3(this, "initialized", false), p3(this, "storagePrefix", B2), p3(this, "ignoredPayloadTypes", [Ft]), p3(this, "registeredMethods", []), p3(this, "init", async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }), p3(this, "register", ({ methods: i5 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i5])];
    }), p3(this, "create", async (i5) => {
      this.isInitialized();
      const s3 = jc(), n4 = await this.core.crypto.setSymKey(s3), o2 = Ei(import_time2.FIVE_MINUTES), a2 = { protocol: xt2 }, c6 = { topic: n4, expiry: o2, relay: a2, active: false, methods: i5 == null ? void 0 : i5.methods }, h6 = Wc({ protocol: this.core.protocol, version: this.core.version, topic: n4, symKey: s3, relay: a2, expiryTimestamp: o2, methods: i5 == null ? void 0 : i5.methods });
      return this.events.emit(re2.create, c6), this.core.expirer.set(n4, o2), await this.pairings.set(n4, c6), await this.core.relayer.subscribe(n4, { transportType: i5 == null ? void 0 : i5.transportType }), { topic: n4, uri: h6 };
    }), p3(this, "pair", async (i5) => {
      this.isInitialized();
      const s3 = this.core.eventClient.createEvent({ properties: { topic: i5 == null ? void 0 : i5.uri, trace: [G2.pairing_started] } });
      this.isValidPair(i5, s3);
      const { topic: n4, symKey: o2, relay: a2, expiryTimestamp: c6, methods: h6 } = Gc(i5.uri);
      s3.props.properties.topic = n4, s3.addTrace(G2.pairing_uri_validation_success), s3.addTrace(G2.pairing_uri_not_expired);
      let l6;
      if (this.pairings.keys.includes(n4)) {
        if (l6 = this.pairings.get(n4), s3.addTrace(G2.existing_pairing), l6.active) throw s3.setError(Y2.active_pairing_already_exists), new Error(`Pairing already exists: ${n4}. Please try again with a new connection URI.`);
        s3.addTrace(G2.pairing_not_expired);
      }
      const d4 = c6 || Ei(import_time2.FIVE_MINUTES), g3 = { topic: n4, relay: a2, expiry: d4, active: false, methods: h6 };
      this.core.expirer.set(n4, d4), await this.pairings.set(n4, g3), s3.addTrace(G2.store_new_pairing), i5.activatePairing && await this.activate({ topic: n4 }), this.events.emit(re2.create, g3), s3.addTrace(G2.emit_inactive_pairing), this.core.crypto.keychain.has(n4) || await this.core.crypto.setSymKey(o2, n4), s3.addTrace(G2.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        s3.setError(Y2.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(n4, { relay: a2 });
      } catch (_5) {
        throw s3.setError(Y2.subscribe_pairing_topic_failure), _5;
      }
      return s3.addTrace(G2.subscribe_pairing_topic_success), g3;
    }), p3(this, "activate", async ({ topic: i5 }) => {
      this.isInitialized();
      const s3 = Ei(import_time2.FIVE_MINUTES);
      this.core.expirer.set(i5, s3), await this.pairings.update(i5, { active: true, expiry: s3 });
    }), p3(this, "ping", async (i5) => {
      this.isInitialized(), await this.isValidPing(i5), this.logger.warn("ping() is deprecated and will be removed in the next major release.");
      const { topic: s3 } = i5;
      if (this.pairings.keys.includes(s3)) {
        const n4 = await this.sendRequest(s3, "wc_pairingPing", {}), { done: o2, resolve: a2, reject: c6 } = gi();
        this.events.once(xi("pairing_ping", n4), ({ error: h6 }) => {
          h6 ? c6(h6) : a2();
        }), await o2();
      }
    }), p3(this, "updateExpiry", async ({ topic: i5, expiry: s3 }) => {
      this.isInitialized(), await this.pairings.update(i5, { expiry: s3 });
    }), p3(this, "updateMetadata", async ({ topic: i5, metadata: s3 }) => {
      this.isInitialized(), await this.pairings.update(i5, { peerMetadata: s3 });
    }), p3(this, "getPairings", () => (this.isInitialized(), this.pairings.values)), p3(this, "disconnect", async (i5) => {
      this.isInitialized(), await this.isValidDisconnect(i5);
      const { topic: s3 } = i5;
      this.pairings.keys.includes(s3) && (await this.sendRequest(s3, "wc_pairingDelete", Nt("USER_DISCONNECTED")), await this.deletePairing(s3));
    }), p3(this, "formatUriFromPairing", (i5) => {
      this.isInitialized();
      const { topic: s3, relay: n4, expiry: o2, methods: a2 } = i5, c6 = this.core.crypto.keychain.get(s3);
      return Wc({ protocol: this.core.protocol, version: this.core.version, topic: s3, symKey: c6, relay: n4, expiryTimestamp: o2, methods: a2 });
    }), p3(this, "sendRequest", async (i5, s3, n4) => {
      const o2 = formatJsonRpcRequest(s3, n4), a2 = await this.core.crypto.encode(i5, o2), c6 = se2[s3].req;
      return this.core.history.set(i5, o2), this.core.relayer.publish(i5, a2, c6), o2.id;
    }), p3(this, "sendResult", async (i5, s3, n4) => {
      const o2 = formatJsonRpcResult(i5, n4), a2 = await this.core.crypto.encode(s3, o2), c6 = (await this.core.history.get(s3, i5)).request.method, h6 = se2[c6].res;
      await this.core.relayer.publish(s3, a2, h6), await this.core.history.resolve(o2);
    }), p3(this, "sendError", async (i5, s3, n4) => {
      const o2 = formatJsonRpcError(i5, n4), a2 = await this.core.crypto.encode(s3, o2), c6 = (await this.core.history.get(s3, i5)).request.method, h6 = se2[c6] ? se2[c6].res : se2.unregistered_method.res;
      await this.core.relayer.publish(s3, a2, h6), await this.core.history.resolve(o2);
    }), p3(this, "deletePairing", async (i5, s3) => {
      await this.core.relayer.unsubscribe(i5), await Promise.all([this.pairings.delete(i5, Nt("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i5), s3 ? Promise.resolve() : this.core.expirer.del(i5)]);
    }), p3(this, "cleanup", async () => {
      const i5 = this.pairings.getAll().filter((s3) => vi(s3.expiry));
      await Promise.all(i5.map((s3) => this.deletePairing(s3.topic)));
    }), p3(this, "onRelayEventRequest", async (i5) => {
      const { topic: s3, payload: n4 } = i5;
      switch (n4.method) {
        case "wc_pairingPing":
          return await this.onPairingPingRequest(s3, n4);
        case "wc_pairingDelete":
          return await this.onPairingDeleteRequest(s3, n4);
        default:
          return await this.onUnknownRpcMethodRequest(s3, n4);
      }
    }), p3(this, "onRelayEventResponse", async (i5) => {
      const { topic: s3, payload: n4 } = i5, o2 = (await this.core.history.get(s3, n4.id)).request.method;
      switch (o2) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(s3, n4);
        default:
          return this.onUnknownRpcMethodResponse(o2);
      }
    }), p3(this, "onPairingPingRequest", async (i5, s3) => {
      const { id: n4 } = s3;
      try {
        this.isValidPing({ topic: i5 }), await this.sendResult(n4, i5, true), this.events.emit(re2.ping, { id: n4, topic: i5 });
      } catch (o2) {
        await this.sendError(n4, i5, o2), this.logger.error(o2);
      }
    }), p3(this, "onPairingPingResponse", (i5, s3) => {
      const { id: n4 } = s3;
      setTimeout(() => {
        isJsonRpcResult(s3) ? this.events.emit(xi("pairing_ping", n4), {}) : isJsonRpcError(s3) && this.events.emit(xi("pairing_ping", n4), { error: s3.error });
      }, 500);
    }), p3(this, "onPairingDeleteRequest", async (i5, s3) => {
      const { id: n4 } = s3;
      try {
        this.isValidDisconnect({ topic: i5 }), await this.deletePairing(i5), this.events.emit(re2.delete, { id: n4, topic: i5 });
      } catch (o2) {
        await this.sendError(n4, i5, o2), this.logger.error(o2);
      }
    }), p3(this, "onUnknownRpcMethodRequest", async (i5, s3) => {
      const { id: n4, method: o2 } = s3;
      try {
        if (this.registeredMethods.includes(o2)) return;
        const a2 = Nt("WC_METHOD_UNSUPPORTED", o2);
        await this.sendError(n4, i5, a2), this.logger.error(a2);
      } catch (a2) {
        await this.sendError(n4, i5, a2), this.logger.error(a2);
      }
    }), p3(this, "onUnknownRpcMethodResponse", (i5) => {
      this.registeredMethods.includes(i5) || this.logger.error(Nt("WC_METHOD_UNSUPPORTED", i5));
    }), p3(this, "isValidPair", (i5, s3) => {
      var n4;
      if (!ma(i5)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `pair() params: ${i5}`);
        throw s3.setError(Y2.malformed_pairing_uri), new Error(a2);
      }
      if (!fa(i5.uri)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `pair() uri: ${i5.uri}`);
        throw s3.setError(Y2.malformed_pairing_uri), new Error(a2);
      }
      const o2 = Gc(i5 == null ? void 0 : i5.uri);
      if (!((n4 = o2 == null ? void 0 : o2.relay) != null && n4.protocol)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw s3.setError(Y2.malformed_pairing_uri), new Error(a2);
      }
      if (!(o2 != null && o2.symKey)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", "pair() uri#symKey");
        throw s3.setError(Y2.malformed_pairing_uri), new Error(a2);
      }
      if (o2 != null && o2.expiryTimestamp && (0, import_time2.toMiliseconds)(o2 == null ? void 0 : o2.expiryTimestamp) < Date.now()) {
        s3.setError(Y2.pairing_expired);
        const { message: a2 } = ht("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a2);
      }
    }), p3(this, "isValidPing", async (i5) => {
      if (!ma(i5)) {
        const { message: n4 } = ht("MISSING_OR_INVALID", `ping() params: ${i5}`);
        throw new Error(n4);
      }
      const { topic: s3 } = i5;
      await this.isValidPairingTopic(s3);
    }), p3(this, "isValidDisconnect", async (i5) => {
      if (!ma(i5)) {
        const { message: n4 } = ht("MISSING_OR_INVALID", `disconnect() params: ${i5}`);
        throw new Error(n4);
      }
      const { topic: s3 } = i5;
      await this.isValidPairingTopic(s3);
    }), p3(this, "isValidPairingTopic", async (i5) => {
      if (!nt(i5, false)) {
        const { message: s3 } = ht("MISSING_OR_INVALID", `pairing topic should be a string: ${i5}`);
        throw new Error(s3);
      }
      if (!this.pairings.keys.includes(i5)) {
        const { message: s3 } = ht("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i5}`);
        throw new Error(s3);
      }
      if (vi(this.pairings.get(i5).expiry)) {
        await this.deletePairing(i5);
        const { message: s3 } = ht("EXPIRED", `pairing topic: ${i5}`);
        throw new Error(s3);
      }
    }), this.core = e, this.logger = E2(t, this.name), this.pairings = new zi2(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y2(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(C3.message, async (e) => {
      const { topic: t, message: i5, transportType: s3 } = e;
      if (this.pairings.keys.includes(t) && s3 !== Q.link_mode && !this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i5))) try {
        const n4 = await this.core.crypto.decode(t, i5);
        isJsonRpcRequest(n4) ? (this.core.history.set(t, n4), await this.onRelayEventRequest({ topic: t, payload: n4 })) : isJsonRpcResponse(n4) && (await this.core.history.resolve(n4), await this.onRelayEventResponse({ topic: t, payload: n4 }), this.core.history.delete(t, n4.id)), await this.core.relayer.messages.ack(t, i5);
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(M2.expired, async (e) => {
      const { topic: t } = bi(e.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(re2.expire, { topic: t }));
    });
  }
};
var ko = Object.defineProperty;
var jo = (r2, e, t) => e in r2 ? ko(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var O4 = (r2, e, t) => jo(r2, typeof e != "symbol" ? e + "" : e, t);
var ki2 = class extends I2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, O4(this, "records", /* @__PURE__ */ new Map()), O4(this, "events", new import_events3.EventEmitter()), O4(this, "name", Bt2), O4(this, "version", Vt2), O4(this, "cached", []), O4(this, "initialized", false), O4(this, "storagePrefix", B2), O4(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i5) => this.records.set(i5.id, i5)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), O4(this, "set", (i5, s3, n4) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i5, request: s3, chainId: n4 }), this.records.has(s3.id)) return;
      const o2 = { id: s3.id, topic: i5, request: { method: s3.method, params: s3.params || null }, chainId: n4, expiry: Ei(import_time2.THIRTY_DAYS) };
      this.records.set(o2.id, o2), this.persist(), this.events.emit(F2.created, o2);
    }), O4(this, "resolve", async (i5) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i5 }), !this.records.has(i5.id)) return;
      const s3 = await this.getRecord(i5.id);
      typeof s3.response > "u" && (s3.response = isJsonRpcError(i5) ? { error: i5.error } : { result: i5.result }, this.records.set(s3.id, s3), this.persist(), this.events.emit(F2.updated, s3));
    }), O4(this, "get", async (i5, s3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i5, id: s3 }), await this.getRecord(s3))), O4(this, "delete", (i5, s3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s3 }), this.values.forEach((n4) => {
        if (n4.topic === i5) {
          if (typeof s3 < "u" && n4.id !== s3) return;
          this.records.delete(n4.id), this.events.emit(F2.deleted, n4);
        }
      }), this.persist();
    }), O4(this, "exists", async (i5, s3) => (this.isInitialized(), this.records.has(s3) ? (await this.getRecord(s3)).topic === i5 : false)), O4(this, "on", (i5, s3) => {
      this.events.on(i5, s3);
    }), O4(this, "once", (i5, s3) => {
      this.events.once(i5, s3);
    }), O4(this, "off", (i5, s3) => {
      this.events.off(i5, s3);
    }), O4(this, "removeListener", (i5, s3) => {
      this.events.removeListener(i5, s3);
    }), this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const i5 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e.push(i5);
    }), e;
  }
  async setJsonRpcRecords(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e) {
    this.isInitialized();
    const t = this.records.get(e);
    if (!t) {
      const { message: i5 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw new Error(i5);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(F2.sync);
  }
  async restore() {
    try {
      const e = await this.getJsonRpcRecords();
      if (typeof e > "u" || !e.length) return;
      if (this.records.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e);
    }
  }
  registerEventListeners() {
    this.events.on(F2.created, (e) => {
      const t = F2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F2.updated, (e) => {
      const t = F2.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.events.on(F2.deleted, (e) => {
      const t = F2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e = false;
      this.records.forEach((t) => {
        (0, import_time2.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(F2.deleted, t, false), e = true);
      }), e && this.persist();
    } catch (e) {
      this.logger.warn(e);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Uo2 = Object.defineProperty;
var Fo = (r2, e, t) => e in r2 ? Uo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var A2 = (r2, e, t) => Fo(r2, typeof e != "symbol" ? e + "" : e, t);
var ji2 = class extends S2 {
  constructor(e, t) {
    super(e, t), this.core = e, this.logger = t, A2(this, "expirations", /* @__PURE__ */ new Map()), A2(this, "events", new import_events3.EventEmitter()), A2(this, "name", qt2), A2(this, "version", Gt), A2(this, "cached", []), A2(this, "initialized", false), A2(this, "storagePrefix", B2), A2(this, "init", async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i5) => this.expirations.set(i5.target, i5)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }), A2(this, "has", (i5) => {
      try {
        const s3 = this.formatTarget(i5);
        return typeof this.getExpiration(s3) < "u";
      } catch {
        return false;
      }
    }), A2(this, "set", (i5, s3) => {
      this.isInitialized();
      const n4 = this.formatTarget(i5), o2 = { target: n4, expiry: s3 };
      this.expirations.set(n4, o2), this.checkExpiry(n4, o2), this.events.emit(M2.created, { target: n4, expiration: o2 });
    }), A2(this, "get", (i5) => {
      this.isInitialized();
      const s3 = this.formatTarget(i5);
      return this.getExpiration(s3);
    }), A2(this, "del", (i5) => {
      if (this.isInitialized(), this.has(i5)) {
        const s3 = this.formatTarget(i5), n4 = this.getExpiration(s3);
        this.expirations.delete(s3), this.events.emit(M2.deleted, { target: s3, expiration: n4 });
      }
    }), A2(this, "on", (i5, s3) => {
      this.events.on(i5, s3);
    }), A2(this, "once", (i5, s3) => {
      this.events.once(i5, s3);
    }), A2(this, "off", (i5, s3) => {
      this.events.off(i5, s3);
    }), A2(this, "removeListener", (i5, s3) => {
      this.events.removeListener(i5, s3);
    }), this.logger = E2(t, this.name);
  }
  get context() {
    return y2(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e) {
    if (typeof e == "string") return mi(e);
    if (typeof e == "number") return wi(e);
    const { message: t } = ht("UNKNOWN_TYPE", `Target type: ${typeof e}`);
    throw new Error(t);
  }
  async setExpirations(e) {
    await this.core.storage.setItem(this.storageKey, e);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(M2.sync);
  }
  async restore() {
    try {
      const e = await this.getExpirations();
      if (typeof e > "u" || !e.length) return;
      if (this.expirations.size) {
        const { message: t } = ht("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e);
    }
  }
  getExpiration(e) {
    const t = this.expirations.get(e);
    if (!t) {
      const { message: i5 } = ht("NO_MATCHING_KEY", `${this.name}: ${e}`);
      throw this.logger.warn(i5), new Error(i5);
    }
    return t;
  }
  checkExpiry(e, t) {
    const { expiry: i5 } = t;
    (0, import_time2.toMiliseconds)(i5) - Date.now() <= 0 && this.expire(e, t);
  }
  expire(e, t) {
    this.expirations.delete(e), this.events.emit(M2.expired, { target: e, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e, t) => this.checkExpiry(t, e));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(M2.created, (e) => {
      const t = M2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M2.expired, (e) => {
      const t = M2.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    }), this.events.on(M2.deleted, (e) => {
      const t = M2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e } = ht("NOT_INITIALIZED", this.name);
      throw new Error(e);
    }
  }
};
var Mo = Object.defineProperty;
var Ko2 = (r2, e, t) => e in r2 ? Mo(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var w2 = (r2, e, t) => Ko2(r2, typeof e != "symbol" ? e + "" : e, t);
var Ui2 = class extends M {
  constructor(e, t, i5) {
    super(e, t, i5), this.core = e, this.logger = t, this.store = i5, w2(this, "name", Wt2), w2(this, "abortController"), w2(this, "isDevEnv"), w2(this, "verifyUrlV3", Yt2), w2(this, "storagePrefix", B2), w2(this, "version", Le), w2(this, "publicKey"), w2(this, "fetchPromise"), w2(this, "init", async () => {
      var s3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time2.toMiliseconds)((s3 = this.publicKey) == null ? void 0 : s3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }), w2(this, "register", async (s3) => {
      if (!Tt() || this.isDevEnv) return;
      const n4 = window.location.origin, { id: o2, decryptedId: a2 } = s3, c6 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${n4}&id=${o2}&decryptedId=${a2}`;
      try {
        const h6 = (0, import_window_getters2.getDocument)(), l6 = this.startAbortTimer(import_time2.ONE_SECOND * 5), d4 = await new Promise((g3, _5) => {
          const u3 = () => {
            window.removeEventListener("message", x5), h6.body.removeChild(b7), _5("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", u3);
          const b7 = h6.createElement("iframe");
          b7.src = c6, b7.style.display = "none", b7.addEventListener("error", u3, { signal: this.abortController.signal });
          const x5 = (I5) => {
            if (I5.data && typeof I5.data == "string") try {
              const D4 = JSON.parse(I5.data);
              if (D4.type === "verify_attestation") {
                if (sn(D4.attestation).payload.id !== o2) return;
                clearInterval(l6), h6.body.removeChild(b7), this.abortController.signal.removeEventListener("abort", u3), window.removeEventListener("message", x5), g3(D4.attestation === null ? "" : D4.attestation);
              }
            } catch (D4) {
              this.logger.warn(D4);
            }
          };
          h6.body.appendChild(b7), window.addEventListener("message", x5, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", d4), d4;
      } catch (h6) {
        this.logger.warn(h6);
      }
      return "";
    }), w2(this, "resolve", async (s3) => {
      if (this.isDevEnv) return "";
      const { attestationId: n4, hash: o2, encryptedId: a2 } = s3;
      if (n4 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (n4) {
        if (sn(n4).payload.id !== a2) return;
        const h6 = await this.isValidJwtAttestation(n4);
        if (h6) {
          if (!h6.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h6;
        }
      }
      if (!o2) return;
      const c6 = this.getVerifyUrl(s3 == null ? void 0 : s3.verifyUrl);
      return this.fetchAttestation(o2, c6);
    }), w2(this, "fetchAttestation", async (s3, n4) => {
      this.logger.debug(`resolving attestation: ${s3} from url: ${n4}`);
      const o2 = this.startAbortTimer(import_time2.ONE_SECOND * 5), a2 = await fetch(`${n4}/attestation/${s3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(o2), a2.status === 200 ? await a2.json() : void 0;
    }), w2(this, "getVerifyUrl", (s3) => {
      let n4 = s3 || ue2;
      return Jt2.includes(n4) || (this.logger.info(`verify url: ${n4}, not included in trusted list, assigning default: ${ue2}`), n4 = ue2), n4;
    }), w2(this, "fetchPublicKey", async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const s3 = this.startAbortTimer(import_time2.FIVE_SECONDS), n4 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(s3), await n4.json();
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), w2(this, "persistPublicKey", async (s3) => {
      this.logger.debug("persisting public key to local storage", s3), await this.store.setItem(this.storeKey, s3), this.publicKey = s3;
    }), w2(this, "removePublicKey", async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }), w2(this, "isValidJwtAttestation", async (s3) => {
      const n4 = await this.getPublicKey();
      try {
        if (n4) return this.validateAttestation(s3, n4);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
      const o2 = await this.fetchAndPersistPublicKey();
      try {
        if (o2) return this.validateAttestation(s3, o2);
      } catch (a2) {
        this.logger.error(a2), this.logger.warn("error validating attestation");
      }
    }), w2(this, "getPublicKey", async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey()), w2(this, "fetchAndPersistPublicKey", async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (n4) => {
        const o2 = await this.fetchPublicKey();
        o2 && (await this.persistPublicKey(o2), n4(o2));
      });
      const s3 = await this.fetchPromise;
      return this.fetchPromise = void 0, s3;
    }), w2(this, "validateAttestation", (s3, n4) => {
      const o2 = zc(s3, n4.publicKey), a2 = { hasExpired: (0, import_time2.toMiliseconds)(o2.exp) < Date.now(), payload: o2 };
      if (a2.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a2.payload.origin, isScam: a2.payload.isScam, isVerified: a2.payload.isVerified };
    }), this.logger = E2(t, this.name), this.abortController = new AbortController(), this.isDevEnv = Ii(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y2(this.logger);
  }
  startAbortTimer(e) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e));
  }
};
var Bo2 = Object.defineProperty;
var Vo = (r2, e, t) => e in r2 ? Bo2(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var Fi2 = (r2, e, t) => Vo(r2, typeof e != "symbol" ? e + "" : e, t);
var Mi2 = class extends O3 {
  constructor(e, t) {
    super(e, t), this.projectId = e, this.logger = t, Fi2(this, "context", Xt2), Fi2(this, "registerDeviceToken", async (i5) => {
      const { clientId: s3, token: n4, notificationType: o2, enableEncrypted: a2 = false } = i5, c6 = `${Zt}/${this.projectId}/clients`;
      await fetch(c6, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: s3, type: o2, token: n4, always_raw: a2 }) });
    }), this.logger = E2(t, this.context);
  }
};
var qo = Object.defineProperty;
var Ki2 = Object.getOwnPropertySymbols;
var Go2 = Object.prototype.hasOwnProperty;
var Wo2 = Object.prototype.propertyIsEnumerable;
var Ze2 = (r2, e, t) => e in r2 ? qo(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var be2 = (r2, e) => {
  for (var t in e || (e = {})) Go2.call(e, t) && Ze2(r2, t, e[t]);
  if (Ki2) for (var t of Ki2(e)) Wo2.call(e, t) && Ze2(r2, t, e[t]);
  return r2;
};
var E3 = (r2, e, t) => Ze2(r2, typeof e != "symbol" ? e + "" : e, t);
var Bi2 = class extends R {
  constructor(e, t, i5 = true) {
    super(e, t, i5), this.core = e, this.logger = t, E3(this, "context", ei2), E3(this, "storagePrefix", B2), E3(this, "storageVersion", Qt2), E3(this, "events", /* @__PURE__ */ new Map()), E3(this, "shouldPersist", false), E3(this, "init", async () => {
      if (!Ii()) try {
        const s3 = { eventId: Bi(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Mn(this.core.relayer.protocol, this.core.relayer.version, _e2) } } };
        await this.sendEvent([s3]);
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), E3(this, "createEvent", (s3) => {
      const { event: n4 = "ERROR", type: o2 = "", properties: { topic: a2, trace: c6 } } = s3, h6 = Bi(), l6 = this.core.projectId || "", d4 = Date.now(), g3 = be2({ eventId: h6, timestamp: d4, props: { event: n4, type: o2, properties: { topic: a2, trace: c6 } }, bundleId: l6, domain: this.getAppDomain() }, this.setMethods(h6));
      return this.telemetryEnabled && (this.events.set(h6, g3), this.shouldPersist = true), g3;
    }), E3(this, "getEvent", (s3) => {
      const { eventId: n4, topic: o2 } = s3;
      if (n4) return this.events.get(n4);
      const a2 = Array.from(this.events.values()).find((c6) => c6.props.properties.topic === o2);
      if (a2) return be2(be2({}, a2), this.setMethods(a2.eventId));
    }), E3(this, "deleteEvent", (s3) => {
      const { eventId: n4 } = s3;
      this.events.delete(n4), this.shouldPersist = true;
    }), E3(this, "setEventListeners", () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((s3) => {
          (0, import_time2.fromMiliseconds)(Date.now()) - (0, import_time2.fromMiliseconds)(s3.timestamp) > ti && (this.events.delete(s3.eventId), this.shouldPersist = true);
        });
      });
    }), E3(this, "setMethods", (s3) => ({ addTrace: (n4) => this.addTrace(s3, n4), setError: (n4) => this.setError(s3, n4) })), E3(this, "addTrace", (s3, n4) => {
      const o2 = this.events.get(s3);
      o2 && (o2.props.properties.trace.push(n4), this.events.set(s3, o2), this.shouldPersist = true);
    }), E3(this, "setError", (s3, n4) => {
      const o2 = this.events.get(s3);
      o2 && (o2.props.type = n4, o2.timestamp = Date.now(), this.events.set(s3, o2), this.shouldPersist = true);
    }), E3(this, "persist", async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }), E3(this, "restore", async () => {
      try {
        const s3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!s3.length) return;
        s3.forEach((n4) => {
          this.events.set(n4.eventId, be2(be2({}, n4), this.setMethods(n4.eventId)));
        });
      } catch (s3) {
        this.logger.warn(s3);
      }
    }), E3(this, "submit", async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const s3 = [];
      for (const [n4, o2] of this.events) o2.props.type && s3.push(o2);
      if (s3.length !== 0) try {
        if ((await this.sendEvent(s3)).ok) for (const n4 of s3) this.events.delete(n4.eventId), this.shouldPersist = true;
      } catch (n4) {
        this.logger.warn(n4);
      }
    }), E3(this, "sendEvent", async (s3) => {
      const n4 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${ii}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${_e2}${n4}`, { method: "POST", body: JSON.stringify(s3) });
    }), E3(this, "getAppDomain", () => Pn().url), this.logger = E2(t, this.context), this.telemetryEnabled = i5, i5 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Ho = Object.defineProperty;
var Vi2 = Object.getOwnPropertySymbols;
var Yo2 = Object.prototype.hasOwnProperty;
var Jo2 = Object.prototype.propertyIsEnumerable;
var Qe3 = (r2, e, t) => e in r2 ? Ho(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var qi2 = (r2, e) => {
  for (var t in e || (e = {})) Yo2.call(e, t) && Qe3(r2, t, e[t]);
  if (Vi2) for (var t of Vi2(e)) Jo2.call(e, t) && Qe3(r2, t, e[t]);
  return r2;
};
var v3 = (r2, e, t) => Qe3(r2, typeof e != "symbol" ? e + "" : e, t);
var Te = class _Te extends h3 {
  constructor(e) {
    var t;
    super(e), v3(this, "protocol", ze2), v3(this, "version", Le), v3(this, "name", he2), v3(this, "relayUrl"), v3(this, "projectId"), v3(this, "customStoragePrefix"), v3(this, "events", new import_events3.EventEmitter()), v3(this, "logger"), v3(this, "heartbeat"), v3(this, "relayer"), v3(this, "crypto"), v3(this, "storage"), v3(this, "history"), v3(this, "expirer"), v3(this, "pairing"), v3(this, "verify"), v3(this, "echoClient"), v3(this, "linkModeSupportedApps"), v3(this, "eventClient"), v3(this, "initialized", false), v3(this, "logChunkController"), v3(this, "on", (a2, c6) => this.events.on(a2, c6)), v3(this, "once", (a2, c6) => this.events.once(a2, c6)), v3(this, "off", (a2, c6) => this.events.off(a2, c6)), v3(this, "removeListener", (a2, c6) => this.events.removeListener(a2, c6)), v3(this, "dispatchEnvelope", ({ topic: a2, message: c6, sessionExists: h6 }) => {
      if (!a2 || !c6) return;
      const l6 = { topic: a2, message: c6, publishedAt: Date.now(), transportType: Q.link_mode };
      this.relayer.onLinkMessageEvent(l6, { sessionExists: h6 });
    });
    const i5 = this.getGlobalCore(e == null ? void 0 : e.customStoragePrefix);
    if (i5) try {
      return this.customStoragePrefix = i5.customStoragePrefix, this.logger = i5.logger, this.heartbeat = i5.heartbeat, this.crypto = i5.crypto, this.history = i5.history, this.expirer = i5.expirer, this.storage = i5.storage, this.relayer = i5.relayer, this.pairing = i5.pairing, this.verify = i5.verify, this.echoClient = i5.echoClient, this.linkModeSupportedApps = i5.linkModeSupportedApps, this.eventClient = i5.eventClient, this.initialized = i5.initialized, this.logChunkController = i5.logChunkController, i5;
    } catch (a2) {
      console.warn("Failed to copy global core", a2);
    }
    this.projectId = e == null ? void 0 : e.projectId, this.relayUrl = (e == null ? void 0 : e.relayUrl) || Ue, this.customStoragePrefix = e != null && e.customStoragePrefix ? `:${e.customStoragePrefix}` : "";
    const s3 = k3({ level: typeof (e == null ? void 0 : e.logger) == "string" && e.logger ? e.logger : Et2.logger, name: he2 }), { logger: n4, chunkLoggerController: o2 } = A({ opts: s3, maxSizeInBytes: e == null ? void 0 : e.maxLogBlobSizeInBytes, loggerOverride: e == null ? void 0 : e.logger });
    this.logChunkController = o2, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var a2, c6;
      (a2 = this.logChunkController) != null && a2.downloadLogsBlobInBrowser && ((c6 = this.logChunkController) == null || c6.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E2(n4, this.name), this.heartbeat = new i(), this.crypto = new vi2(this, this.logger, e == null ? void 0 : e.keychain), this.history = new ki2(this, this.logger), this.expirer = new ji2(this, this.logger), this.storage = e != null && e.storage ? e.storage : new h(qi2(qi2({}, It2), e == null ? void 0 : e.storageOptions)), this.relayer = new Si2({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new Li2(this, this.logger), this.verify = new Ui2(this, this.logger, this.storage), this.echoClient = new Mi2(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Bi2(this, this.logger, e == null ? void 0 : e.telemetryEnabled), this.setGlobalCore(this);
  }
  static async init(e) {
    const t = new _Te(e);
    await t.initialize();
    const i5 = await t.crypto.getClientId();
    return await t.storage.setItem(jt2, i5), t;
  }
  get context() {
    return y2(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e;
    return (e = this.logChunkController) == null ? void 0 : e.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e) {
    this.linkModeSupportedApps.includes(e) || (this.linkModeSupportedApps.push(e), await this.storage.setItem(Fe2, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.linkModeSupportedApps = await this.storage.getItem(Fe2) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e), this.logger.error(e.message), e;
    }
  }
  getGlobalCore(e = "") {
    try {
      if (this.isGlobalCoreDisabled()) return;
      const t = `_walletConnectCore_${e}`, i5 = `${t}_count`;
      return globalThis[i5] = (globalThis[i5] || 0) + 1, globalThis[i5] > 1 && console.warn(`WalletConnect Core is already initialized. This is probably a mistake and can lead to unexpected behavior. Init() was called ${globalThis[i5]} times.`), globalThis[t];
    } catch (t) {
      console.warn("Failed to get global WalletConnect core", t);
      return;
    }
  }
  setGlobalCore(e) {
    var t;
    try {
      if (this.isGlobalCoreDisabled()) return;
      const i5 = `_walletConnectCore_${((t = e.opts) == null ? void 0 : t.customStoragePrefix) || ""}`;
      globalThis[i5] = e;
    } catch (i5) {
      console.warn("Failed to set global WalletConnect core", i5);
    }
  }
  isGlobalCoreDisabled() {
    try {
      return typeof process < "u" && process.env.DISABLE_GLOBAL_CORE === "true";
    } catch {
      return true;
    }
  }
};
var Xo2 = Te;

// node_modules/@walletconnect/sign-client/node_modules/@walletconnect/logger/dist/index.es.js
var import_pino4 = __toESM(require_browser2());
var import_pino5 = __toESM(require_browser2());
var c4 = { level: "info" };
var n3 = "custom_context";
var l4 = 1e3 * 1024;
var x3 = Object.defineProperty;
var S4 = Object.defineProperties;
var _3 = Object.getOwnPropertyDescriptors;
var p4 = Object.getOwnPropertySymbols;
var T3 = Object.prototype.hasOwnProperty;
var z4 = Object.prototype.propertyIsEnumerable;
var f7 = (r2, e, t) => e in r2 ? x3(r2, e, { enumerable: true, configurable: true, writable: true, value: t }) : r2[e] = t;
var i4 = (r2, e) => {
  for (var t in e || (e = {})) T3.call(e, t) && f7(r2, t, e[t]);
  if (p4) for (var t of p4(e)) z4.call(e, t) && f7(r2, t, e[t]);
  return r2;
};
var g2 = (r2, e) => S4(r2, _3(e));
function k6(r2) {
  return g2(i4({}, r2), { level: (r2 == null ? void 0 : r2.level) || c4.level });
}
function v4(r2, e = n3) {
  return r2[e] || "";
}
function b3(r2, e, t = n3) {
  return r2[t] = e, r2;
}
function y5(r2, e = n3) {
  let t = "";
  return typeof r2.bindings > "u" ? t = v4(r2, e) : t = r2.bindings().context || "", t;
}
function w3(r2, e, t = n3) {
  const o2 = y5(r2, t);
  return o2.trim() ? `${o2}/${e}` : e;
}
function E4(r2, e, t = n3) {
  const o2 = w3(r2, e, t), a2 = r2.child({ context: o2 });
  return b3(a2, o2, t);
}

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_time3 = __toESM(require_cjs());
var import_events4 = __toESM(require_events());
var De2 = "wc";
var Le2 = 2;
var ke3 = "client";
var we2 = `${De2}@${Le2}:${ke3}:`;
var me2 = { name: ke3, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var Me3 = "WALLETCONNECT_DEEPLINK_CHOICE";
var pt2 = "proposal";
var $e2 = "Proposal expired";
var ht2 = "session";
var J2 = import_time3.SEVEN_DAYS;
var dt2 = "engine";
var N2 = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var _e3 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var $2 = { idle: "IDLE", active: "ACTIVE" };
var Ke3 = { eth_sendTransaction: { key: "" }, eth_sendRawTransaction: { key: "" }, wallet_sendCalls: { key: "" }, solana_signTransaction: { key: "signature" }, solana_signAllTransactions: { key: "transactions" }, solana_signAndSendTransaction: { key: "signature" } };
var ut2 = "request";
var gt2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var yt2 = "wc";
var wt2 = "auth";
var mt2 = "authKeys";
var _t2 = "pairingTopics";
var Et3 = "requests";
var ae2 = `${yt2}@${1.5}:${wt2}:`;
var ce2 = `${ae2}:PUB_KEY`;
var vs2 = Object.defineProperty;
var Is2 = Object.defineProperties;
var Ts2 = Object.getOwnPropertyDescriptors;
var ft2 = Object.getOwnPropertySymbols;
var qs3 = Object.prototype.hasOwnProperty;
var Ps2 = Object.prototype.propertyIsEnumerable;
var Ue2 = (S7, n4, e) => n4 in S7 ? vs2(S7, n4, { enumerable: true, configurable: true, writable: true, value: e }) : S7[n4] = e;
var v5 = (S7, n4) => {
  for (var e in n4 || (n4 = {})) qs3.call(n4, e) && Ue2(S7, e, n4[e]);
  if (ft2) for (var e of ft2(n4)) Ps2.call(n4, e) && Ue2(S7, e, n4[e]);
  return S7;
};
var b4 = (S7, n4) => Is2(S7, Ts2(n4));
var c5 = (S7, n4, e) => Ue2(S7, typeof n4 != "symbol" ? n4 + "" : n4, e);
var Ns2 = class extends V2 {
  constructor(n4) {
    super(n4), c5(this, "name", dt2), c5(this, "events", new import_events4.default()), c5(this, "initialized", false), c5(this, "requestQueue", { state: $2.idle, queue: [] }), c5(this, "sessionRequestQueue", { state: $2.idle, queue: [] }), c5(this, "requestQueueDelay", import_time3.ONE_SECOND), c5(this, "expectedPairingMethodMap", /* @__PURE__ */ new Map()), c5(this, "recentlyDeletedMap", /* @__PURE__ */ new Map()), c5(this, "recentlyDeletedLimit", 200), c5(this, "relayMessageCache", []), c5(this, "pendingSessions", /* @__PURE__ */ new Map()), c5(this, "init", async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(N2) }), this.initialized = true, setTimeout(async () => {
        await this.processPendingMessageEvents(), this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }), c5(this, "connect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = b4(v5({}, e), { requiredNamespaces: e.requiredNamespaces || {}, optionalNamespaces: e.optionalNamespaces || {} });
      await this.isValidConnect(t), t.optionalNamespaces = aa(t.requiredNamespaces, t.optionalNamespaces), t.requiredNamespaces = {};
      const { pairingTopic: s3, requiredNamespaces: i5, optionalNamespaces: r2, sessionProperties: o2, scopedProperties: a2, relays: l6 } = t;
      let p6 = s3, h6, u3 = false;
      try {
        if (p6) {
          const T5 = this.client.core.pairing.pairings.get(p6);
          this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."), u3 = T5.active;
        }
      } catch (T5) {
        throw this.client.logger.error(`connect() -> pairing.get(${p6}) failed`), T5;
      }
      if (!p6 || !u3) {
        const { topic: T5, uri: K5 } = await this.client.core.pairing.create();
        p6 = T5, h6 = K5;
      }
      if (!p6) {
        const { message: T5 } = ht("NO_MATCHING_KEY", `connect() pairing topic: ${p6}`);
        throw new Error(T5);
      }
      const d4 = await this.client.core.crypto.generateKeyPair(), w5 = N2.wc_sessionPropose.req.ttl || import_time3.FIVE_MINUTES, m3 = Ei(w5), f9 = b4(v5(v5({ requiredNamespaces: i5, optionalNamespaces: r2, relays: l6 ?? [{ protocol: xt2 }], proposer: { publicKey: d4, metadata: this.client.metadata }, expiryTimestamp: m3, pairingTopic: p6 }, o2 && { sessionProperties: o2 }), a2 && { scopedProperties: a2 }), { id: payloadId() }), _5 = xi("session_connect", f9.id), { reject: g3, resolve: A5, done: D4 } = gi(w5, $e2), I5 = ({ id: T5 }) => {
        T5 === f9.id && (this.client.events.off("proposal_expire", I5), this.pendingSessions.delete(f9.id), this.events.emit(_5, { error: { message: $e2, code: 0 } }));
      };
      return this.client.events.on("proposal_expire", I5), this.events.once(_5, ({ error: T5, session: K5 }) => {
        this.client.events.off("proposal_expire", I5), T5 ? g3(T5) : K5 && A5(K5);
      }), await this.sendRequest({ topic: p6, method: "wc_sessionPropose", params: f9, throwOnFailedPublish: true, clientRpcId: f9.id }), await this.setProposal(f9.id, f9), { uri: h6, approval: D4 };
    }), c5(this, "pair", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }), c5(this, "approve", async (e) => {
      var t, s3, i5;
      const r2 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e == null ? void 0 : e.id) == null ? void 0 : t.toString(), trace: [er2.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (q4) {
        throw r2.setError(tr2.no_internet_connection), q4;
      }
      try {
        await this.isValidProposalId(e == null ? void 0 : e.id);
      } catch (q4) {
        throw this.client.logger.error(`approve() -> proposal.get(${e == null ? void 0 : e.id}) failed`), r2.setError(tr2.proposal_not_found), q4;
      }
      try {
        await this.isValidApprove(e);
      } catch (q4) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r2.setError(tr2.session_approve_namespace_validation_failure), q4;
      }
      const { id: o2, relayProtocol: a2, namespaces: l6, sessionProperties: p6, scopedProperties: h6, sessionConfig: u3 } = e, d4 = this.client.proposal.get(o2);
      this.client.core.eventClient.deleteEvent({ eventId: r2.eventId });
      const { pairingTopic: w5, proposer: m3, requiredNamespaces: f9, optionalNamespaces: _5 } = d4;
      let g3 = (s3 = this.client.core.eventClient) == null ? void 0 : s3.getEvent({ topic: w5 });
      g3 || (g3 = (i5 = this.client.core.eventClient) == null ? void 0 : i5.createEvent({ type: er2.session_approve_started, properties: { topic: w5, trace: [er2.session_approve_started, er2.session_namespaces_validation_success] } }));
      const A5 = await this.client.core.crypto.generateKeyPair(), D4 = m3.publicKey, I5 = await this.client.core.crypto.generateSharedKey(A5, D4), T5 = v5(v5(v5({ relay: { protocol: a2 ?? "irn" }, namespaces: l6, controller: { publicKey: A5, metadata: this.client.metadata }, expiry: Ei(J2) }, p6 && { sessionProperties: p6 }), h6 && { scopedProperties: h6 }), u3 && { sessionConfig: u3 }), K5 = Q.relay;
      g3.addTrace(er2.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(I5, { transportType: K5 });
      } catch (q4) {
        throw g3.setError(tr2.subscribe_session_topic_failure), q4;
      }
      g3.addTrace(er2.subscribe_session_topic_success);
      const fe3 = b4(v5({}, T5), { topic: I5, requiredNamespaces: f9, optionalNamespaces: _5, pairingTopic: w5, acknowledged: false, self: T5.controller, peer: { publicKey: m3.publicKey, metadata: m3.metadata }, controller: A5, transportType: Q.relay });
      await this.client.session.set(I5, fe3), g3.addTrace(er2.store_session);
      try {
        g3.addTrace(er2.publishing_session_settle), await this.sendRequest({ topic: I5, method: "wc_sessionSettle", params: T5, throwOnFailedPublish: true }).catch((q4) => {
          throw g3 == null ? void 0 : g3.setError(tr2.session_settle_publish_failure), q4;
        }), g3.addTrace(er2.session_settle_publish_success), g3.addTrace(er2.publishing_session_approve), await this.sendResult({ id: o2, topic: w5, result: { relay: { protocol: a2 ?? "irn" }, responderPublicKey: A5 }, throwOnFailedPublish: true }).catch((q4) => {
          throw g3 == null ? void 0 : g3.setError(tr2.session_approve_publish_failure), q4;
        }), g3.addTrace(er2.session_approve_publish_success);
      } catch (q4) {
        throw this.client.logger.error(q4), this.client.session.delete(I5, Nt("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(I5), q4;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: g3.eventId }), await this.client.core.pairing.updateMetadata({ topic: w5, metadata: m3.metadata }), await this.client.proposal.delete(o2, Nt("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: w5 }), await this.setExpiry(I5, Ei(J2)), { topic: I5, acknowledged: () => Promise.resolve(this.client.session.get(I5)) };
    }), c5(this, "reject", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e);
      } catch (r2) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r2;
      }
      const { id: t, reason: s3 } = e;
      let i5;
      try {
        i5 = this.client.proposal.get(t).pairingTopic;
      } catch (r2) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r2;
      }
      i5 && (await this.sendError({ id: t, topic: i5, error: s3, rpcOpts: N2.wc_sessionPropose.reject }), await this.client.proposal.delete(t, Nt("USER_DISCONNECTED")));
    }), c5(this, "update", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e);
      } catch (h6) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), h6;
      }
      const { topic: t, namespaces: s3 } = e, { done: i5, resolve: r2, reject: o2 } = gi(), a2 = payloadId(), l6 = getBigIntRpcId().toString(), p6 = this.client.session.get(t).namespaces;
      return this.events.once(xi("session_update", a2), ({ error: h6 }) => {
        h6 ? o2(h6) : r2();
      }), await this.client.session.update(t, { namespaces: s3 }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s3 }, throwOnFailedPublish: true, clientRpcId: a2, relayRpcId: l6 }).catch((h6) => {
        this.client.logger.error(h6), this.client.session.update(t, { namespaces: p6 }), o2(h6);
      }), { acknowledged: i5 };
    }), c5(this, "extend", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e);
      } catch (a2) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a2;
      }
      const { topic: t } = e, s3 = payloadId(), { done: i5, resolve: r2, reject: o2 } = gi();
      return this.events.once(xi("session_extend", s3), ({ error: a2 }) => {
        a2 ? o2(a2) : r2();
      }), await this.setExpiry(t, Ei(J2)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s3, throwOnFailedPublish: true }).catch((a2) => {
        o2(a2);
      }), { acknowledged: i5 };
    }), c5(this, "request", async (e) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e);
      } catch (_5) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), _5;
      }
      const { chainId: t, request: s3, topic: i5, expiry: r2 = N2.wc_sessionRequest.req.ttl } = e, o2 = this.client.session.get(i5);
      (o2 == null ? void 0 : o2.transportType) === Q.relay && await this.confirmOnlineStateOrThrow();
      const a2 = payloadId(), l6 = getBigIntRpcId().toString(), { done: p6, resolve: h6, reject: u3 } = gi(r2, "Request expired. Please try again.");
      this.events.once(xi("session_request", a2), ({ error: _5, result: g3 }) => {
        _5 ? u3(_5) : h6(g3);
      });
      const d4 = "wc_sessionRequest", w5 = this.getAppLinkIfEnabled(o2.peer.metadata, o2.transportType);
      if (w5) return await this.sendRequest({ clientRpcId: a2, relayRpcId: l6, topic: i5, method: d4, params: { request: b4(v5({}, s3), { expiryTimestamp: Ei(r2) }), chainId: t }, expiry: r2, throwOnFailedPublish: true, appLink: w5 }).catch((_5) => u3(_5)), this.client.events.emit("session_request_sent", { topic: i5, request: s3, chainId: t, id: a2 }), await p6();
      const m3 = { request: b4(v5({}, s3), { expiryTimestamp: Ei(r2) }), chainId: t }, f9 = this.shouldSetTVF(d4, m3);
      return await Promise.all([new Promise(async (_5) => {
        await this.sendRequest(v5({ clientRpcId: a2, relayRpcId: l6, topic: i5, method: d4, params: m3, expiry: r2, throwOnFailedPublish: true }, f9 && { tvf: this.getTVFParams(a2, m3) })).catch((g3) => u3(g3)), this.client.events.emit("session_request_sent", { topic: i5, request: s3, chainId: t, id: a2 }), _5();
      }), new Promise(async (_5) => {
        var g3;
        if (!((g3 = o2.sessionConfig) != null && g3.disableDeepLink)) {
          const A5 = await Oi(this.client.core.storage, Me3);
          await Si({ id: a2, topic: i5, wcDeepLink: A5 });
        }
        _5();
      }), p6()]).then((_5) => _5[2]);
    }), c5(this, "respond", async (e) => {
      this.isInitialized(), await this.isValidRespond(e);
      const { topic: t, response: s3 } = e, { id: i5 } = s3, r2 = this.client.session.get(t);
      r2.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const o2 = this.getAppLinkIfEnabled(r2.peer.metadata, r2.transportType);
      isJsonRpcResult(s3) ? await this.sendResult({ id: i5, topic: t, result: s3.result, throwOnFailedPublish: true, appLink: o2 }) : isJsonRpcError(s3) && await this.sendError({ id: i5, topic: t, error: s3.error, appLink: o2 }), this.cleanupAfterResponse(e);
    }), c5(this, "ping", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e);
      } catch (s3) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s3;
      }
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) {
        const s3 = payloadId(), i5 = getBigIntRpcId().toString(), { done: r2, resolve: o2, reject: a2 } = gi();
        this.events.once(xi("session_ping", s3), ({ error: l6 }) => {
          l6 ? a2(l6) : o2();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s3, relayRpcId: i5 }), r2()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && (this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."), await this.client.core.pairing.ping({ topic: t }));
    }), c5(this, "emit", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e);
      const { topic: t, event: s3, chainId: i5 } = e, r2 = getBigIntRpcId().toString(), o2 = payloadId();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s3, chainId: i5 }, throwOnFailedPublish: true, relayRpcId: r2, clientRpcId: o2 });
    }), c5(this, "disconnect", async (e) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e);
      const { topic: t } = e;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: Nt("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s3 } = ht("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s3);
      }
    }), c5(this, "find", (e) => (this.isInitialized(), this.client.session.getAll().filter((t) => ua(t, e)))), c5(this, "getPendingSessionRequests", () => this.client.pendingRequest.getAll()), c5(this, "authenticate", async (e, t) => {
      var s3;
      this.isInitialized(), this.isValidAuthenticate(e);
      const i5 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s3 = this.client.metadata.redirect) == null ? void 0 : s3.linkMode), r2 = i5 ? Q.link_mode : Q.relay;
      r2 === Q.relay && await this.confirmOnlineStateOrThrow();
      const { chains: o2, statement: a2 = "", uri: l6, domain: p6, nonce: h6, type: u3, exp: d4, nbf: w5, methods: m3 = [], expiry: f9 } = e, _5 = [...e.resources || []], { topic: g3, uri: A5 } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r2 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: g3, uri: A5 } });
      const D4 = await this.client.core.crypto.generateKeyPair(), I5 = Pc(D4);
      if (await Promise.all([this.client.auth.authKeys.set(ce2, { responseTopic: I5, publicKey: D4 }), this.client.auth.pairingTopics.set(I5, { topic: I5, pairingTopic: g3 })]), await this.client.core.relayer.subscribe(I5, { transportType: r2 }), this.client.logger.info(`sending request to new pairing topic: ${g3}`), m3.length > 0) {
        const { namespace: x5 } = Ne(o2[0]);
        let L5 = fs(x5, "request", m3);
        pe(_5) && (L5 = ls(L5, _5.pop())), _5.push(L5);
      }
      const T5 = f9 && f9 > N2.wc_sessionAuthenticate.req.ttl ? f9 : N2.wc_sessionAuthenticate.req.ttl, K5 = { authPayload: { type: u3 ?? "caip122", chains: o2, statement: a2, aud: l6, domain: p6, version: "1", nonce: h6, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: d4, nbf: w5, resources: _5 }, requester: { publicKey: D4, metadata: this.client.metadata }, expiryTimestamp: Ei(T5) }, fe3 = { eip155: { chains: o2, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m3])], events: ["chainChanged", "accountsChanged"] } }, q4 = { requiredNamespaces: {}, optionalNamespaces: fe3, relays: [{ protocol: "irn" }], pairingTopic: g3, proposer: { publicKey: D4, metadata: this.client.metadata }, expiryTimestamp: Ei(N2.wc_sessionPropose.req.ttl), id: payloadId() }, { done: Rt4, resolve: je4, reject: Se4 } = gi(T5, "Request expired"), te3 = payloadId(), le4 = xi("session_connect", q4.id), Re2 = xi("session_request", te3), pe4 = async ({ error: x5, session: L5 }) => {
        this.events.off(Re2, ve3), x5 ? Se4(x5) : L5 && je4({ session: L5 });
      }, ve3 = async (x5) => {
        var L5, Fe4, Qe5;
        if (await this.deletePendingAuthRequest(te3, { message: "fulfilled", code: 0 }), x5.error) {
          const ie4 = Nt("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return x5.error.code === ie4.code ? void 0 : (this.events.off(le4, pe4), Se4(x5.error.message));
        }
        await this.deleteProposal(q4.id), this.events.off(le4, pe4);
        const { cacaos: He4, responder: Q4 } = x5.result, Te3 = [], ze4 = [];
        for (const ie4 of He4) {
          await is({ cacao: ie4, projectId: this.client.core.projectId }) || (this.client.logger.error(ie4, "Signature verification failed"), Se4(Nt("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: qe4 } = ie4, Pe4 = pe(qe4.resources), Ye4 = [dr(qe4.iss)], vt2 = De(qe4.iss);
          if (Pe4) {
            const Ne3 = ds(Pe4), It4 = hs(Pe4);
            Te3.push(...Ne3), Ye4.push(...It4);
          }
          for (const Ne3 of Ye4) ze4.push(`${Ne3}:${vt2}`);
        }
        const se4 = await this.client.core.crypto.generateSharedKey(D4, Q4.publicKey);
        let he4;
        Te3.length > 0 && (he4 = { topic: se4, acknowledged: true, self: { publicKey: D4, metadata: this.client.metadata }, peer: Q4, controller: Q4.publicKey, expiry: Ei(J2), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: g3, namespaces: ca([...new Set(Te3)], [...new Set(ze4)]), transportType: r2 }, await this.client.core.relayer.subscribe(se4, { transportType: r2 }), await this.client.session.set(se4, he4), g3 && await this.client.core.pairing.updateMetadata({ topic: g3, metadata: Q4.metadata }), he4 = this.client.session.get(se4)), (L5 = this.client.metadata.redirect) != null && L5.linkMode && (Fe4 = Q4.metadata.redirect) != null && Fe4.linkMode && (Qe5 = Q4.metadata.redirect) != null && Qe5.universal && t && (this.client.core.addLinkModeSupportedApp(Q4.metadata.redirect.universal), this.client.session.update(se4, { transportType: Q.link_mode })), je4({ auths: He4, session: he4 });
      };
      this.events.once(le4, pe4), this.events.once(Re2, ve3);
      let Ie4;
      try {
        if (i5) {
          const x5 = formatJsonRpcRequest("wc_sessionAuthenticate", K5, te3);
          this.client.core.history.set(g3, x5);
          const L5 = await this.client.core.crypto.encode("", x5, { type: re, encoding: xe });
          Ie4 = Xc(t, g3, L5);
        } else await Promise.all([this.sendRequest({ topic: g3, method: "wc_sessionAuthenticate", params: K5, expiry: e.expiry, throwOnFailedPublish: true, clientRpcId: te3 }), this.sendRequest({ topic: g3, method: "wc_sessionPropose", params: q4, expiry: N2.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: q4.id })]);
      } catch (x5) {
        throw this.events.off(le4, pe4), this.events.off(Re2, ve3), x5;
      }
      return await this.setProposal(q4.id, q4), await this.setAuthRequest(te3, { request: b4(v5({}, K5), { verifyContext: {} }), pairingTopic: g3, transportType: r2 }), { uri: Ie4 ?? A5, response: Rt4 };
    }), c5(this, "approveSessionAuthenticate", async (e) => {
      const { id: t, auths: s3 } = e, i5 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [ir2.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (f9) {
        throw i5.setError(sr2.no_internet_connection), f9;
      }
      const r2 = this.getPendingAuthRequest(t);
      if (!r2) throw i5.setError(sr2.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const o2 = r2.transportType || Q.relay;
      o2 === Q.relay && await this.confirmOnlineStateOrThrow();
      const a2 = r2.requester.publicKey, l6 = await this.client.core.crypto.generateKeyPair(), p6 = Pc(a2), h6 = { type: Ft, receiverPublicKey: a2, senderPublicKey: l6 }, u3 = [], d4 = [];
      for (const f9 of s3) {
        if (!await is({ cacao: f9, projectId: this.client.core.projectId })) {
          i5.setError(sr2.invalid_cacao);
          const I5 = Nt("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: p6, error: I5, encodeOpts: h6 }), new Error(I5.message);
        }
        i5.addTrace(ir2.cacaos_verified);
        const { p: _5 } = f9, g3 = pe(_5.resources), A5 = [dr(_5.iss)], D4 = De(_5.iss);
        if (g3) {
          const I5 = ds(g3), T5 = hs(g3);
          u3.push(...I5), A5.push(...T5);
        }
        for (const I5 of A5) d4.push(`${I5}:${D4}`);
      }
      const w5 = await this.client.core.crypto.generateSharedKey(l6, a2);
      i5.addTrace(ir2.create_authenticated_session_topic);
      let m3;
      if ((u3 == null ? void 0 : u3.length) > 0) {
        m3 = { topic: w5, acknowledged: true, self: { publicKey: l6, metadata: this.client.metadata }, peer: { publicKey: a2, metadata: r2.requester.metadata }, controller: a2, expiry: Ei(J2), authentication: s3, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r2.pairingTopic, namespaces: ca([...new Set(u3)], [...new Set(d4)]), transportType: o2 }, i5.addTrace(ir2.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w5, { transportType: o2 });
        } catch (f9) {
          throw i5.setError(sr2.subscribe_authenticated_session_topic_failure), f9;
        }
        i5.addTrace(ir2.subscribe_authenticated_session_topic_success), await this.client.session.set(w5, m3), i5.addTrace(ir2.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r2.pairingTopic, metadata: r2.requester.metadata });
      }
      i5.addTrace(ir2.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: p6, id: t, result: { cacaos: s3, responder: { publicKey: l6, metadata: this.client.metadata } }, encodeOpts: h6, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r2.requester.metadata, o2) });
      } catch (f9) {
        throw i5.setError(sr2.authenticated_session_approve_publish_failure), f9;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r2.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i5.eventId }), { session: m3 };
    }), c5(this, "rejectSessionAuthenticate", async (e) => {
      this.isInitialized();
      const { id: t, reason: s3 } = e, i5 = this.getPendingAuthRequest(t);
      if (!i5) throw new Error(`Could not find pending auth request with id ${t}`);
      i5.transportType === Q.relay && await this.confirmOnlineStateOrThrow();
      const r2 = i5.requester.publicKey, o2 = await this.client.core.crypto.generateKeyPair(), a2 = Pc(r2), l6 = { type: Ft, receiverPublicKey: r2, senderPublicKey: o2 };
      await this.sendError({ id: t, topic: a2, error: s3, encodeOpts: l6, rpcOpts: N2.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i5.requester.metadata, i5.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, Nt("USER_DISCONNECTED"));
    }), c5(this, "formatAuthMessage", (e) => {
      this.isInitialized();
      const { request: t, iss: s3 } = e;
      return hr(t, s3);
    }), c5(this, "processRelayMessageCache", () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e = this.relayMessageCache.shift();
          e && await this.onRelayMessage(e);
        } catch (e) {
          this.client.logger.error(e);
        }
      }, 50);
    }), c5(this, "cleanupDuplicatePairings", async (e) => {
      if (e.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e.pairingTopic), s3 = this.client.core.pairing.pairings.getAll().filter((i5) => {
          var r2, o2;
          return ((r2 = i5.peerMetadata) == null ? void 0 : r2.url) && ((o2 = i5.peerMetadata) == null ? void 0 : o2.url) === e.peer.metadata.url && i5.topic && i5.topic !== t.topic;
        });
        if (s3.length === 0) return;
        this.client.logger.info(`Cleaning up ${s3.length} duplicate pairing(s)`), await Promise.all(s3.map((i5) => this.client.core.pairing.disconnect({ topic: i5.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c5(this, "deleteSession", async (e) => {
      var t;
      const { topic: s3, expirerHasDeleted: i5 = false, emitEvent: r2 = true, id: o2 = 0 } = e, { self: a2 } = this.client.session.get(s3);
      await this.client.core.relayer.unsubscribe(s3), await this.client.session.delete(s3, Nt("USER_DISCONNECTED")), this.addToRecentlyDeleted(s3, "session"), this.client.core.crypto.keychain.has(a2.publicKey) && await this.client.core.crypto.deleteKeyPair(a2.publicKey), this.client.core.crypto.keychain.has(s3) && await this.client.core.crypto.deleteSymKey(s3), i5 || this.client.core.expirer.del(s3), this.client.core.storage.removeItem(Me3).catch((l6) => this.client.logger.warn(l6)), this.getPendingSessionRequests().forEach((l6) => {
        l6.topic === s3 && this.deletePendingSessionRequest(l6.id, Nt("USER_DISCONNECTED"));
      }), s3 === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = $2.idle), r2 && this.client.events.emit("session_delete", { id: o2, topic: s3 });
    }), c5(this, "deleteProposal", async (e, t) => {
      if (t) try {
        const s3 = this.client.proposal.get(e), i5 = this.client.core.eventClient.getEvent({ topic: s3.pairingTopic });
        i5 == null ? void 0 : i5.setError(tr2.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e, Nt("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "proposal");
    }), c5(this, "deletePendingSessionRequest", async (e, t, s3 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e, t), s3 ? Promise.resolve() : this.client.core.expirer.del(e)]), this.addToRecentlyDeleted(e, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i5) => i5.id !== e), s3 && (this.sessionRequestQueue.state = $2.idle, this.client.events.emit("session_request_expire", { id: e }));
    }), c5(this, "deletePendingAuthRequest", async (e, t, s3 = false) => {
      await Promise.all([this.client.auth.requests.delete(e, t), s3 ? Promise.resolve() : this.client.core.expirer.del(e)]);
    }), c5(this, "setExpiry", async (e, t) => {
      this.client.session.keys.includes(e) && (this.client.core.expirer.set(e, t), await this.client.session.update(e, { expiry: t }));
    }), c5(this, "setProposal", async (e, t) => {
      this.client.core.expirer.set(e, Ei(N2.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e, t);
    }), c5(this, "setAuthRequest", async (e, t) => {
      const { request: s3, pairingTopic: i5, transportType: r2 = Q.relay } = t;
      this.client.core.expirer.set(e, s3.expiryTimestamp), await this.client.auth.requests.set(e, { authPayload: s3.authPayload, requester: s3.requester, expiryTimestamp: s3.expiryTimestamp, id: e, pairingTopic: i5, verifyContext: s3.verifyContext, transportType: r2 });
    }), c5(this, "setPendingSessionRequest", async (e) => {
      const { id: t, topic: s3, params: i5, verifyContext: r2 } = e, o2 = i5.request.expiryTimestamp || Ei(N2.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, o2), await this.client.pendingRequest.set(t, { id: t, topic: s3, params: i5, verifyContext: r2 });
    }), c5(this, "sendRequest", async (e) => {
      const { topic: t, method: s3, params: i5, expiry: r2, relayRpcId: o2, clientRpcId: a2, throwOnFailedPublish: l6, appLink: p6, tvf: h6 } = e, u3 = formatJsonRpcRequest(s3, i5, a2);
      let d4;
      const w5 = !!p6;
      try {
        const _5 = w5 ? xe : qt;
        d4 = await this.client.core.crypto.encode(t, u3, { encoding: _5 });
      } catch (_5) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), _5;
      }
      let m3;
      if (gt2.includes(s3)) {
        const _5 = kc(JSON.stringify(u3)), g3 = kc(d4);
        m3 = await this.client.core.verify.register({ id: g3, decryptedId: _5 });
      }
      const f9 = N2[s3].req;
      if (f9.attestation = m3, r2 && (f9.ttl = r2), o2 && (f9.id = o2), this.client.core.history.set(t, u3), w5) {
        const _5 = Xc(p6, t, d4);
        await global.Linking.openURL(_5, this.client.name);
      } else {
        const _5 = N2[s3].req;
        r2 && (_5.ttl = r2), o2 && (_5.id = o2), _5.tvf = b4(v5({}, h6), { correlationId: u3.id }), l6 ? (_5.internal = b4(v5({}, _5.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d4, _5)) : this.client.core.relayer.publish(t, d4, _5).catch((g3) => this.client.logger.error(g3));
      }
      return u3.id;
    }), c5(this, "sendResult", async (e) => {
      const { id: t, topic: s3, result: i5, throwOnFailedPublish: r2, encodeOpts: o2, appLink: a2 } = e, l6 = formatJsonRpcResult(t, i5);
      let p6;
      const h6 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const w5 = h6 ? xe : qt;
        p6 = await this.client.core.crypto.encode(s3, l6, b4(v5({}, o2 || {}), { encoding: w5 }));
      } catch (w5) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s3} failed`), w5;
      }
      let u3, d4;
      try {
        u3 = await this.client.core.history.get(s3, t);
        const w5 = u3.request;
        try {
          this.shouldSetTVF(w5.method, w5.params) && (d4 = this.getTVFParams(t, w5.params, i5));
        } catch (m3) {
          this.client.logger.warn("sendResult() -> getTVFParams() failed", m3);
        }
      } catch (w5) {
        throw this.client.logger.error(`sendResult() -> history.get(${s3}, ${t}) failed`), w5;
      }
      if (h6) {
        const w5 = Xc(a2, s3, p6);
        await global.Linking.openURL(w5, this.client.name);
      } else {
        const w5 = u3.request.method, m3 = N2[w5].res;
        m3.tvf = b4(v5({}, d4), { correlationId: t }), r2 ? (m3.internal = b4(v5({}, m3.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s3, p6, m3)) : this.client.core.relayer.publish(s3, p6, m3).catch((f9) => this.client.logger.error(f9));
      }
      await this.client.core.history.resolve(l6);
    }), c5(this, "sendError", async (e) => {
      const { id: t, topic: s3, error: i5, encodeOpts: r2, rpcOpts: o2, appLink: a2 } = e, l6 = formatJsonRpcError(t, i5);
      let p6;
      const h6 = a2 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const d4 = h6 ? xe : qt;
        p6 = await this.client.core.crypto.encode(s3, l6, b4(v5({}, r2 || {}), { encoding: d4 }));
      } catch (d4) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s3} failed`), d4;
      }
      let u3;
      try {
        u3 = await this.client.core.history.get(s3, t);
      } catch (d4) {
        throw this.client.logger.error(`sendError() -> history.get(${s3}, ${t}) failed`), d4;
      }
      if (h6) {
        const d4 = Xc(a2, s3, p6);
        await global.Linking.openURL(d4, this.client.name);
      } else {
        const d4 = u3.request.method, w5 = o2 || N2[d4].res;
        this.client.core.relayer.publish(s3, p6, w5);
      }
      await this.client.core.history.resolve(l6);
    }), c5(this, "cleanup", async () => {
      const e = [], t = [];
      this.client.session.getAll().forEach((s3) => {
        let i5 = false;
        vi(s3.expiry) && (i5 = true), this.client.core.crypto.keychain.has(s3.topic) || (i5 = true), i5 && e.push(s3.topic);
      }), this.client.proposal.getAll().forEach((s3) => {
        vi(s3.expiryTimestamp) && t.push(s3.id);
      }), await Promise.all([...e.map((s3) => this.deleteSession({ topic: s3 })), ...t.map((s3) => this.deleteProposal(s3))]);
    }), c5(this, "onProviderMessageEvent", async (e) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(e) : await this.onRelayMessage(e);
    }), c5(this, "onRelayEventRequest", async (e) => {
      this.requestQueue.queue.push(e), await this.processRequestsQueue();
    }), c5(this, "processRequestsQueue", async () => {
      if (this.requestQueue.state === $2.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = $2.active;
        const e = this.requestQueue.queue.shift();
        if (e) try {
          await this.processRequest(e);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = $2.idle;
    }), c5(this, "processRequest", async (e) => {
      const { topic: t, payload: s3, attestation: i5, transportType: r2, encryptedId: o2 } = e, a2 = s3.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a2 })) switch (a2) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s3, attestation: i5, encryptedId: o2 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s3);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s3);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s3);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s3);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s3);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s3, attestation: i5, encryptedId: o2, transportType: r2 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s3);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s3, attestation: i5, encryptedId: o2, transportType: r2 });
        default:
          return this.client.logger.info(`Unsupported request method ${a2}`);
      }
    }), c5(this, "onRelayEventResponse", async (e) => {
      const { topic: t, payload: s3, transportType: i5 } = e, r2 = (await this.client.core.history.get(t, s3.id)).request.method;
      switch (r2) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s3, i5);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s3);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s3);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s3);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s3);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s3);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s3);
        default:
          return this.client.logger.info(`Unsupported response method ${r2}`);
      }
    }), c5(this, "onRelayEventUnknownPayload", (e) => {
      const { topic: t } = e, { message: s3 } = ht("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s3);
    }), c5(this, "shouldIgnorePairingRequest", (e) => {
      const { topic: t, requestMethod: s3 } = e, i5 = this.expectedPairingMethodMap.get(t);
      return !i5 || i5.includes(s3) ? false : !!(i5.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }), c5(this, "onSessionProposeRequest", async (e) => {
      const { topic: t, payload: s3, attestation: i5, encryptedId: r2 } = e, { params: o2, id: a2 } = s3;
      try {
        const l6 = this.client.core.eventClient.getEvent({ topic: t });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), l6 == null ? void 0 : l6.setError(Y2.proposal_listener_not_found)), this.isValidConnect(v5({}, s3.params));
        const p6 = o2.expiryTimestamp || Ei(N2.wc_sessionPropose.req.ttl), h6 = v5({ id: a2, pairingTopic: t, expiryTimestamp: p6 }, o2);
        await this.setProposal(a2, h6);
        const u3 = await this.getVerifyContext({ attestationId: i5, hash: kc(JSON.stringify(s3)), encryptedId: r2, metadata: h6.proposer.metadata });
        l6 == null ? void 0 : l6.addTrace(G2.emit_session_proposal), this.client.events.emit("session_proposal", { id: a2, params: h6, verifyContext: u3 });
      } catch (l6) {
        await this.sendError({ id: a2, topic: t, error: l6, rpcOpts: N2.wc_sessionPropose.autoReject }), this.client.logger.error(l6);
      }
    }), c5(this, "onSessionProposeResponse", async (e, t, s3) => {
      const { id: i5 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r2 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r2 });
        const o2 = this.client.proposal.get(i5);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: o2 });
        const a2 = o2.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a2 });
        const l6 = r2.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: l6 });
        const p6 = await this.client.core.crypto.generateSharedKey(a2, l6);
        this.pendingSessions.set(i5, { sessionTopic: p6, pairingTopic: e, proposalId: i5, publicKey: a2 });
        const h6 = await this.client.core.relayer.subscribe(p6, { transportType: s3 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: h6 }), await this.client.core.pairing.activate({ topic: e });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i5, Nt("USER_DISCONNECTED"));
        const r2 = xi("session_connect", i5);
        if (this.events.listenerCount(r2) === 0) throw new Error(`emitting ${r2} without any listeners, 954`);
        this.events.emit(r2, { error: t.error });
      }
    }), c5(this, "onSessionSettleRequest", async (e, t) => {
      const { id: s3, params: i5 } = t;
      try {
        this.isValidSessionSettleRequest(i5);
        const { relay: r2, controller: o2, expiry: a2, namespaces: l6, sessionProperties: p6, scopedProperties: h6, sessionConfig: u3 } = t.params, d4 = [...this.pendingSessions.values()].find((f9) => f9.sessionTopic === e);
        if (!d4) return this.client.logger.error(`Pending session not found for topic ${e}`);
        const w5 = this.client.proposal.get(d4.proposalId), m3 = b4(v5(v5(v5({ topic: e, relay: r2, expiry: a2, namespaces: l6, acknowledged: true, pairingTopic: d4.pairingTopic, requiredNamespaces: w5.requiredNamespaces, optionalNamespaces: w5.optionalNamespaces, controller: o2.publicKey, self: { publicKey: d4.publicKey, metadata: this.client.metadata }, peer: { publicKey: o2.publicKey, metadata: o2.metadata } }, p6 && { sessionProperties: p6 }), h6 && { scopedProperties: h6 }), u3 && { sessionConfig: u3 }), { transportType: Q.relay });
        await this.client.session.set(m3.topic, m3), await this.setExpiry(m3.topic, m3.expiry), await this.client.core.pairing.updateMetadata({ topic: d4.pairingTopic, metadata: m3.peer.metadata }), this.client.events.emit("session_connect", { session: m3 }), this.events.emit(xi("session_connect", d4.proposalId), { session: m3 }), this.pendingSessions.delete(d4.proposalId), this.deleteProposal(d4.proposalId, false), this.cleanupDuplicatePairings(m3), await this.sendResult({ id: t.id, topic: e, result: true, throwOnFailedPublish: true });
      } catch (r2) {
        await this.sendError({ id: s3, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c5(this, "onSessionSettleResponse", async (e, t) => {
      const { id: s3 } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e, { acknowledged: true }), this.events.emit(xi("session_approve", s3), {})) : isJsonRpcError(t) && (await this.client.session.delete(e, Nt("USER_DISCONNECTED")), this.events.emit(xi("session_approve", s3), { error: t.error }));
    }), c5(this, "onSessionUpdateRequest", async (e, t) => {
      const { params: s3, id: i5 } = t;
      try {
        const r2 = `${e}_session_update`, o2 = Ra.get(r2);
        if (o2 && this.isRequestOutOfSync(o2, i5)) {
          this.client.logger.warn(`Discarding out of sync request - ${i5}`), this.sendError({ id: i5, topic: e, error: Nt("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(v5({ topic: e }, s3));
        try {
          Ra.set(r2, i5), await this.client.session.update(e, { namespaces: s3.namespaces }), await this.sendResult({ id: i5, topic: e, result: true, throwOnFailedPublish: true });
        } catch (a2) {
          throw Ra.delete(r2), a2;
        }
        this.client.events.emit("session_update", { id: i5, topic: e, params: s3 });
      } catch (r2) {
        await this.sendError({ id: i5, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c5(this, "isRequestOutOfSync", (e, t) => t.toString().slice(0, -3) < e.toString().slice(0, -3)), c5(this, "onSessionUpdateResponse", (e, t) => {
      const { id: s3 } = t, i5 = xi("session_update", s3);
      if (this.events.listenerCount(i5) === 0) throw new Error(`emitting ${i5} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_update", s3), {}) : isJsonRpcError(t) && this.events.emit(xi("session_update", s3), { error: t.error });
    }), c5(this, "onSessionExtendRequest", async (e, t) => {
      const { id: s3 } = t;
      try {
        this.isValidExtend({ topic: e }), await this.setExpiry(e, Ei(J2)), await this.sendResult({ id: s3, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s3, topic: e });
      } catch (i5) {
        await this.sendError({ id: s3, topic: e, error: i5 }), this.client.logger.error(i5);
      }
    }), c5(this, "onSessionExtendResponse", (e, t) => {
      const { id: s3 } = t, i5 = xi("session_extend", s3);
      if (this.events.listenerCount(i5) === 0) throw new Error(`emitting ${i5} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_extend", s3), {}) : isJsonRpcError(t) && this.events.emit(xi("session_extend", s3), { error: t.error });
    }), c5(this, "onSessionPingRequest", async (e, t) => {
      const { id: s3 } = t;
      try {
        this.isValidPing({ topic: e }), await this.sendResult({ id: s3, topic: e, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s3, topic: e });
      } catch (i5) {
        await this.sendError({ id: s3, topic: e, error: i5 }), this.client.logger.error(i5);
      }
    }), c5(this, "onSessionPingResponse", (e, t) => {
      const { id: s3 } = t, i5 = xi("session_ping", s3);
      setTimeout(() => {
        if (this.events.listenerCount(i5) === 0) throw new Error(`emitting ${i5} without any listeners 2176`);
        isJsonRpcResult(t) ? this.events.emit(xi("session_ping", s3), {}) : isJsonRpcError(t) && this.events.emit(xi("session_ping", s3), { error: t.error });
      }, 500);
    }), c5(this, "onSessionDeleteRequest", async (e, t) => {
      const { id: s3 } = t;
      try {
        this.isValidDisconnect({ topic: e, reason: t.params }), Promise.all([new Promise((i5) => {
          this.client.core.relayer.once(C3.publish, async () => {
            i5(await this.deleteSession({ topic: e, id: s3 }));
          });
        }), this.sendResult({ id: s3, topic: e, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e, error: Nt("USER_DISCONNECTED") })]).catch((i5) => this.client.logger.error(i5));
      } catch (i5) {
        this.client.logger.error(i5);
      }
    }), c5(this, "onSessionRequest", async (e) => {
      var t, s3, i5;
      const { topic: r2, payload: o2, attestation: a2, encryptedId: l6, transportType: p6 } = e, { id: h6, params: u3 } = o2;
      try {
        await this.isValidRequest(v5({ topic: r2 }, u3));
        const d4 = this.client.session.get(r2), w5 = await this.getVerifyContext({ attestationId: a2, hash: kc(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", u3, h6))), encryptedId: l6, metadata: d4.peer.metadata, transportType: p6 }), m3 = { id: h6, topic: r2, params: u3, verifyContext: w5 };
        await this.setPendingSessionRequest(m3), p6 === Q.link_mode && (t = d4.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s3 = d4.peer.metadata.redirect) == null ? void 0 : s3.universal), (i5 = this.client.signConfig) != null && i5.disableRequestQueue ? this.emitSessionRequest(m3) : (this.addSessionRequestToSessionRequestQueue(m3), this.processSessionRequestQueue());
      } catch (d4) {
        await this.sendError({ id: h6, topic: r2, error: d4 }), this.client.logger.error(d4);
      }
    }), c5(this, "onSessionRequestResponse", (e, t) => {
      const { id: s3 } = t, i5 = xi("session_request", s3);
      if (this.events.listenerCount(i5) === 0) throw new Error(`emitting ${i5} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(xi("session_request", s3), { result: t.result }) : isJsonRpcError(t) && this.events.emit(xi("session_request", s3), { error: t.error });
    }), c5(this, "onSessionEventRequest", async (e, t) => {
      const { id: s3, params: i5 } = t;
      try {
        const r2 = `${e}_session_event_${i5.event.name}`, o2 = Ra.get(r2);
        if (o2 && this.isRequestOutOfSync(o2, s3)) {
          this.client.logger.info(`Discarding out of sync request - ${s3}`);
          return;
        }
        this.isValidEmit(v5({ topic: e }, i5)), this.client.events.emit("session_event", { id: s3, topic: e, params: i5 }), Ra.set(r2, s3);
      } catch (r2) {
        await this.sendError({ id: s3, topic: e, error: r2 }), this.client.logger.error(r2);
      }
    }), c5(this, "onSessionAuthenticateResponse", (e, t) => {
      const { id: s3 } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e, payload: t }), isJsonRpcResult(t) ? this.events.emit(xi("session_request", s3), { result: t.result }) : isJsonRpcError(t) && this.events.emit(xi("session_request", s3), { error: t.error });
    }), c5(this, "onSessionAuthenticateRequest", async (e) => {
      var t;
      const { topic: s3, payload: i5, attestation: r2, encryptedId: o2, transportType: a2 } = e;
      try {
        const { requester: l6, authPayload: p6, expiryTimestamp: h6 } = i5.params, u3 = await this.getVerifyContext({ attestationId: r2, hash: kc(JSON.stringify(i5)), encryptedId: o2, metadata: l6.metadata, transportType: a2 }), d4 = { requester: l6, pairingTopic: s3, id: i5.id, authPayload: p6, verifyContext: u3, expiryTimestamp: h6 };
        await this.setAuthRequest(i5.id, { request: d4, pairingTopic: s3, transportType: a2 }), a2 === Q.link_mode && (t = l6.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(l6.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s3, params: i5.params, id: i5.id, verifyContext: u3 });
      } catch (l6) {
        this.client.logger.error(l6);
        const p6 = i5.params.requester.publicKey, h6 = await this.client.core.crypto.generateKeyPair(), u3 = this.getAppLinkIfEnabled(i5.params.requester.metadata, a2), d4 = { type: Ft, receiverPublicKey: p6, senderPublicKey: h6 };
        await this.sendError({ id: i5.id, topic: s3, error: l6, encodeOpts: d4, rpcOpts: N2.wc_sessionAuthenticate.autoReject, appLink: u3 });
      }
    }), c5(this, "addSessionRequestToSessionRequestQueue", (e) => {
      this.sessionRequestQueue.queue.push(e);
    }), c5(this, "cleanupAfterResponse", (e) => {
      this.deletePendingSessionRequest(e.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = $2.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }), c5(this, "cleanupPendingSentRequestsForTopic", ({ topic: e, error: t }) => {
      const s3 = this.client.core.history.pending;
      s3.length > 0 && s3.filter((i5) => i5.topic === e && i5.request.method === "wc_sessionRequest").forEach((i5) => {
        const r2 = i5.request.id, o2 = xi("session_request", r2);
        if (this.events.listenerCount(o2) === 0) throw new Error(`emitting ${o2} without any listeners`);
        this.events.emit(xi("session_request", i5.request.id), { error: t });
      });
    }), c5(this, "processSessionRequestQueue", () => {
      if (this.sessionRequestQueue.state === $2.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e = this.sessionRequestQueue.queue[0];
      if (!e) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = $2.active, this.emitSessionRequest(e);
      } catch (t) {
        this.client.logger.error(t);
      }
    }), c5(this, "emitSessionRequest", (e) => {
      this.client.events.emit("session_request", e);
    }), c5(this, "onPairingCreated", (e) => {
      if (e.methods && this.expectedPairingMethodMap.set(e.topic, e.methods), e.active) return;
      const t = this.client.proposal.getAll().find((s3) => s3.pairingTopic === e.topic);
      t && this.onSessionProposeRequest({ topic: e.topic, payload: formatJsonRpcRequest("wc_sessionPropose", b4(v5({}, t), { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties, scopedProperties: t.scopedProperties }), t.id) });
    }), c5(this, "isValidConnect", async (e) => {
      if (!ma(e)) {
        const { message: l6 } = ht("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e)}`);
        throw new Error(l6);
      }
      const { pairingTopic: t, requiredNamespaces: s3, optionalNamespaces: i5, sessionProperties: r2, scopedProperties: o2, relays: a2 } = e;
      if (Et(t) || await this.isValidPairingTopic(t), !ga(a2, true)) {
        const { message: l6 } = ht("MISSING_OR_INVALID", `connect() relays: ${a2}`);
        throw new Error(l6);
      }
      if (!Et(s3) && Oe(s3) !== 0) {
        const l6 = "requiredNamespaces are deprecated and are automatically assigned to optionalNamespaces";
        ["fatal", "error", "silent"].includes(this.client.logger.level) ? console.warn(l6) : this.client.logger.warn(l6), this.validateNamespaces(s3, "requiredNamespaces");
      }
      if (!Et(i5) && Oe(i5) !== 0 && this.validateNamespaces(i5, "optionalNamespaces"), Et(r2) || this.validateSessionProps(r2, "sessionProperties"), !Et(o2)) {
        this.validateSessionProps(o2, "scopedProperties");
        const l6 = Object.keys(s3 || {}).concat(Object.keys(i5 || {}));
        if (!Object.keys(o2).every((p6) => l6.includes(p6))) throw new Error(`Scoped properties must be a subset of required/optional namespaces, received: ${JSON.stringify(o2)}, required/optional namespaces: ${JSON.stringify(l6)}`);
      }
    }), c5(this, "validateNamespaces", (e, t) => {
      const s3 = pa(e, "connect()", t);
      if (s3) throw new Error(s3.message);
    }), c5(this, "isValidApprove", async (e) => {
      if (!ma(e)) throw new Error(ht("MISSING_OR_INVALID", `approve() params: ${e}`).message);
      const { id: t, namespaces: s3, relayProtocol: i5, sessionProperties: r2, scopedProperties: o2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const a2 = this.client.proposal.get(t), l6 = Bo(s3, "approve()");
      if (l6) throw new Error(l6.message);
      const p6 = No(a2.requiredNamespaces, s3, "approve()");
      if (p6) throw new Error(p6.message);
      if (!nt(i5, true)) {
        const { message: h6 } = ht("MISSING_OR_INVALID", `approve() relayProtocol: ${i5}`);
        throw new Error(h6);
      }
      if (Et(r2) || this.validateSessionProps(r2, "sessionProperties"), !Et(o2)) {
        this.validateSessionProps(o2, "scopedProperties");
        const h6 = new Set(Object.keys(s3));
        if (!Object.keys(o2).every((u3) => h6.has(u3))) throw new Error(`Scoped properties must be a subset of approved namespaces, received: ${JSON.stringify(o2)}, approved namespaces: ${Array.from(h6).join(", ")}`);
      }
    }), c5(this, "isValidReject", async (e) => {
      if (!ma(e)) {
        const { message: i5 } = ht("MISSING_OR_INVALID", `reject() params: ${e}`);
        throw new Error(i5);
      }
      const { id: t, reason: s3 } = e;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !wa(s3)) {
        const { message: i5 } = ht("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s3)}`);
        throw new Error(i5);
      }
    }), c5(this, "isValidSessionSettleRequest", (e) => {
      if (!ma(e)) {
        const { message: l6 } = ht("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e}`);
        throw new Error(l6);
      }
      const { relay: t, controller: s3, namespaces: i5, expiry: r2 } = e;
      if (!Io(t)) {
        const { message: l6 } = ht("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(l6);
      }
      const o2 = ha(s3, "onSessionSettleRequest()");
      if (o2) throw new Error(o2.message);
      const a2 = Bo(i5, "onSessionSettleRequest()");
      if (a2) throw new Error(a2.message);
      if (vi(r2)) {
        const { message: l6 } = ht("EXPIRED", "onSessionSettleRequest()");
        throw new Error(l6);
      }
    }), c5(this, "isValidUpdate", async (e) => {
      if (!ma(e)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `update() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: t, namespaces: s3 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i5 = this.client.session.get(t), r2 = Bo(s3, "update()");
      if (r2) throw new Error(r2.message);
      const o2 = No(i5.requiredNamespaces, s3, "update()");
      if (o2) throw new Error(o2.message);
    }), c5(this, "isValidExtend", async (e) => {
      if (!ma(e)) {
        const { message: s3 } = ht("MISSING_OR_INVALID", `extend() params: ${e}`);
        throw new Error(s3);
      }
      const { topic: t } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }), c5(this, "isValidRequest", async (e) => {
      if (!ma(e)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `request() params: ${e}`);
        throw new Error(a2);
      }
      const { topic: t, request: s3, chainId: i5, expiry: r2 } = e;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: o2 } = this.client.session.get(t);
      if (!xa(o2, i5)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `request() chainId: ${i5}`);
        throw new Error(a2);
      }
      if (!ba(s3)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `request() ${JSON.stringify(s3)}`);
        throw new Error(a2);
      }
      if (!Sa(o2, i5, s3.method)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `request() method: ${s3.method}`);
        throw new Error(a2);
      }
      if (r2 && !Ia(r2, _e3)) {
        const { message: a2 } = ht("MISSING_OR_INVALID", `request() expiry: ${r2}. Expiry must be a number (in seconds) between ${_e3.min} and ${_e3.max}`);
        throw new Error(a2);
      }
    }), c5(this, "isValidRespond", async (e) => {
      var t;
      if (!ma(e)) {
        const { message: r2 } = ht("MISSING_OR_INVALID", `respond() params: ${e}`);
        throw new Error(r2);
      }
      const { topic: s3, response: i5 } = e;
      try {
        await this.isValidSessionTopic(s3);
      } catch (r2) {
        throw (t = e == null ? void 0 : e.response) != null && t.id && this.cleanupAfterResponse(e), r2;
      }
      if (!Ea(i5)) {
        const { message: r2 } = ht("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i5)}`);
        throw new Error(r2);
      }
    }), c5(this, "isValidPing", async (e) => {
      if (!ma(e)) {
        const { message: s3 } = ht("MISSING_OR_INVALID", `ping() params: ${e}`);
        throw new Error(s3);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c5(this, "isValidEmit", async (e) => {
      if (!ma(e)) {
        const { message: o2 } = ht("MISSING_OR_INVALID", `emit() params: ${e}`);
        throw new Error(o2);
      }
      const { topic: t, event: s3, chainId: i5 } = e;
      await this.isValidSessionTopic(t);
      const { namespaces: r2 } = this.client.session.get(t);
      if (!xa(r2, i5)) {
        const { message: o2 } = ht("MISSING_OR_INVALID", `emit() chainId: ${i5}`);
        throw new Error(o2);
      }
      if (!va(s3)) {
        const { message: o2 } = ht("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s3)}`);
        throw new Error(o2);
      }
      if (!Oa(r2, i5, s3.name)) {
        const { message: o2 } = ht("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s3)}`);
        throw new Error(o2);
      }
    }), c5(this, "isValidDisconnect", async (e) => {
      if (!ma(e)) {
        const { message: s3 } = ht("MISSING_OR_INVALID", `disconnect() params: ${e}`);
        throw new Error(s3);
      }
      const { topic: t } = e;
      await this.isValidSessionOrPairingTopic(t);
    }), c5(this, "isValidAuthenticate", (e) => {
      const { chains: t, uri: s3, domain: i5, nonce: r2 } = e;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!nt(s3, false)) throw new Error("uri is required parameter");
      if (!nt(i5, false)) throw new Error("domain is required parameter");
      if (!nt(r2, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a2) => Ne(a2).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: o2 } = Ne(t[0]);
      if (o2 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }), c5(this, "getVerifyContext", async (e) => {
      const { attestationId: t, hash: s3, encryptedId: i5, metadata: r2, transportType: o2 } = e, a2 = { verified: { verifyUrl: r2.verifyUrl || ue2, validation: "UNKNOWN", origin: r2.url || "" } };
      try {
        if (o2 === Q.link_mode) {
          const p6 = this.getAppLinkIfEnabled(r2, o2);
          return a2.verified.validation = p6 && new URL(p6).origin === new URL(r2.url).origin ? "VALID" : "INVALID", a2;
        }
        const l6 = await this.client.core.verify.resolve({ attestationId: t, hash: s3, encryptedId: i5, verifyUrl: r2.verifyUrl });
        l6 && (a2.verified.origin = l6.origin, a2.verified.isScam = l6.isScam, a2.verified.validation = l6.origin === new URL(r2.url).origin ? "VALID" : "INVALID");
      } catch (l6) {
        this.client.logger.warn(l6);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a2)}`), a2;
    }), c5(this, "validateSessionProps", (e, t) => {
      Object.values(e).forEach((s3, i5) => {
        if (s3 == null) {
          const { message: r2 } = ht("MISSING_OR_INVALID", `${t} must contain an existing value for each key. Received: ${s3} for key ${Object.keys(e)[i5]}`);
          throw new Error(r2);
        }
      });
    }), c5(this, "getPendingAuthRequest", (e) => {
      const t = this.client.auth.requests.get(e);
      return typeof t == "object" ? t : void 0;
    }), c5(this, "addToRecentlyDeleted", (e, t) => {
      if (this.recentlyDeletedMap.set(e, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s3 = 0;
        const i5 = this.recentlyDeletedLimit / 2;
        for (const r2 of this.recentlyDeletedMap.keys()) {
          if (s3++ >= i5) break;
          this.recentlyDeletedMap.delete(r2);
        }
      }
    }), c5(this, "checkRecentlyDeleted", (e) => {
      const t = this.recentlyDeletedMap.get(e);
      if (t) {
        const { message: s3 } = ht("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e}`);
        throw new Error(s3);
      }
    }), c5(this, "isLinkModeEnabled", (e, t) => {
      var s3, i5, r2, o2, a2, l6, p6, h6, u3;
      return !e || t !== Q.link_mode ? false : ((i5 = (s3 = this.client.metadata) == null ? void 0 : s3.redirect) == null ? void 0 : i5.linkMode) === true && ((o2 = (r2 = this.client.metadata) == null ? void 0 : r2.redirect) == null ? void 0 : o2.universal) !== void 0 && ((l6 = (a2 = this.client.metadata) == null ? void 0 : a2.redirect) == null ? void 0 : l6.universal) !== "" && ((p6 = e == null ? void 0 : e.redirect) == null ? void 0 : p6.universal) !== void 0 && ((h6 = e == null ? void 0 : e.redirect) == null ? void 0 : h6.universal) !== "" && ((u3 = e == null ? void 0 : e.redirect) == null ? void 0 : u3.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }), c5(this, "getAppLinkIfEnabled", (e, t) => {
      var s3;
      return this.isLinkModeEnabled(e, t) ? (s3 = e == null ? void 0 : e.redirect) == null ? void 0 : s3.universal : void 0;
    }), c5(this, "handleLinkModeMessage", ({ url: e }) => {
      if (!e || !e.includes("wc_ev") || !e.includes("topic")) return;
      const t = Ai(e, "topic") || "", s3 = decodeURIComponent(Ai(e, "wc_ev") || ""), i5 = this.client.session.keys.includes(t);
      i5 && this.client.session.update(t, { transportType: Q.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s3, sessionExists: i5 });
    }), c5(this, "registerLinkModeListeners", async () => {
      var e;
      if (Ii() || pt() && (e = this.client.metadata.redirect) != null && e.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s3 = await t.getInitialURL();
          s3 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s3 });
          }, 50);
        }
      }
    }), c5(this, "shouldSetTVF", (e, t) => {
      if (!t || e !== "wc_sessionRequest") return false;
      const { request: s3 } = t;
      return Object.keys(Ke3).includes(s3.method);
    }), c5(this, "getTVFParams", (e, t, s3) => {
      var i5, r2;
      try {
        const o2 = t.request.method, a2 = this.extractTxHashesFromResult(o2, s3);
        return b4(v5({ correlationId: e, rpcMethods: [o2], chainId: t.chainId }, this.isValidContractData(t.request.params) && { contractAddresses: [(r2 = (i5 = t.request.params) == null ? void 0 : i5[0]) == null ? void 0 : r2.to] }), { txHashes: a2 });
      } catch (o2) {
        this.client.logger.warn("Error getting TVF params", o2);
      }
      return {};
    }), c5(this, "isValidContractData", (e) => {
      var t;
      if (!e) return false;
      try {
        const s3 = (e == null ? void 0 : e.data) || ((t = e == null ? void 0 : e[0]) == null ? void 0 : t.data);
        if (!s3.startsWith("0x")) return false;
        const i5 = s3.slice(2);
        return /^[0-9a-fA-F]*$/.test(i5) ? i5.length % 2 === 0 : false;
      } catch {
      }
      return false;
    }), c5(this, "extractTxHashesFromResult", (e, t) => {
      try {
        const s3 = Ke3[e];
        if (typeof t == "string") return [t];
        const i5 = t[s3.key];
        if (se(i5)) return e === "solana_signAllTransactions" ? i5.map((r2) => Ji(r2)) : i5;
        if (typeof i5 == "string") return [i5];
      } catch (s3) {
        this.client.logger.warn("Error extracting tx hashes from result", s3);
      }
      return [];
    });
  }
  async processPendingMessageEvents() {
    try {
      const n4 = this.client.session.keys, e = this.client.core.relayer.messages.getWithoutAck(n4);
      for (const [t, s3] of Object.entries(e)) for (const i5 of s3) try {
        await this.onProviderMessageEvent({ topic: t, message: i5, publishedAt: Date.now() });
      } catch {
        this.client.logger.warn(`Error processing pending message event for topic: ${t}, message: ${i5}`);
      }
    } catch (n4) {
      this.client.logger.warn("processPendingMessageEvents failed", n4);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: n4 } = ht("NOT_INITIALIZED", this.name);
      throw new Error(n4);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(C3.message, (n4) => {
      this.onProviderMessageEvent(n4);
    });
  }
  async onRelayMessage(n4) {
    const { topic: e, message: t, attestation: s3, transportType: i5 } = n4, { publicKey: r2 } = this.client.auth.authKeys.keys.includes(ce2) ? this.client.auth.authKeys.get(ce2) : { responseTopic: void 0, publicKey: void 0 };
    try {
      const o2 = await this.client.core.crypto.decode(e, t, { receiverPublicKey: r2, encoding: i5 === Q.link_mode ? xe : qt });
      isJsonRpcRequest(o2) ? (this.client.core.history.set(e, o2), await this.onRelayEventRequest({ topic: e, payload: o2, attestation: s3, transportType: i5, encryptedId: kc(t) })) : isJsonRpcResponse(o2) ? (await this.client.core.history.resolve(o2), await this.onRelayEventResponse({ topic: e, payload: o2, transportType: i5 }), this.client.core.history.delete(e, o2.id)) : await this.onRelayEventUnknownPayload({ topic: e, payload: o2, transportType: i5 }), await this.client.core.relayer.messages.ack(e, t);
    } catch (o2) {
      this.client.logger.error(o2);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(M2.expired, async (n4) => {
      const { topic: e, id: t } = bi(n4.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, ht("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, ht("EXPIRED"), true);
      e ? this.client.session.keys.includes(e) && (await this.deleteSession({ topic: e, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(re2.create, (n4) => this.onPairingCreated(n4)), this.client.core.pairing.events.on(re2.delete, (n4) => {
      this.addToRecentlyDeleted(n4.topic, "pairing");
    });
  }
  isValidPairingTopic(n4) {
    if (!nt(n4, false)) {
      const { message: e } = ht("MISSING_OR_INVALID", `pairing topic should be a string: ${n4}`);
      throw new Error(e);
    }
    if (!this.client.core.pairing.pairings.keys.includes(n4)) {
      const { message: e } = ht("NO_MATCHING_KEY", `pairing topic doesn't exist: ${n4}`);
      throw new Error(e);
    }
    if (vi(this.client.core.pairing.pairings.get(n4).expiry)) {
      const { message: e } = ht("EXPIRED", `pairing topic: ${n4}`);
      throw new Error(e);
    }
  }
  async isValidSessionTopic(n4) {
    if (!nt(n4, false)) {
      const { message: e } = ht("MISSING_OR_INVALID", `session topic should be a string: ${n4}`);
      throw new Error(e);
    }
    if (this.checkRecentlyDeleted(n4), !this.client.session.keys.includes(n4)) {
      const { message: e } = ht("NO_MATCHING_KEY", `session topic doesn't exist: ${n4}`);
      throw new Error(e);
    }
    if (vi(this.client.session.get(n4).expiry)) {
      await this.deleteSession({ topic: n4 });
      const { message: e } = ht("EXPIRED", `session topic: ${n4}`);
      throw new Error(e);
    }
    if (!this.client.core.crypto.keychain.has(n4)) {
      const { message: e } = ht("MISSING_OR_INVALID", `session topic does not exist in keychain: ${n4}`);
      throw await this.deleteSession({ topic: n4 }), new Error(e);
    }
  }
  async isValidSessionOrPairingTopic(n4) {
    if (this.checkRecentlyDeleted(n4), this.client.session.keys.includes(n4)) await this.isValidSessionTopic(n4);
    else if (this.client.core.pairing.pairings.keys.includes(n4)) this.isValidPairingTopic(n4);
    else if (nt(n4, false)) {
      const { message: e } = ht("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${n4}`);
      throw new Error(e);
    } else {
      const { message: e } = ht("MISSING_OR_INVALID", `session or pairing topic should be a string: ${n4}`);
      throw new Error(e);
    }
  }
  async isValidProposalId(n4) {
    if (!ya(n4)) {
      const { message: e } = ht("MISSING_OR_INVALID", `proposal id should be a number: ${n4}`);
      throw new Error(e);
    }
    if (!this.client.proposal.keys.includes(n4)) {
      const { message: e } = ht("NO_MATCHING_KEY", `proposal id doesn't exist: ${n4}`);
      throw new Error(e);
    }
    if (vi(this.client.proposal.get(n4).expiryTimestamp)) {
      await this.deleteProposal(n4);
      const { message: e } = ht("EXPIRED", `proposal id: ${n4}`);
      throw new Error(e);
    }
  }
};
var Os2 = class extends zi2 {
  constructor(n4, e) {
    super(n4, e, pt2, we2), this.core = n4, this.logger = e;
  }
};
var St3 = class extends zi2 {
  constructor(n4, e) {
    super(n4, e, ht2, we2), this.core = n4, this.logger = e;
  }
};
var bs2 = class extends zi2 {
  constructor(n4, e) {
    super(n4, e, ut2, we2, (t) => t.id), this.core = n4, this.logger = e;
  }
};
var As2 = class extends zi2 {
  constructor(n4, e) {
    super(n4, e, mt2, ae2, () => ce2), this.core = n4, this.logger = e;
  }
};
var xs2 = class extends zi2 {
  constructor(n4, e) {
    super(n4, e, _t2, ae2), this.core = n4, this.logger = e;
  }
};
var Cs2 = class extends zi2 {
  constructor(n4, e) {
    super(n4, e, Et3, ae2, (t) => t.id), this.core = n4, this.logger = e;
  }
};
var Vs2 = Object.defineProperty;
var Ds2 = (S7, n4, e) => n4 in S7 ? Vs2(S7, n4, { enumerable: true, configurable: true, writable: true, value: e }) : S7[n4] = e;
var Ge3 = (S7, n4, e) => Ds2(S7, typeof n4 != "symbol" ? n4 + "" : n4, e);
var Ls2 = class {
  constructor(n4, e) {
    this.core = n4, this.logger = e, Ge3(this, "authKeys"), Ge3(this, "pairingTopics"), Ge3(this, "requests"), this.authKeys = new As2(this.core, this.logger), this.pairingTopics = new xs2(this.core, this.logger), this.requests = new Cs2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var ks2 = Object.defineProperty;
var Ms2 = (S7, n4, e) => n4 in S7 ? ks2(S7, n4, { enumerable: true, configurable: true, writable: true, value: e }) : S7[n4] = e;
var E5 = (S7, n4, e) => Ms2(S7, typeof n4 != "symbol" ? n4 + "" : n4, e);
var Ee3 = class _Ee extends J {
  constructor(n4) {
    super(n4), E5(this, "protocol", De2), E5(this, "version", Le2), E5(this, "name", me2.name), E5(this, "metadata"), E5(this, "core"), E5(this, "logger"), E5(this, "events", new import_events4.EventEmitter()), E5(this, "engine"), E5(this, "session"), E5(this, "proposal"), E5(this, "pendingRequest"), E5(this, "auth"), E5(this, "signConfig"), E5(this, "on", (t, s3) => this.events.on(t, s3)), E5(this, "once", (t, s3) => this.events.once(t, s3)), E5(this, "off", (t, s3) => this.events.off(t, s3)), E5(this, "removeListener", (t, s3) => this.events.removeListener(t, s3)), E5(this, "removeAllListeners", (t) => this.events.removeAllListeners(t)), E5(this, "connect", async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "pair", async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "approve", async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "reject", async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "update", async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "extend", async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "request", async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "respond", async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "ping", async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "emit", async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "disconnect", async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "find", (t) => {
      try {
        return this.engine.find(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "getPendingSessionRequests", () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }), E5(this, "authenticate", async (t, s3) => {
      try {
        return await this.engine.authenticate(t, s3);
      } catch (i5) {
        throw this.logger.error(i5.message), i5;
      }
    }), E5(this, "formatAuthMessage", (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "approveSessionAuthenticate", async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), E5(this, "rejectSessionAuthenticate", async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s3) {
        throw this.logger.error(s3.message), s3;
      }
    }), this.name = (n4 == null ? void 0 : n4.name) || me2.name, this.metadata = oi(n4 == null ? void 0 : n4.metadata), this.signConfig = n4 == null ? void 0 : n4.signConfig;
    const e = typeof (n4 == null ? void 0 : n4.logger) < "u" && typeof (n4 == null ? void 0 : n4.logger) != "string" ? n4.logger : (0, import_pino5.default)(k6({ level: (n4 == null ? void 0 : n4.logger) || me2.logger }));
    this.core = (n4 == null ? void 0 : n4.core) || new Xo2(n4), this.logger = E4(e, this.name), this.session = new St3(this.core, this.logger), this.proposal = new Os2(this.core, this.logger), this.pendingRequest = new bs2(this.core, this.logger), this.engine = new Ns2(this), this.auth = new Ls2(this.core, this.logger);
  }
  static async init(n4) {
    const e = new _Ee(n4);
    return await e.initialize(), e;
  }
  get context() {
    return y5(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), setTimeout(() => {
        this.engine.processRelayMessageCache();
      }, (0, import_time3.toMiliseconds)(import_time3.ONE_SECOND));
    } catch (n4) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(n4.message), n4;
    }
  }
};

// node_modules/@walletconnect/ethereum-provider/node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events5 = __toESM(require_events());
var et2 = "error";
var St4 = "wss://relay.walletconnect.org";
var Dt2 = "wc";
var qt3 = "universal_provider";
var U5 = `${Dt2}@2:${qt3}:`;
var st = "https://rpc.walletconnect.org/v1/";
var I3 = "generic";
var jt3 = `${st}bundler`;
var u2 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
function Rt3() {
}
function k7(s3) {
  return s3 == null || typeof s3 != "object" && typeof s3 != "function";
}
function W2(s3) {
  return ArrayBuffer.isView(s3) && !(s3 instanceof DataView);
}
function _t3(s3) {
  if (k7(s3)) return s3;
  if (Array.isArray(s3) || W2(s3) || s3 instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s3 instanceof SharedArrayBuffer) return s3.slice(0);
  const t = Object.getPrototypeOf(s3), e = t.constructor;
  if (s3 instanceof Date || s3 instanceof Map || s3 instanceof Set) return new e(s3);
  if (s3 instanceof RegExp) {
    const i5 = new e(s3);
    return i5.lastIndex = s3.lastIndex, i5;
  }
  if (s3 instanceof DataView) return new e(s3.buffer.slice(0));
  if (s3 instanceof Error) {
    const i5 = new e(s3.message);
    return i5.stack = s3.stack, i5.name = s3.name, i5.cause = s3.cause, i5;
  }
  if (typeof File < "u" && s3 instanceof File) return new e([s3], s3.name, { type: s3.type, lastModified: s3.lastModified });
  if (typeof s3 == "object") {
    const i5 = Object.create(t);
    return Object.assign(i5, s3);
  }
  return s3;
}
function it3(s3) {
  return typeof s3 == "object" && s3 !== null;
}
function rt(s3) {
  return Object.getOwnPropertySymbols(s3).filter((t) => Object.prototype.propertyIsEnumerable.call(s3, t));
}
function nt2(s3) {
  return s3 == null ? s3 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(s3);
}
var Ut2 = "[object RegExp]";
var at2 = "[object String]";
var ct2 = "[object Number]";
var ot2 = "[object Boolean]";
var ht3 = "[object Arguments]";
var Ft3 = "[object Symbol]";
var Lt3 = "[object Date]";
var Mt3 = "[object Map]";
var xt3 = "[object Set]";
var Bt3 = "[object Array]";
var Gt2 = "[object ArrayBuffer]";
var Jt3 = "[object Object]";
var zt2 = "[object DataView]";
var kt4 = "[object Uint8Array]";
var Wt3 = "[object Uint8ClampedArray]";
var Kt3 = "[object Uint16Array]";
var Vt3 = "[object Uint32Array]";
var Xt3 = "[object Int8Array]";
var Yt3 = "[object Int16Array]";
var Qt3 = "[object Int32Array]";
var Zt2 = "[object Float32Array]";
var Tt3 = "[object Float64Array]";
function te2(s3, t) {
  return $3(s3, void 0, s3, /* @__PURE__ */ new Map(), t);
}
function $3(s3, t, e, i5 = /* @__PURE__ */ new Map(), n4 = void 0) {
  const a2 = n4 == null ? void 0 : n4(s3, t, e, i5);
  if (a2 != null) return a2;
  if (k7(s3)) return s3;
  if (i5.has(s3)) return i5.get(s3);
  if (Array.isArray(s3)) {
    const r2 = new Array(s3.length);
    i5.set(s3, r2);
    for (let c6 = 0; c6 < s3.length; c6++) r2[c6] = $3(s3[c6], c6, e, i5, n4);
    return Object.hasOwn(s3, "index") && (r2.index = s3.index), Object.hasOwn(s3, "input") && (r2.input = s3.input), r2;
  }
  if (s3 instanceof Date) return new Date(s3.getTime());
  if (s3 instanceof RegExp) {
    const r2 = new RegExp(s3.source, s3.flags);
    return r2.lastIndex = s3.lastIndex, r2;
  }
  if (s3 instanceof Map) {
    const r2 = /* @__PURE__ */ new Map();
    i5.set(s3, r2);
    for (const [c6, o2] of s3) r2.set(c6, $3(o2, c6, e, i5, n4));
    return r2;
  }
  if (s3 instanceof Set) {
    const r2 = /* @__PURE__ */ new Set();
    i5.set(s3, r2);
    for (const c6 of s3) r2.add($3(c6, void 0, e, i5, n4));
    return r2;
  }
  if (typeof Buffer < "u" && Buffer.isBuffer(s3)) return s3.subarray();
  if (W2(s3)) {
    const r2 = new (Object.getPrototypeOf(s3)).constructor(s3.length);
    i5.set(s3, r2);
    for (let c6 = 0; c6 < s3.length; c6++) r2[c6] = $3(s3[c6], c6, e, i5, n4);
    return r2;
  }
  if (s3 instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && s3 instanceof SharedArrayBuffer) return s3.slice(0);
  if (s3 instanceof DataView) {
    const r2 = new DataView(s3.buffer.slice(0), s3.byteOffset, s3.byteLength);
    return i5.set(s3, r2), y6(r2, s3, e, i5, n4), r2;
  }
  if (typeof File < "u" && s3 instanceof File) {
    const r2 = new File([s3], s3.name, { type: s3.type });
    return i5.set(s3, r2), y6(r2, s3, e, i5, n4), r2;
  }
  if (s3 instanceof Blob) {
    const r2 = new Blob([s3], { type: s3.type });
    return i5.set(s3, r2), y6(r2, s3, e, i5, n4), r2;
  }
  if (s3 instanceof Error) {
    const r2 = new s3.constructor();
    return i5.set(s3, r2), r2.message = s3.message, r2.name = s3.name, r2.stack = s3.stack, r2.cause = s3.cause, y6(r2, s3, e, i5, n4), r2;
  }
  if (typeof s3 == "object" && ee3(s3)) {
    const r2 = Object.create(Object.getPrototypeOf(s3));
    return i5.set(s3, r2), y6(r2, s3, e, i5, n4), r2;
  }
  return s3;
}
function y6(s3, t, e = s3, i5, n4) {
  const a2 = [...Object.keys(t), ...rt(t)];
  for (let r2 = 0; r2 < a2.length; r2++) {
    const c6 = a2[r2], o2 = Object.getOwnPropertyDescriptor(s3, c6);
    (o2 == null || o2.writable) && (s3[c6] = $3(t[c6], c6, e, i5, n4));
  }
}
function ee3(s3) {
  switch (nt2(s3)) {
    case ht3:
    case Bt3:
    case Gt2:
    case zt2:
    case ot2:
    case Lt3:
    case Zt2:
    case Tt3:
    case Xt3:
    case Yt3:
    case Qt3:
    case Mt3:
    case ct2:
    case Jt3:
    case Ut2:
    case xt3:
    case at2:
    case Ft3:
    case kt4:
    case Wt3:
    case Kt3:
    case Vt3:
      return true;
    default:
      return false;
  }
}
function se3(s3, t) {
  return te2(s3, (e, i5, n4, a2) => {
    const r2 = t == null ? void 0 : t(e, i5, n4, a2);
    if (r2 != null) return r2;
    if (typeof s3 == "object") switch (Object.prototype.toString.call(s3)) {
      case ct2:
      case at2:
      case ot2: {
        const c6 = new s3.constructor(s3 == null ? void 0 : s3.valueOf());
        return y6(c6, s3), c6;
      }
      case ht3: {
        const c6 = {};
        return y6(c6, s3), c6.length = s3.length, c6[Symbol.iterator] = s3[Symbol.iterator], c6;
      }
      default:
        return;
    }
  });
}
function pt3(s3) {
  return se3(s3);
}
function dt3(s3) {
  return s3 !== null && typeof s3 == "object" && nt2(s3) === "[object Arguments]";
}
function ie3(s3) {
  return W2(s3);
}
function re3(s3) {
  var _a;
  if (typeof s3 != "object" || s3 == null) return false;
  if (Object.getPrototypeOf(s3) === null) return true;
  if (Object.prototype.toString.call(s3) !== "[object Object]") {
    const e = s3[Symbol.toStringTag];
    return e == null || !((_a = Object.getOwnPropertyDescriptor(s3, Symbol.toStringTag)) == null ? void 0 : _a.writable) ? false : s3.toString() === `[object ${e}]`;
  }
  let t = s3;
  for (; Object.getPrototypeOf(t) !== null; ) t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(s3) === t;
}
function ne3(s3, ...t) {
  const e = t.slice(0, -1), i5 = t[t.length - 1];
  let n4 = s3;
  for (let a2 = 0; a2 < e.length; a2++) {
    const r2 = e[a2];
    n4 = F3(n4, r2, i5, /* @__PURE__ */ new Map());
  }
  return n4;
}
function F3(s3, t, e, i5) {
  if (k7(s3) && (s3 = Object(s3)), t == null || typeof t != "object") return s3;
  if (i5.has(t)) return _t3(i5.get(t));
  if (i5.set(t, s3), Array.isArray(t)) {
    t = t.slice();
    for (let a2 = 0; a2 < t.length; a2++) t[a2] = t[a2] ?? void 0;
  }
  const n4 = [...Object.keys(t), ...rt(t)];
  for (let a2 = 0; a2 < n4.length; a2++) {
    const r2 = n4[a2];
    let c6 = t[r2], o2 = s3[r2];
    if (dt3(c6) && (c6 = { ...c6 }), dt3(o2) && (o2 = { ...o2 }), typeof Buffer < "u" && Buffer.isBuffer(c6) && (c6 = pt3(c6)), Array.isArray(c6)) if (typeof o2 == "object" && o2 != null) {
      const w5 = [], v7 = Reflect.ownKeys(o2);
      for (let P4 = 0; P4 < v7.length; P4++) {
        const p6 = v7[P4];
        w5[p6] = o2[p6];
      }
      o2 = w5;
    } else o2 = [];
    const m3 = e(o2, c6, r2, s3, t, i5);
    m3 != null ? s3[r2] = m3 : Array.isArray(c6) || it3(o2) && it3(c6) ? s3[r2] = F3(o2, c6, e, i5) : o2 == null && re3(c6) ? s3[r2] = F3({}, c6, e, i5) : o2 == null && ie3(c6) ? s3[r2] = pt3(c6) : (o2 === void 0 || c6 !== void 0) && (s3[r2] = c6);
  }
  return s3;
}
function ae3(s3, ...t) {
  return ne3(s3, ...t, Rt3);
}
var ce3 = Object.defineProperty;
var oe2 = Object.defineProperties;
var he3 = Object.getOwnPropertyDescriptors;
var ut3 = Object.getOwnPropertySymbols;
var pe3 = Object.prototype.hasOwnProperty;
var de3 = Object.prototype.propertyIsEnumerable;
var lt2 = (s3, t, e) => t in s3 ? ce3(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var L3 = (s3, t) => {
  for (var e in t || (t = {})) pe3.call(t, e) && lt2(s3, e, t[e]);
  if (ut3) for (var e of ut3(t)) de3.call(t, e) && lt2(s3, e, t[e]);
  return s3;
};
var ue3 = (s3, t) => oe2(s3, he3(t));
function d3(s3, t, e) {
  var i5;
  const n4 = Ne(s3);
  return ((i5 = t.rpcMap) == null ? void 0 : i5[n4.reference]) || `${st}?chainId=${n4.namespace}:${n4.reference}&projectId=${e}`;
}
function b5(s3) {
  return s3.includes(":") ? s3.split(":")[1] : s3;
}
function ft3(s3) {
  return s3.map((t) => `${t.split(":")[0]}:${t.split(":")[1]}`);
}
function le3(s3, t) {
  const e = Object.keys(t.namespaces).filter((n4) => n4.includes(s3));
  if (!e.length) return [];
  const i5 = [];
  return e.forEach((n4) => {
    const a2 = t.namespaces[n4].accounts;
    i5.push(...a2);
  }), i5;
}
function M3(s3 = {}, t = {}) {
  const e = mt3(s3), i5 = mt3(t);
  return ae3(e, i5);
}
function mt3(s3) {
  var t, e, i5, n4, a2;
  const r2 = {};
  if (!Oe(s3)) return r2;
  for (const [c6, o2] of Object.entries(s3)) {
    const m3 = yn(c6) ? [c6] : o2.chains, w5 = o2.methods || [], v7 = o2.events || [], P4 = o2.rpcMap || {}, p6 = yo(c6);
    r2[p6] = ue3(L3(L3({}, r2[p6]), o2), { chains: ot(m3, (t = r2[p6]) == null ? void 0 : t.chains), methods: ot(w5, (e = r2[p6]) == null ? void 0 : e.methods), events: ot(v7, (i5 = r2[p6]) == null ? void 0 : i5.events) }), (Oe(P4) || Oe(((n4 = r2[p6]) == null ? void 0 : n4.rpcMap) || {})) && (r2[p6].rpcMap = L3(L3({}, P4), (a2 = r2[p6]) == null ? void 0 : a2.rpcMap));
  }
  return r2;
}
function vt(s3) {
  return s3.includes(":") ? s3.split(":")[2] : s3;
}
function gt3(s3) {
  const t = {};
  for (const [e, i5] of Object.entries(s3)) {
    const n4 = i5.methods || [], a2 = i5.events || [], r2 = i5.accounts || [], c6 = yn(e) ? [e] : i5.chains ? i5.chains : ft3(i5.accounts);
    t[e] = { chains: c6, methods: n4, events: a2, accounts: r2 };
  }
  return t;
}
function K3(s3) {
  return typeof s3 == "number" ? s3 : s3.includes("0x") ? parseInt(s3, 16) : (s3 = s3.includes(":") ? s3.split(":")[1] : s3, isNaN(Number(s3)) ? s3 : Number(s3));
}
var Pt3 = {};
var h5 = (s3) => Pt3[s3];
var V4 = (s3, t) => {
  Pt3[s3] = t;
};
var fe2 = Object.defineProperty;
var me3 = (s3, t, e) => t in s3 ? fe2(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var O5 = (s3, t, e) => me3(s3, typeof t != "symbol" ? t + "" : t, e);
var ve2 = class {
  constructor(t) {
    O5(this, "name", "polkadot"), O5(this, "client"), O5(this, "httpProviders"), O5(this, "events"), O5(this, "namespace"), O5(this, "chainId"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i5;
      const n4 = b5(e);
      t[n4] = this.createHttpProvider(n4, (i5 = this.namespace.rpcMap) == null ? void 0 : i5[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProvider(t, e) {
    const i5 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i5, h5("disableProviderPing")));
  }
};
var ge3 = Object.defineProperty;
var Pe3 = Object.defineProperties;
var we3 = Object.getOwnPropertyDescriptors;
var wt3 = Object.getOwnPropertySymbols;
var ye3 = Object.prototype.hasOwnProperty;
var be3 = Object.prototype.propertyIsEnumerable;
var X2 = (s3, t, e) => t in s3 ? ge3(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var yt3 = (s3, t) => {
  for (var e in t || (t = {})) ye3.call(t, e) && X2(s3, e, t[e]);
  if (wt3) for (var e of wt3(t)) be3.call(t, e) && X2(s3, e, t[e]);
  return s3;
};
var bt2 = (s3, t) => Pe3(s3, we3(t));
var A3 = (s3, t, e) => X2(s3, typeof t != "symbol" ? t + "" : t, e);
var Ie3 = class {
  constructor(t) {
    A3(this, "name", "eip155"), A3(this, "client"), A3(this, "chainId"), A3(this, "namespace"), A3(this, "httpProviders"), A3(this, "events"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(t) {
    switch (t.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(t);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(t);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(t);
    }
    return this.namespace.methods.includes(t.request.method) ? await this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(parseInt(t), e), this.chainId = parseInt(t), this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  createHttpProvider(t, e) {
    const i5 = e || d3(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
    if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i5, h5("disableProviderPing")));
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i5;
      const n4 = parseInt(b5(e));
      t[n4] = this.createHttpProvider(n4, (i5 = this.namespace.rpcMap) == null ? void 0 : i5[e]);
    }), t;
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const t = this.chainId, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  async handleSwitchChain(t) {
    var e, i5;
    let n4 = t.request.params ? (e = t.request.params[0]) == null ? void 0 : e.chainId : "0x0";
    n4 = n4.startsWith("0x") ? n4 : `0x${n4}`;
    const a2 = parseInt(n4, 16);
    if (this.isChainApproved(a2)) this.setDefaultChain(`${a2}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: t.topic, request: { method: t.request.method, params: [{ chainId: n4 }] }, chainId: (i5 = this.namespace.chains) == null ? void 0 : i5[0] }), this.setDefaultChain(`${a2}`);
    else throw new Error(`Failed to switch to chain 'eip155:${a2}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(t) {
    return this.namespace.chains.includes(`${this.name}:${t}`);
  }
  async getCapabilities(t) {
    var e, i5, n4, a2, r2;
    const c6 = (i5 = (e = t.request) == null ? void 0 : e.params) == null ? void 0 : i5[0], o2 = ((a2 = (n4 = t.request) == null ? void 0 : n4.params) == null ? void 0 : a2[1]) || [], m3 = `${c6}${o2.join(",")}`;
    if (!c6) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const w5 = this.client.session.get(t.topic), v7 = ((r2 = w5 == null ? void 0 : w5.sessionProperties) == null ? void 0 : r2.capabilities) || {};
    if (v7 != null && v7[m3]) return v7 == null ? void 0 : v7[m3];
    const P4 = await this.client.request(t);
    try {
      await this.client.session.update(t.topic, { sessionProperties: bt2(yt3({}, w5.sessionProperties || {}), { capabilities: bt2(yt3({}, v7 || {}), { [m3]: P4 }) }) });
    } catch (p6) {
      console.warn("Failed to update session with capabilities", p6);
    }
    return P4;
  }
  async getCallStatus(t) {
    var e, i5;
    const n4 = this.client.session.get(t.topic), a2 = (e = n4.sessionProperties) == null ? void 0 : e.bundler_name;
    if (a2) {
      const c6 = this.getBundlerUrl(t.chainId, a2);
      try {
        return await this.getUserOperationReceipt(c6, t);
      } catch (o2) {
        console.warn("Failed to fetch call status from bundler", o2, c6);
      }
    }
    const r2 = (i5 = n4.sessionProperties) == null ? void 0 : i5.bundler_url;
    if (r2) try {
      return await this.getUserOperationReceipt(r2, t);
    } catch (c6) {
      console.warn("Failed to fetch call status from custom bundler", c6, r2);
    }
    if (this.namespace.methods.includes(t.request.method)) return await this.client.request(t);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(t, e) {
    var i5;
    const n4 = new URL(t), a2 = await fetch(n4, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(i5 = e.request.params) == null ? void 0 : i5[0]])) });
    if (!a2.ok) throw new Error(`Failed to fetch user operation receipt - ${a2.status}`);
    return await a2.json();
  }
  getBundlerUrl(t, e) {
    return `${jt3}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`;
  }
};
var $e3 = Object.defineProperty;
var Oe3 = (s3, t, e) => t in s3 ? $e3(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var C5 = (s3, t, e) => Oe3(s3, typeof t != "symbol" ? t + "" : t, e);
var Ae2 = class {
  constructor(t) {
    C5(this, "name", "solana"), C5(this, "client"), C5(this, "httpProviders"), C5(this, "events"), C5(this, "namespace"), C5(this, "chainId"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i5;
      const n4 = b5(e);
      t[n4] = this.createHttpProvider(n4, (i5 = this.namespace.rpcMap) == null ? void 0 : i5[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProvider(t, e) {
    const i5 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i5, h5("disableProviderPing")));
  }
};
var Ce3 = Object.defineProperty;
var He3 = (s3, t, e) => t in s3 ? Ce3(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var H2 = (s3, t, e) => He3(s3, typeof t != "symbol" ? t + "" : t, e);
var Ee4 = class {
  constructor(t) {
    H2(this, "name", "cosmos"), H2(this, "client"), H2(this, "httpProviders"), H2(this, "events"), H2(this, "namespace"), H2(this, "chainId"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i5;
      const n4 = b5(e);
      t[n4] = this.createHttpProvider(n4, (i5 = this.namespace.rpcMap) == null ? void 0 : i5[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProvider(t, e) {
    const i5 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i5, h5("disableProviderPing")));
  }
};
var Ne2 = Object.defineProperty;
var Se3 = (s3, t, e) => t in s3 ? Ne2(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var E6 = (s3, t, e) => Se3(s3, typeof t != "symbol" ? t + "" : t, e);
var De3 = class {
  constructor(t) {
    E6(this, "name", "algorand"), E6(this, "client"), E6(this, "httpProviders"), E6(this, "events"), E6(this, "namespace"), E6(this, "chainId"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (!this.httpProviders[t]) {
      const i5 = e || d3(`${this.name}:${t}`, this.namespace, this.client.core.projectId);
      if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i5);
    }
    this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i5;
      t[e] = this.createHttpProvider(e, (i5 = this.namespace.rpcMap) == null ? void 0 : i5[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProvider(t, e) {
    const i5 = e || d3(t, this.namespace, this.client.core.projectId);
    return typeof i5 > "u" ? void 0 : new o(new f2(i5, h5("disableProviderPing")));
  }
};
var qe3 = Object.defineProperty;
var je3 = (s3, t, e) => t in s3 ? qe3(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var N3 = (s3, t, e) => je3(s3, typeof t != "symbol" ? t + "" : t, e);
var Re = class {
  constructor(t) {
    N3(this, "name", "cip34"), N3(this, "client"), N3(this, "httpProviders"), N3(this, "events"), N3(this, "namespace"), N3(this, "chainId"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      const i5 = this.getCardanoRPCUrl(e), n4 = b5(e);
      t[n4] = this.createHttpProvider(n4, i5);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  getCardanoRPCUrl(t) {
    const e = this.namespace.rpcMap;
    if (e) return e[t];
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProvider(t, e) {
    const i5 = e || this.getCardanoRPCUrl(t);
    if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i5, h5("disableProviderPing")));
  }
};
var _e4 = Object.defineProperty;
var Ue3 = (s3, t, e) => t in s3 ? _e4(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var S5 = (s3, t, e) => Ue3(s3, typeof t != "symbol" ? t + "" : t, e);
var Fe3 = class {
  constructor(t) {
    S5(this, "name", "elrond"), S5(this, "client"), S5(this, "httpProviders"), S5(this, "events"), S5(this, "namespace"), S5(this, "chainId"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i5;
      const n4 = b5(e);
      t[n4] = this.createHttpProvider(n4, (i5 = this.namespace.rpcMap) == null ? void 0 : i5[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProvider(t, e) {
    const i5 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i5, h5("disableProviderPing")));
  }
};
var Le3 = Object.defineProperty;
var Me4 = (s3, t, e) => t in s3 ? Le3(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var D2 = (s3, t, e) => Me4(s3, typeof t != "symbol" ? t + "" : t, e);
var xe2 = class {
  constructor(t) {
    D2(this, "name", "multiversx"), D2(this, "client"), D2(this, "httpProviders"), D2(this, "events"), D2(this, "namespace"), D2(this, "chainId"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i5;
      const n4 = b5(e);
      t[n4] = this.createHttpProvider(n4, (i5 = this.namespace.rpcMap) == null ? void 0 : i5[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProvider(t, e) {
    const i5 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i5, h5("disableProviderPing")));
  }
};
var Be3 = Object.defineProperty;
var Ge4 = (s3, t, e) => t in s3 ? Be3(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var q2 = (s3, t, e) => Ge4(s3, typeof t != "symbol" ? t + "" : t, e);
var Je3 = class {
  constructor(t) {
    q2(this, "name", "near"), q2(this, "client"), q2(this, "httpProviders"), q2(this, "events"), q2(this, "namespace"), q2(this, "chainId"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i5 = e || d3(`${this.name}:${t}`, this.namespace);
      if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i5);
    }
    this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      var i5;
      t[e] = this.createHttpProvider(e, (i5 = this.namespace.rpcMap) == null ? void 0 : i5[e]);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProvider(t, e) {
    const i5 = e || d3(t, this.namespace);
    return typeof i5 > "u" ? void 0 : new o(new f2(i5, h5("disableProviderPing")));
  }
};
var ze3 = Object.defineProperty;
var ke4 = (s3, t, e) => t in s3 ? ze3(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var j2 = (s3, t, e) => ke4(s3, typeof t != "symbol" ? t + "" : t, e);
var We4 = class {
  constructor(t) {
    j2(this, "name", "tezos"), j2(this, "client"), j2(this, "httpProviders"), j2(this, "events"), j2(this, "namespace"), j2(this, "chainId"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace = Object.assign(this.namespace, t);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider().request(t.request);
  }
  setDefaultChain(t, e) {
    if (this.chainId = t, !this.httpProviders[t]) {
      const i5 = e || d3(`${this.name}:${t}`, this.namespace);
      if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
      this.setHttpProvider(t, i5);
    }
    this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const t = {};
    return this.namespace.chains.forEach((e) => {
      t[e] = this.createHttpProvider(e);
    }), t;
  }
  getHttpProvider() {
    const t = `${this.name}:${this.chainId}`, e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProvider(t, e) {
    const i5 = e || d3(t, this.namespace);
    return typeof i5 > "u" ? void 0 : new o(new f2(i5));
  }
};
var Ke4 = Object.defineProperty;
var Ve3 = (s3, t, e) => t in s3 ? Ke4(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var R3 = (s3, t, e) => Ve3(s3, typeof t != "symbol" ? t + "" : t, e);
var Xe3 = class {
  constructor(t) {
    R3(this, "name", I3), R3(this, "client"), R3(this, "httpProviders"), R3(this, "events"), R3(this, "namespace"), R3(this, "chainId"), this.namespace = t.namespace, this.events = h5("events"), this.client = h5("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(t) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(t.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(t.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(t.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(t.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(t) {
    return this.namespace.methods.includes(t.request.method) ? this.client.request(t) : this.getHttpProvider(t.chainId).request(t.request);
  }
  setDefaultChain(t, e) {
    this.httpProviders[t] || this.setHttpProvider(t, e), this.chainId = t, this.events.emit(u2.DEFAULT_CHAIN_CHANGED, `${this.name}:${t}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const t = this.namespace.chains[0];
    if (!t) throw new Error("ChainId not found");
    return t.split(":")[1];
  }
  getAccounts() {
    const t = this.namespace.accounts;
    return t ? [...new Set(t.filter((e) => e.split(":")[1] === this.chainId.toString()).map((e) => e.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var t, e;
    const i5 = {};
    return (e = (t = this.namespace) == null ? void 0 : t.accounts) == null || e.forEach((n4) => {
      const a2 = Ne(n4);
      i5[`${a2.namespace}:${a2.reference}`] = this.createHttpProvider(n4);
    }), i5;
  }
  getHttpProvider(t) {
    const e = this.httpProviders[t];
    if (typeof e > "u") throw new Error(`JSON-RPC provider for ${t} not found`);
    return e;
  }
  setHttpProvider(t, e) {
    const i5 = this.createHttpProvider(t, e);
    i5 && (this.httpProviders[t] = i5);
  }
  createHttpProvider(t, e) {
    const i5 = e || d3(t, this.namespace, this.client.core.projectId);
    if (!i5) throw new Error(`No RPC url provided for chainId: ${t}`);
    return new o(new f2(i5, h5("disableProviderPing")));
  }
};
var Ye3 = Object.defineProperty;
var Qe4 = Object.defineProperties;
var Ze4 = Object.getOwnPropertyDescriptors;
var It3 = Object.getOwnPropertySymbols;
var Te2 = Object.prototype.hasOwnProperty;
var ts2 = Object.prototype.propertyIsEnumerable;
var Y3 = (s3, t, e) => t in s3 ? Ye3(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var x4 = (s3, t) => {
  for (var e in t || (t = {})) Te2.call(t, e) && Y3(s3, e, t[e]);
  if (It3) for (var e of It3(t)) ts2.call(t, e) && Y3(s3, e, t[e]);
  return s3;
};
var Q2 = (s3, t) => Qe4(s3, Ze4(t));
var l5 = (s3, t, e) => Y3(s3, typeof t != "symbol" ? t + "" : t, e);
var B3 = class _B {
  constructor(t) {
    l5(this, "client"), l5(this, "namespaces"), l5(this, "optionalNamespaces"), l5(this, "sessionProperties"), l5(this, "scopedProperties"), l5(this, "events", new import_events5.default()), l5(this, "rpcProviders", {}), l5(this, "session"), l5(this, "providerOpts"), l5(this, "logger"), l5(this, "uri"), l5(this, "disableProviderPing", false), this.providerOpts = t, this.logger = typeof (t == null ? void 0 : t.logger) < "u" && typeof (t == null ? void 0 : t.logger) != "string" ? t.logger : (0, import_pino.default)(k({ level: (t == null ? void 0 : t.logger) || et2 })), this.disableProviderPing = (t == null ? void 0 : t.disableProviderPing) || false;
  }
  static async init(t) {
    const e = new _B(t);
    return await e.initialize(), e;
  }
  async request(t, e, i5) {
    const [n4, a2] = this.validateChain(e);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(n4).request({ request: x4({}, t), chainId: `${n4}:${a2}`, topic: this.session.topic, expiry: i5 });
  }
  sendAsync(t, e, i5, n4) {
    const a2 = (/* @__PURE__ */ new Date()).getTime();
    this.request(t, i5, n4).then((r2) => e(null, formatJsonRpcResult(a2, r2))).catch((r2) => e(r2, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var t;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (t = this.session) == null ? void 0 : t.topic, reason: Nt("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(t) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(t), await this.cleanupPendingPairings(), !t.skipPairing) return await this.pair(t.pairingTopic);
  }
  async authenticate(t, e) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(t), await this.cleanupPendingPairings();
    const { uri: i5, response: n4 } = await this.client.authenticate(t, e);
    i5 && (this.uri = i5, this.events.emit("display_uri", i5));
    const a2 = await n4();
    if (this.session = a2.session, this.session) {
      const r2 = gt3(this.session.namespaces);
      this.namespaces = M3(this.namespaces, r2), await this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return a2;
  }
  on(t, e) {
    this.events.on(t, e);
  }
  once(t, e) {
    this.events.once(t, e);
  }
  removeListener(t, e) {
    this.events.removeListener(t, e);
  }
  off(t, e) {
    this.events.off(t, e);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(t) {
    const { uri: e, approval: i5 } = await this.client.connect({ pairingTopic: t, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties, scopedProperties: this.scopedProperties });
    e && (this.uri = e, this.events.emit("display_uri", e));
    const n4 = await i5();
    this.session = n4;
    const a2 = gt3(n4.namespaces);
    return this.namespaces = M3(this.namespaces, a2), await this.persist("namespaces", this.namespaces), await this.persist("optionalNamespaces", this.optionalNamespaces), this.onConnect(), this.session;
  }
  setDefaultChain(t, e) {
    try {
      if (!this.session) return;
      const [i5, n4] = this.validateChain(t), a2 = this.getProvider(i5);
      a2.name === I3 ? a2.setDefaultChain(`${i5}:${n4}`, e) : a2.setDefaultChain(n4, e);
    } catch (i5) {
      if (!/Please call connect/.test(i5.message)) throw i5;
    }
  }
  async cleanupPendingPairings(t = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const e = this.client.pairing.getAll();
    if (se(e)) {
      for (const i5 of e) t.deletePairings ? this.client.core.expirer.set(i5.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(i5.topic);
      this.logger.info(`Inactive pairings cleared: ${e.length}`);
    }
  }
  abortPairingAttempt() {
    this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.");
  }
  async checkStorage() {
    this.namespaces = await this.getFromStore("namespaces") || {}, this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.session && this.createProviders();
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    var t, e;
    if (this.client = this.providerOpts.client || await Ee3.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || et2, relayUrl: this.providerOpts.relayUrl || St4, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.providerOpts.session) try {
      this.session = this.client.session.get(this.providerOpts.session.topic);
    } catch (i5) {
      throw this.logger.error("Failed to get session", i5), new Error(`The provided session: ${(e = (t = this.providerOpts) == null ? void 0 : t.session) == null ? void 0 : e.topic} doesn't exist in the Sign client`);
    }
    else {
      const i5 = this.client.session.getAll();
      this.session = i5[0];
    }
    this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const t = [...new Set(Object.keys(this.session.namespaces).map((e) => yo(e)))];
    V4("client", this.client), V4("events", this.events), V4("disableProviderPing", this.disableProviderPing), t.forEach((e) => {
      if (!this.session) return;
      const i5 = le3(e, this.session), n4 = ft3(i5), a2 = M3(this.namespaces, this.optionalNamespaces), r2 = Q2(x4({}, a2[e]), { accounts: i5, chains: n4 });
      switch (e) {
        case "eip155":
          this.rpcProviders[e] = new Ie3({ namespace: r2 });
          break;
        case "algorand":
          this.rpcProviders[e] = new De3({ namespace: r2 });
          break;
        case "solana":
          this.rpcProviders[e] = new Ae2({ namespace: r2 });
          break;
        case "cosmos":
          this.rpcProviders[e] = new Ee4({ namespace: r2 });
          break;
        case "polkadot":
          this.rpcProviders[e] = new ve2({ namespace: r2 });
          break;
        case "cip34":
          this.rpcProviders[e] = new Re({ namespace: r2 });
          break;
        case "elrond":
          this.rpcProviders[e] = new Fe3({ namespace: r2 });
          break;
        case "multiversx":
          this.rpcProviders[e] = new xe2({ namespace: r2 });
          break;
        case "near":
          this.rpcProviders[e] = new Je3({ namespace: r2 });
          break;
        case "tezos":
          this.rpcProviders[e] = new We4({ namespace: r2 });
          break;
        default:
          this.rpcProviders[I3] ? this.rpcProviders[I3].updateNamespace(r2) : this.rpcProviders[I3] = new Xe3({ namespace: r2 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (t) => {
      var e;
      const { topic: i5 } = t;
      i5 === ((e = this.session) == null ? void 0 : e.topic) && this.events.emit("session_ping", t);
    }), this.client.on("session_event", (t) => {
      var e;
      const { params: i5, topic: n4 } = t;
      if (n4 !== ((e = this.session) == null ? void 0 : e.topic)) return;
      const { event: a2 } = i5;
      if (a2.name === "accountsChanged") {
        const r2 = a2.data;
        r2 && se(r2) && this.events.emit("accountsChanged", r2.map(vt));
      } else if (a2.name === "chainChanged") {
        const r2 = i5.chainId, c6 = i5.event.data, o2 = yo(r2), m3 = K3(r2) !== K3(c6) ? `${o2}:${K3(c6)}` : r2;
        this.onChainChanged(m3);
      } else this.events.emit(a2.name, a2.data);
      this.events.emit("session_event", t);
    }), this.client.on("session_update", ({ topic: t, params: e }) => {
      var i5, n4;
      if (t !== ((i5 = this.session) == null ? void 0 : i5.topic)) return;
      const { namespaces: a2 } = e, r2 = (n4 = this.client) == null ? void 0 : n4.session.get(t);
      this.session = Q2(x4({}, r2), { namespaces: a2 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: t, params: e });
    }), this.client.on("session_delete", async (t) => {
      var e;
      t.topic === ((e = this.session) == null ? void 0 : e.topic) && (await this.cleanup(), this.events.emit("session_delete", t), this.events.emit("disconnect", Q2(x4({}, Nt("USER_DISCONNECTED")), { data: t.topic })));
    }), this.on(u2.DEFAULT_CHAIN_CHANGED, (t) => {
      this.onChainChanged(t, true);
    });
  }
  getProvider(t) {
    return this.rpcProviders[t] || this.rpcProviders[I3];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((t) => {
      var e;
      this.getProvider(t).updateNamespace((e = this.session) == null ? void 0 : e.namespaces[t]);
    });
  }
  setNamespaces(t) {
    const { namespaces: e = {}, optionalNamespaces: i5 = {}, sessionProperties: n4, scopedProperties: a2 } = t;
    this.optionalNamespaces = M3(e, i5), this.sessionProperties = n4, this.scopedProperties = a2;
  }
  validateChain(t) {
    const [e, i5] = (t == null ? void 0 : t.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [e, i5];
    if (e && !Object.keys(this.namespaces || {}).map((r2) => yo(r2)).includes(e)) throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);
    if (e && i5) return [e, i5];
    const n4 = yo(Object.keys(this.namespaces)[0]), a2 = this.rpcProviders[n4].getDefaultChain();
    return [n4, a2];
  }
  async requestAccounts() {
    const [t] = this.validateChain();
    return await this.getProvider(t).requestAccounts();
  }
  async onChainChanged(t, e = false) {
    if (!this.namespaces) return;
    const [i5, n4] = this.validateChain(t);
    if (!n4) return;
    this.updateNamespaceChain(i5, n4), this.events.emit("chainChanged", n4);
    const a2 = this.getProvider(i5).getDefaultChain();
    e || this.getProvider(i5).setDefaultChain(n4), this.emitAccountsChangedOnChainChange({ namespace: i5, previousChainId: a2, newChainId: t }), await this.persist("namespaces", this.namespaces);
  }
  emitAccountsChangedOnChainChange({ namespace: t, previousChainId: e, newChainId: i5 }) {
    var n4, a2;
    try {
      if (e === i5) return;
      const r2 = (a2 = (n4 = this.session) == null ? void 0 : n4.namespaces[t]) == null ? void 0 : a2.accounts;
      if (!r2) return;
      const c6 = r2.filter((o2) => o2.includes(`${i5}:`)).map(vt);
      if (!se(c6)) return;
      this.events.emit("accountsChanged", c6);
    } catch (r2) {
      this.logger.warn("Failed to emit accountsChanged on chain change", r2);
    }
  }
  updateNamespaceChain(t, e) {
    if (!this.namespaces) return;
    const i5 = this.namespaces[t] ? t : `${t}:${e}`, n4 = { chains: [], methods: [], events: [], defaultChain: e };
    this.namespaces[i5] ? this.namespaces[i5] && (this.namespaces[i5].defaultChain = e) : this.namespaces[i5] = n4;
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, await this.deleteFromStore("namespaces"), await this.deleteFromStore("optionalNamespaces"), await this.deleteFromStore("sessionProperties"), this.session = void 0, await this.cleanupPendingPairings({ deletePairings: true }), await this.cleanupStorage();
  }
  async persist(t, e) {
    var i5;
    const n4 = ((i5 = this.session) == null ? void 0 : i5.topic) || "";
    await this.client.core.storage.setItem(`${U5}/${t}${n4}`, e);
  }
  async getFromStore(t) {
    var e;
    const i5 = ((e = this.session) == null ? void 0 : e.topic) || "";
    return await this.client.core.storage.getItem(`${U5}/${t}${i5}`);
  }
  async deleteFromStore(t) {
    var e;
    const i5 = ((e = this.session) == null ? void 0 : e.topic) || "";
    await this.client.core.storage.removeItem(`${U5}/${t}${i5}`);
  }
  async cleanupStorage() {
    var t;
    try {
      if (((t = this.client) == null ? void 0 : t.session.length) > 0) return;
      const e = await this.client.core.storage.getKeys();
      for (const i5 of e) i5.startsWith(U5) && await this.client.core.storage.removeItem(i5);
    } catch (e) {
      this.logger.warn("Failed to cleanup storage", e);
    }
  }
};
var es2 = B3;

// node_modules/@walletconnect/ethereum-provider/dist/index.es.js
var $4 = "wc";
var k8 = "ethereum_provider";
var q3 = `${$4}@2:${k8}:`;
var U6 = "https://rpc.walletconnect.org/v1/";
var f8 = ["eth_sendTransaction", "personal_sign"];
var A4 = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode", "wallet_sendCalls", "wallet_getCapabilities", "wallet_getCallsStatus", "wallet_showCallsStatus"];
var C6 = ["chainChanged", "accountsChanged"];
var P3 = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
var D3 = async () => {
  const { createAppKit: s3 } = await import("./core-I7OUAZRH.js");
  return s3;
};
var z5 = Object.defineProperty;
var L4 = Object.defineProperties;
var K4 = Object.getOwnPropertyDescriptors;
var M4 = Object.getOwnPropertySymbols;
var Q3 = Object.prototype.hasOwnProperty;
var V5 = Object.prototype.propertyIsEnumerable;
var _4 = (s3, t, e) => t in s3 ? z5(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var v6 = (s3, t) => {
  for (var e in t || (t = {})) Q3.call(t, e) && _4(s3, e, t[e]);
  if (M4) for (var e of M4(t)) V5.call(t, e) && _4(s3, e, t[e]);
  return s3;
};
var w4 = (s3, t) => L4(s3, K4(t));
var p5 = (s3, t, e) => _4(s3, typeof t != "symbol" ? t + "" : t, e);
function I4(s3) {
  return Number(s3[0].split(":")[1]);
}
function E7(s3) {
  return `0x${s3.toString(16)}`;
}
function G3(s3) {
  const { chains: t, optionalChains: e, methods: n4, optionalMethods: i5, events: a2, optionalEvents: o2, rpcMap: u3 } = s3;
  if (!se(t)) throw new Error("Invalid chains");
  const c6 = { chains: t, methods: n4 || f8, events: a2 || C6, rpcMap: v6({}, t.length ? { [I4(t)]: u3[I4(t)] } : {}) }, l6 = a2 == null ? void 0 : a2.filter((d4) => !C6.includes(d4)), r2 = n4 == null ? void 0 : n4.filter((d4) => !f8.includes(d4));
  if (!e && !o2 && !i5 && !(l6 != null && l6.length) && !(r2 != null && r2.length)) return { required: t.length ? c6 : void 0 };
  const m3 = (l6 == null ? void 0 : l6.length) && (r2 == null ? void 0 : r2.length) || !e, h6 = { chains: [...new Set(m3 ? c6.chains.concat(e || []) : e)], methods: [...new Set(c6.methods.concat(i5 != null && i5.length ? i5 : A4))], events: [...new Set(c6.events.concat(o2 != null && o2.length ? o2 : P3))], rpcMap: u3 };
  return { required: t.length ? c6 : void 0, optional: e.length ? h6 : void 0 };
}
var b6 = class _b {
  constructor() {
    p5(this, "events", new import_events6.EventEmitter()), p5(this, "namespace", "eip155"), p5(this, "accounts", []), p5(this, "signer"), p5(this, "chainId", 1), p5(this, "modal"), p5(this, "rpc"), p5(this, "STORAGE_KEY", q3), p5(this, "on", (t, e) => (this.events.on(t, e), this)), p5(this, "once", (t, e) => (this.events.once(t, e), this)), p5(this, "removeListener", (t, e) => (this.events.removeListener(t, e), this)), p5(this, "off", (t, e) => (this.events.off(t, e), this)), p5(this, "parseAccount", (t) => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t), this.signer = {}, this.rpc = {};
  }
  static async init(t) {
    const e = new _b();
    return await e.initialize(t), e;
  }
  async request(t, e) {
    return await this.signer.request(t, this.formatChainId(this.chainId), e);
  }
  sendAsync(t, e, n4) {
    this.signer.sendAsync(t, e, this.formatChainId(this.chainId), n4);
  }
  get connected() {
    return this.signer.client ? this.signer.client.core.relayer.connected : false;
  }
  get connecting() {
    return this.signer.client ? this.signer.client.core.relayer.connecting : false;
  }
  async enable() {
    return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
  }
  async connect(t) {
    var e;
    if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts(t);
    const { required: n4, optional: i5 } = G3(this.rpc);
    try {
      const a2 = await new Promise(async (u3, c6) => {
        var l6, r2;
        this.rpc.showQrModal && ((l6 = this.modal) == null || l6.open(), (r2 = this.modal) == null || r2.subscribeState((h6) => {
          !h6.open && !this.signer.session && (this.signer.abortPairingAttempt(), c6(new Error("Connection request reset. Please try again.")));
        }));
        const m3 = t != null && t.scopedProperties ? { [this.namespace]: t.scopedProperties } : void 0;
        await this.signer.connect(w4(v6({ namespaces: v6({}, n4 && { [this.namespace]: n4 }) }, i5 && { optionalNamespaces: { [this.namespace]: i5 } }), { pairingTopic: t == null ? void 0 : t.pairingTopic, scopedProperties: m3 })).then((h6) => {
          u3(h6);
        }).catch((h6) => {
          var d4;
          (d4 = this.modal) == null || d4.showErrorMessage("Unable to connect"), c6(new Error(h6.message));
        });
      });
      if (!a2) return;
      const o2 = Ko(a2.namespaces, [this.namespace]);
      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o2), this.setAccounts(o2), this.events.emit("connect", { chainId: E7(this.chainId) });
    } catch (a2) {
      throw this.signer.logger.error(a2), a2;
    } finally {
      (e = this.modal) == null || e.close();
    }
  }
  async authenticate(t, e) {
    var n4;
    if (!this.signer.client) throw new Error("Provider not initialized. Call init() first");
    this.loadConnectOpts({ chains: t == null ? void 0 : t.chains });
    try {
      const i5 = await new Promise(async (o2, u3) => {
        var c6, l6;
        this.rpc.showQrModal && ((c6 = this.modal) == null || c6.open(), (l6 = this.modal) == null || l6.subscribeState((r2) => {
          !r2.open && !this.signer.session && (this.signer.abortPairingAttempt(), u3(new Error("Connection request reset. Please try again.")));
        })), await this.signer.authenticate(w4(v6({}, t), { chains: this.rpc.chains }), e).then((r2) => {
          o2(r2);
        }).catch((r2) => {
          var m3;
          (m3 = this.modal) == null || m3.showErrorMessage("Unable to connect"), u3(new Error(r2.message));
        });
      }), a2 = i5.session;
      if (a2) {
        const o2 = Ko(a2.namespaces, [this.namespace]);
        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : o2), this.setAccounts(o2), this.events.emit("connect", { chainId: E7(this.chainId) });
      }
      return i5;
    } catch (i5) {
      throw this.signer.logger.error(i5), i5;
    } finally {
      (n4 = this.modal) == null || n4.close();
    }
  }
  async disconnect() {
    this.session && await this.signer.disconnect(), this.reset();
  }
  get isWalletConnect() {
    return true;
  }
  get session() {
    return this.signer.session;
  }
  registerEventListeners() {
    this.signer.on("session_event", (t) => {
      const { params: e } = t, { event: n4 } = e;
      n4.name === "accountsChanged" ? (this.accounts = this.parseAccounts(n4.data), this.events.emit("accountsChanged", this.accounts)) : n4.name === "chainChanged" ? this.setChainId(this.formatChainId(n4.data)) : this.events.emit(n4.name, n4.data), this.events.emit("session_event", t);
    }), this.signer.on("accountsChanged", (t) => {
      this.accounts = this.parseAccounts(t), this.events.emit("accountsChanged", this.accounts);
    }), this.signer.on("chainChanged", (t) => {
      const e = parseInt(t);
      this.chainId = e, this.events.emit("chainChanged", E7(this.chainId)), this.persist();
    }), this.signer.on("session_update", (t) => {
      this.events.emit("session_update", t);
    }), this.signer.on("session_delete", (t) => {
      this.reset(), this.events.emit("session_delete", t), this.events.emit("disconnect", w4(v6({}, Nt("USER_DISCONNECTED")), { data: t.topic, name: "USER_DISCONNECTED" }));
    }), this.signer.on("display_uri", (t) => {
      this.events.emit("display_uri", t);
    });
  }
  switchEthereumChain(t) {
    this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t.toString(16) }] });
  }
  isCompatibleChainId(t) {
    return typeof t == "string" ? t.startsWith(`${this.namespace}:`) : false;
  }
  formatChainId(t) {
    return `${this.namespace}:${t}`;
  }
  parseChainId(t) {
    return Number(t.split(":")[1]);
  }
  setChainIds(t) {
    const e = t.filter((n4) => this.isCompatibleChainId(n4)).map((n4) => this.parseChainId(n4));
    e.length && (this.chainId = e[0], this.events.emit("chainChanged", E7(this.chainId)), this.persist());
  }
  setChainId(t) {
    if (this.isCompatibleChainId(t)) {
      const e = this.parseChainId(t);
      this.chainId = e, this.switchEthereumChain(e);
    }
  }
  parseAccountId(t) {
    const [e, n4, i5] = t.split(":");
    return { chainId: `${e}:${n4}`, address: i5 };
  }
  setAccounts(t) {
    this.accounts = t.filter((e) => this.parseChainId(this.parseAccountId(e).chainId) === this.chainId).map((e) => this.parseAccountId(e).address), this.events.emit("accountsChanged", this.accounts);
  }
  getRpcConfig(t) {
    var e, n4;
    const i5 = (e = t == null ? void 0 : t.chains) != null ? e : [], a2 = (n4 = t == null ? void 0 : t.optionalChains) != null ? n4 : [], o2 = i5.concat(a2);
    if (!o2.length) throw new Error("No chains specified in either `chains` or `optionalChains`");
    const u3 = i5.length ? (t == null ? void 0 : t.methods) || f8 : [], c6 = i5.length ? (t == null ? void 0 : t.events) || C6 : [], l6 = (t == null ? void 0 : t.optionalMethods) || [], r2 = (t == null ? void 0 : t.optionalEvents) || [], m3 = (t == null ? void 0 : t.rpcMap) || this.buildRpcMap(o2, t.projectId), h6 = (t == null ? void 0 : t.qrModalOptions) || void 0;
    return { chains: i5 == null ? void 0 : i5.map((d4) => this.formatChainId(d4)), optionalChains: a2.map((d4) => this.formatChainId(d4)), methods: u3, events: c6, optionalMethods: l6, optionalEvents: r2, rpcMap: m3, showQrModal: !!(t != null && t.showQrModal), qrModalOptions: h6, projectId: t.projectId, metadata: t.metadata };
  }
  buildRpcMap(t, e) {
    const n4 = {};
    return t.forEach((i5) => {
      n4[i5] = this.getRpcUrl(i5, e);
    }), n4;
  }
  async initialize(t) {
    if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? I4(this.rpc.chains) : I4(this.rpc.optionalChains), this.signer = await es2.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: t.disableProviderPing, relayUrl: t.relayUrl, storage: t.storage, storageOptions: t.storageOptions, customStoragePrefix: t.customStoragePrefix, telemetryEnabled: t.telemetryEnabled, logger: t.logger }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
      let e;
      try {
        const n4 = await D3(), { convertWCMToAppKitOptions: i5 } = await Promise.resolve().then(function() {
          return nt3;
        }), a2 = i5(w4(v6({}, this.rpc.qrModalOptions), { chains: [.../* @__PURE__ */ new Set([...this.rpc.chains, ...this.rpc.optionalChains])], metadata: this.rpc.metadata, projectId: this.rpc.projectId }));
        if (!a2.networks.length) throw new Error("No networks found for WalletConnect");
        e = n4(w4(v6({}, a2), { universalProvider: this.signer, manualWCControl: true }));
      } catch (n4) {
        throw console.warn(n4), new Error("To use QR modal, please install @reown/appkit package");
      }
      if (e) try {
        this.modal = e;
      } catch (n4) {
        throw this.signer.logger.error(n4), new Error("Could not generate WalletConnectModal Instance");
      }
    }
  }
  loadConnectOpts(t) {
    if (!t) return;
    const { chains: e, optionalChains: n4, rpcMap: i5 } = t;
    e && se(e) && (this.rpc.chains = e.map((a2) => this.formatChainId(a2)), e.forEach((a2) => {
      this.rpc.rpcMap[a2] = (i5 == null ? void 0 : i5[a2]) || this.getRpcUrl(a2);
    })), n4 && se(n4) && (this.rpc.optionalChains = [], this.rpc.optionalChains = n4 == null ? void 0 : n4.map((a2) => this.formatChainId(a2)), n4.forEach((a2) => {
      this.rpc.rpcMap[a2] = (i5 == null ? void 0 : i5[a2]) || this.getRpcUrl(a2);
    }));
  }
  getRpcUrl(t, e) {
    var n4;
    return ((n4 = this.rpc.rpcMap) == null ? void 0 : n4[t]) || `${U6}?chainId=eip155:${t}&projectId=${e || this.rpc.projectId}`;
  }
  async loadPersistedSession() {
    if (this.session) try {
      const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), e = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];
      this.setChainIds(t ? [this.formatChainId(t)] : e == null ? void 0 : e.accounts), this.setAccounts(e == null ? void 0 : e.accounts);
    } catch (t) {
      this.signer.logger.error("Failed to load persisted session, clearing state..."), this.signer.logger.error(t), await this.disconnect().catch((e) => this.signer.logger.warn(e));
    }
  }
  reset() {
    this.chainId = 1, this.accounts = [];
  }
  persist() {
    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
  }
  parseAccounts(t) {
    return typeof t == "string" || t instanceof String ? [this.parseAccount(t)] : t.map((e) => this.parseAccount(e));
  }
};
var Y4 = b6;
var H3 = Object.defineProperty;
var B4 = Object.defineProperties;
var F4 = Object.getOwnPropertyDescriptors;
var S6 = Object.getOwnPropertySymbols;
var X3 = Object.prototype.hasOwnProperty;
var J3 = Object.prototype.propertyIsEnumerable;
var T4 = (s3, t, e) => t in s3 ? H3(s3, t, { enumerable: true, configurable: true, writable: true, value: e }) : s3[t] = e;
var R4 = (s3, t) => {
  for (var e in t || (t = {})) X3.call(t, e) && T4(s3, e, t[e]);
  if (S6) for (var e of S6(t)) J3.call(t, e) && T4(s3, e, t[e]);
  return s3;
};
var Z2 = (s3, t) => B4(s3, F4(t));
function tt3(s3) {
  if (s3) return { "--w3m-font-family": s3["--wcm-font-family"], "--w3m-accent": s3["--wcm-accent-color"], "--w3m-color-mix": s3["--wcm-background-color"], "--w3m-z-index": s3["--wcm-z-index"] ? Number(s3["--wcm-z-index"]) : void 0, "--w3m-qr-color": s3["--wcm-accent-color"], "--w3m-font-size-master": s3["--wcm-text-medium-regular-size"], "--w3m-border-radius-master": s3["--wcm-container-border-radius"], "--w3m-color-mix-strength": 0 };
}
var et3 = (s3) => {
  const [t, e] = s3.split(":");
  return W3({ id: e, caipNetworkId: s3, chainNamespace: t, name: "", nativeCurrency: { name: "", symbol: "", decimals: 8 }, rpcUrls: { default: { http: ["https://rpc.walletconnect.org/v1"] } } });
};
function st2(s3) {
  var t, e, n4, i5, a2, o2, u3;
  const c6 = (t = s3.chains) == null ? void 0 : t.map(et3).filter(Boolean);
  if (c6.length === 0) throw new Error("At least one chain must be specified");
  const l6 = c6.find((m3) => {
    var h6;
    return m3.id === ((h6 = s3.defaultChain) == null ? void 0 : h6.id);
  }), r2 = { projectId: s3.projectId, networks: c6, themeMode: s3.themeMode, themeVariables: tt3(s3.themeVariables), chainImages: s3.chainImages, connectorImages: s3.walletImages, defaultNetwork: l6, metadata: Z2(R4({}, s3.metadata), { name: ((e = s3.metadata) == null ? void 0 : e.name) || "WalletConnect", description: ((n4 = s3.metadata) == null ? void 0 : n4.description) || "Connect to WalletConnect-compatible wallets", url: ((i5 = s3.metadata) == null ? void 0 : i5.url) || "https://walletconnect.org", icons: ((a2 = s3.metadata) == null ? void 0 : a2.icons) || ["https://walletconnect.org/walletconnect-logo.png"] }), showWallets: true, featuredWalletIds: s3.explorerRecommendedWalletIds === "NONE" ? [] : Array.isArray(s3.explorerRecommendedWalletIds) ? s3.explorerRecommendedWalletIds : [], excludeWalletIds: s3.explorerExcludedWalletIds === "ALL" ? [] : Array.isArray(s3.explorerExcludedWalletIds) ? s3.explorerExcludedWalletIds : [], enableEIP6963: false, enableInjected: false, enableCoinbase: true, enableWalletConnect: true, features: { email: false, socials: false } };
  if ((o2 = s3.mobileWallets) != null && o2.length || (u3 = s3.desktopWallets) != null && u3.length) {
    const m3 = [...(s3.mobileWallets || []).map((g3) => ({ id: g3.id, name: g3.name, links: g3.links })), ...(s3.desktopWallets || []).map((g3) => ({ id: g3.id, name: g3.name, links: { native: g3.links.native, universal: g3.links.universal } }))], h6 = [...r2.featuredWalletIds || [], ...r2.excludeWalletIds || []], d4 = m3.filter((g3) => !h6.includes(g3.id));
    d4.length && (r2.customWallets = d4);
  }
  return r2;
}
function W3(s3) {
  return R4({ formatters: void 0, fees: void 0, serializers: void 0 }, s3);
}
var nt3 = Object.freeze({ __proto__: null, convertWCMToAppKitOptions: st2, defineChain: W3 });
export {
  Y4 as EthereumProvider,
  P3 as OPTIONAL_EVENTS,
  A4 as OPTIONAL_METHODS,
  C6 as REQUIRED_EVENTS,
  f8 as REQUIRED_METHODS,
  b6 as default
};
/*! Bundled license information:

@walletconnect/utils/dist/index.es.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=index.es-DI564XWV.js.map
